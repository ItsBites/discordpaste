require 'exoskeleton'

Backbone = require 'backbone'
Application = require 'application'
routes = require 'routes'
Davy = require 'davy'

require 'console-polyfill'

# Set Deferred to Davy.js deferred.
Backbone.Deferred = ->
  p = new Davy
  promise: p, resolve: p.fulfill.bind(p), reject: p.reject.bind(p)

# Initialize the application on DOM ready event.
document.addEventListener 'DOMContentLoaded', ->
  new Application {
    title: 'Ost.io',
    controllerSuffix: '-controller',
    routes
  }
, false

Chaplin = require 'chaplin'

# Application-specific utilities
# ------------------------------

# Delegate to Chaplinâ€™s utils module
utils = Chaplin.utils.beget Chaplin.utils

# Backbone.utils.extend utils,
#   method: ->

module.exports = utils

do ->
  'use strict'

  Pongstgrm = (element, options) ->
    this.element = if element then element else '<div/>'
    this.options = $.extend {}, Pongstgrm.DEFAULT, options
    this.instgrm = 'https://api.instagram.com/v1'
    this.authenticate()
    return this

  Pongstgrm.VERSION = '0.1.0'
  Pongstgrm.DEFAULT = {
    # User Authentication
    accessId:     undefined   # {String}: Access ID acquired from Instagram.
    accessToken:  undefined   # {String}: Access token acquired from Instagram.

    # Display Options
    show:         'recent'    # {String}: possible options are liked, recent, profile and tag.
    count:        5           # {Number}: default number of media to be displayed.
    likes:        true        # {Boolean}: show/hide likes count.
    comments:     true        # {Boolean}: show/hide comments
    timestamp:    true        # {Boolean}: show/hide media timestamp.
    flexbox:      true        # {Boolean|String}: if true/false it uses the built-in flexbox in the css, otherwise it will use custom-styles set for that selector

    # Plugin Components
    avatar_size:  64          # {String}: profile picture dimensions in square format e.g., (128 == 128x128 pixels)
    cover_photho: undefined   # {String}: valid image uri
  }

  Pongstgrm.prototype.html = () ->
    that = this

    ###
    # @name thumb
    # @desc render thumbnail markup
    # @params context, is the media's metadata
    # @returns rendered HTML string that is injected to the plugin container
    ###
    @thumb = (context) ->
      likes_count = if context.likes.count >= 2 then 'Likes' else 'Like'
      likes_html  = that.options.likes and "
        <span class='pongstgrm-likes'>
          <i class='pongstgrm-icon-like'></i>&nbsp;
          <small>#{context.likes.count}</small>
        </span>"

      comments_count = if context.comments >= 2 then 'Comment' else 'Comments'
      comments_html  = that.options.comments and "
        <span class='pongstgrm-comments'>
          <i class='pongstgrm-icon-chat'></i>&nbsp;
          <small>#{context.comments.count}</small>
        </span>"

      video = if context.type == 'video' then "
        <span class='pongstgrm-item-video'>
          <i class='pongstgrm-icon-play'></i>
        </span>" else ""

      created = that.options.timestamp and "
        #{new Date(context.created_time * 1000).toDateString()}"

      return "
        <div class='pongstgrm-item'>
          <div class='pongstgrm-item-content'>
            <small class='pongstgrm-item-date'>#{created}</small>
            <img class='pongstgrm-img-responsive' alt=''
              src='#{context.images.low_resolution.url}'
              width='#{context.images.low_resolution.width}'
              height='#{context.images.low_resolution.height}'>#{video}
            <div class='pongstgrm-item-toolbar'>
              #{likes_html} &nbsp; &nbsp; #{comments_html}
            </div>
          </div>
        </div>"

    @modal = (context) ->
    @video = (context) ->
    return { @thumb, @modal, @video }

  # Kicstart the Plugin
  Pongstgrm.prototype.initialize = () ->
    that = this
    that.gallery  = {}
    that.instgrm += '/users/'
    flexbox = if typeof @options.flexbox == 'boolean' then 'flexbox' else @options.flexbox

    getMedia = (endpoint, callback) ->
      $.get endpoint, ((data) ->
        if that.mode == 'profile'
          return callback and callback(data)
        if that.mode == 'gallery'
          data.data.forEach (e, i, a) ->
            $(that.element).append that.html().thumb(e)
          return callback and callback(data)
      ), 'jsonp'

    ###
    # @name
    # @desc
    # @params
    # @returns
    ###
    @gallery.feed = () ->
      that.mode = 'gallery'
      that.instgrm += 'self/feed?' + $.param
        count: that.options.count
        access_token: that.options.access_token
      return getMedia "#{that.instgrm}", (data) ->
        return

    ###
    # @name Liked Media
    # @desc
    #   Get the list of recent media liked by the owner of the access_token.
    #   https://www.instagram.com/developer/endpoints/users/#get_users_feed_liked
    # @params
    #   - ACCESS_TOKEN:	A valid access token.
    #   - COUNT:	Count of media to return.
    #   - MAX_LIKE_ID:	Return media liked before this id.
    # @returns {String}
    #   an HTML string with the media context. The HTML is
    #   appended to the element container. $('#selector').pongstgrm()
    ###
    @gallery.liked = () ->
      that.mode     = 'gallery'
      that.instgrm += 'self/media/liked?' + $.param
        count: that.options.count
        access_token: that.options.accessToken
      return getMedia "#{that.instgrm}", (data) ->
        $(that.element).append "<pre>#{JSON.stringify data.data, null, 2}</pre>"
        return

    ###
    # @name
    # @desc
    # @params
    # @returns
    ###
    @gallery.profile = () ->
      that.mode     = 'profile'
      that.instgrm += "#{that.options.accessId}?" + $.param
        access_token: that.options.accessToken
      return getMedia "#{that.instgrm}", (data) ->
        $(that.element).append "<pre>#{JSON.stringify data.data, null, 2}</pre>"

    ###
    # @name Recent Media
    # @desc
    #   Get the most recent media published by the owner of the access_token
    #   https://www.instagram.com/developer/endpoints/users/#get_users_media_recent_self
    # @params
    #   - ACCESS_TOKEN: A valid access token
    #   - COUNT: Count of media to return
    #   - MIN_ID: (not used in this fn)
    #   - MAX_ID: (not used in this fn)
    # @returns {String}
    #   an HTML string with the media context. The HTML is
    #   appended to the element container. $('#selector').pongstgrm()
    ###
    @gallery.recent = () ->
      that.mode     = 'gallery'
      that.instgrm += 'self/media/recent?' + $.param
        count: that.options.count
        access_token: that.options.accessToken
      getMedia "#{that.instgrm}", (data) ->
        $(that.element).append "<pre>#{JSON.stringify data.data, null, 2}</pre>"



    $(@element).addClass "pongstgrm #{flexbox}"
    @gallery[that.options.show] and @gallery[that.options.show]()

  # Authenticate to Instagram
  Pongstgrm.prototype.authenticate = () ->
    if @options.accessId != undefined or @options.accessToken != undefined
      @initialize()
      return true
    else
      console.info "%cInstagram Access ID and Token to access your media.
        You may access public media by using `{ show: \'tag-you-like\' }", 'color:green'
      return false

  # Plugin Definition
  $.fn.pongstgrm = (option) ->
    opt = $.extend {}, $.fn.pongstgrm.default, option
    i = 0
    while i < arguments.length
      if typeof arguments[i] == 'function'
        opt.callback = arguments[i]()
      if typeof arguments[i] == 'object'
        opt[arguments[i]]
      i++
    return this.each () ->
      new Pongstgrm($(this)[0], opt)
      return

  # Plugin default Options
  $.fn.pongstgrm.options = Pongstgrm.DEFAULT
  return

  getFullName = require(__dirname + '/helpers').getFullName


documentModule = (script, parser) ->
    ###
    Given a module's source code and an AST parser, returns module information
    in the form:
        {
            "docstring": "Module docstring",
            "deps": {"dep1": "foo", "dep2": "bar/baz", ...},
            "classes": [class1, class1...],
            "functions": [func1, func2...],
            "privateFunctions": [func1, func2...]
        }
    AST parsers are defined in the `parsers.coffee` module
    ###
    nodes = parser.getNodes(script)
    first_obj = nodes[0]
    if first_obj?.type == 'Comment'
        docstring = formatDocstring(first_obj.comment)
    else
        docstring = null

    deps = parser.getDependencies(nodes)
    functionNodes = parser.getFunctions(nodes)
    classNodes = parser.getClasses(nodes)

    classes = []
    functions = []
    privateFunctions = []

    classLookup = {}
    for node in classNodes
        cls = documentClass(node)
        classes.push(cls)
        classLookup[cls.name] = cls

    for node in functionNodes
        func = documentFunction(node)
        if _isPrivateFunction(node)
            privateFunctions.push(func)
        else if cls = classLookup[node.variable.base.value]
            func.name = func.name[cls.name.length+1..]
            cls.staticmethods.push(func)
        else
            functions.push(func)

    return {docstring, deps, classes, functions, privateFunctions}


documentClass = (cls) ->
    ###
    Evaluates a class object as returned by the coffeescript parser, returning
    an object of the form:
        {
            "name": "MyClass",
            "docstring": "First comment following the class definition"
            "parent": "MySuperClass",
            "methods": [method1, method2...],
            "lineno": 123
        }
    ###
    if cls.type == 'Assign'
        # Class assigned to variable -- ignore the variable definition
        cls = cls.value

    expressions = cls.body.expressions
    firstObj = expressions[0]

    # Classes that do not inherit from other classes seem to end up with a
    # different representation in the AST
    if firstObj?.base?.type == 'Obj'
        firstObj = firstObj.base.objects[0]

    # Get docstring
    if firstObj?.type == 'Comment'
        docstring = formatDocstring(firstObj.comment)
    else
        docstring = null

    # Get methods
    staticmethods = []
    instancemethods = []
    privatemethods = []
    for expr in expressions
        if expr.type == 'Value' and expr.base.objects
            for method in (n for n in expr.base.objects \
                           when n.type == 'Assign' and n.value.type == 'Code')
                if method.variable.this
                    # Method attached to `this`, i.e. the constructor
                    staticmethods.push(method)
                else
                    # Method attached to prototype
                    if method.variable.base.value?.match /^_/
                        privatemethods.push(method)
                    else
                        instancemethods.push(method)
        else if expr.type == 'Assign' and expr.value.type == 'Code'
            # Static method
            if expr.variable.this # Only include public methods
                staticmethods.push(expr)

    if cls.parent?
        parent = getFullName(cls.parent)
    else
        parent = null

    doc = {
        name: getFullName(cls.variable)
        lineno: cls.variable.locationData.first_line
        docstring: docstring
        parent: parent
        staticmethods: (documentFunction(m) for m in staticmethods)
        instancemethods: (documentFunction(m) for m in instancemethods)
        privatemethods: (documentFunction(m) for m in privatemethods)
    }

    for method in doc.staticmethods
        method.name = method.name.replace(/^this\./, '')

    return doc


documentFunction = (func) ->
    ###
    Evaluates a function object as returned by the coffeescript parser,
    returning an object of the form:
        {
            "name": "myFunc",
            "docstring": "First comment following the function definition",
            "params": ["param1", "param2"...],
            "lineno": 123
        }
    ###
    # Get docstring
    first_obj = func.value.body.expressions[0]
    if first_obj?.comment
        docstring = formatDocstring(first_obj.comment)
    else
        docstring = null

    # Get params
    if func.value.params
        params = for p in func.value.params
            if p.name.base?.value == 'this'
                '@' + p.name.properties[0].name.value
            else
                if p.splat then p.name.value + '...' else p.name.value

    else
        params = []

    doc = {
        name: getFullName(func.variable)
        lineno: func.variable.locationData.first_line
        docstring: docstring
        params: params
    }


formatDocstring = (str) ->
    ###
    Given a string, returns it with leading whitespace removed but with
    indentation preserved. Replaces `\\#` with `#` to allow for the use of
    multiple `#` characters in markup languages (e.g. Markdown headers)
    ###
    lines = str.replace(/\\#/g, '#').split('\n')

    # Remove leading blank lines
    while /^\s*$/.test(lines[0])
        lines.shift()
    if lines.length == 0
        return null

    # Get least indented non-blank line
    indentation = for line in lines
        if /^\s*$/.test(line) then continue
        line.match(/^\s*/)[0].length
    indentation = Math.min(indentation...)

    leading_whitespace = new RegExp("^\\s{#{ indentation }}")
    return (line.replace(leading_whitespace, '') for line in lines).join('\n')


_isPrivateFunction = (func) -> func.variable.base.value.match /^_/

exports.documentModule = documentModule

coffeescript = require('coffee-script')
helpers = require(__dirname + '/helpers')

class BaseParser
    ###
    This base class defines the interface for parsers. Custom parsers should
    implement these methods.
    ###
    getNodes: (script) ->
        ###
        Generates the AST from coffeescript source code.  Adds a 'type' attribute
        to each node containing the name of the node's constructor, and returns
        the expressions array
        ###
        rootNode = coffeescript.nodes(script)
        rootNode.traverseChildren false, (node) ->
            node.type = node.constructor.name
        return [].concat(rootNode.expressions, rootNode)

    getDependencies: (nodes) ->
        ###
        Parse require statements and return a hash of module
        dependencies of the form:
            {
                "local.name": "path/to/module"
            }
        ###
        return {}

    getClasses: (nodes) ->
        ###
        Return an array of class nodes. Be sure to include classes that are
        assigned to variables, e.g. `exports.MyClass = class MyClass`
        ###
        return (n for n in nodes when n.type == 'Class' \
                or n.type == 'Assign' and n.value.type == 'Class')

    getFunctions: (nodes) ->
        ###
        Return an array of function nodes.
        ###
        return (n for n in nodes \
                when n.type == 'Assign' and n.value.type == 'Code')


class CommonJSParser extends BaseParser
    ###
    Parses code written according to CommonJS specifications:
        require("module")
        exports.func = ->
    ###
    getDependencies: (nodes) ->
        ###
        This currently works with the following `require` calls:
            local_name = require("path/to/module")
        or
            local_name = require(__dirname + "/path/to/module")
        ###
        stripQuotes = (str) ->
            return str?.replace(/('|\")/g, '')

        deps = {}
        for n in nodes when n.type == 'Assign'
            if n.value.type == 'Call' and n.value.variable.base?.value == 'require'
                arg = n.value.args[0]
                if arg.type == 'Value'
                    modulePath = stripQuotes(arg.base.value)
                else if arg.type == 'Op' and arg.operator == '+' and arg.first.base.value == '__dirname'
                    modulePath = stripQuotes(arg.second.base.value)
                    if modulePath?
                        modulePath = modulePath.replace(/^\//, '')
                else
                    continue
                if n.variable.base.type == 'Obj'
                    vars = n.variable.base.properties
                else
                    vars = [n.variable]
                for v in vars
                    localName = helpers.getFullName(v)
                    deps[localName] = modulePath
        return deps


class RequireJSParser extends BaseParser

    getNodes: (script) ->
        nodes = super(script)
        result_nodes = []
        moduleLdrs = ['define', 'require']
        for root_node in nodes
            root_node.traverseChildren false, (node) ->
                node.type = node.constructor.name
                node.level = 1
                if node.type is 'Call' and node.variable.base.value in moduleLdrs
                    for arg in node.args
                        if arg.constructor.name is 'Code'
                            arg.body.traverseChildren false, (node) ->
                                node.type = node.constructor.name
                                node.level = 2
                            result_nodes = result_nodes.concat(arg.body.expressions)
                        # TODO: Support objects passed to require or define
        return nodes.concat(result_nodes)

    _parseCall: (node, deps) ->
        ### Parse require([], ->) and define([], ->) ###
        mods = []
        args = []

        for arg in node.args
            val1 = helpers.getAttr(arg, 'base')
            val2 = helpers.getAttr(arg, 'base.body.expressions[0]')
            if val1.type is 'Arr'
                mods = this._parseModuleArray(val1)
            else if val2.type is 'Code'
                args = this._parseFuncArgs(val2)
            else if arg.type is 'Code'
                args = this._parseFuncArgs(arg)

        this._matchArgs(deps, mods, args)

    _parseAssign: (node, deps) ->
        ### Parse module = require("path/to/module") ###
        arg = node.value.args[0]
        module_path = this._getModulePath(arg)
        if module_path?
            local_name = helpers.getFullName(node.variable)
            deps[local_name] = module_path

    _parseObject: (node, deps) ->
        ### Parse require = {} ###
        obj = node.value.base
        mods = []
        args = []
        for attr in obj.properties
            name = helpers.getAttr(attr, 'variable.base.value')
            val1 = helpers.getAttr(attr, 'value.base')
            val2 = helpers.getAttr(attr, 'value.base.body.expressions[0]')
            if name is 'deps' and val1.type is 'Arr'
                mods = this._parseModuleArray(val1)
            else if name is 'callback'
                if val2.type is 'Code'
                    args = this._parseFuncArgs(val2)
                else if attr.value.type is 'Code'
                    args = this._parseFuncArgs(attr.value)

        this._matchArgs(deps, mods, args)

    _matchArgs: (deps, mods, args) ->
        ###
        Match the list of modules to the list of local variable names and
        add them to the dependencies object given.
        ###
        index = 0
        for mod in mods
            local_name = if index < args.length then args[index] else mod
            deps[local_name] = mod
            index += 1

    _stripQuotes: (str) ->
        return str?.replace(/('|\")/g, '')

    _parseFuncArgs: (func) ->
        ###
        Given a node of type 'Code', gathers the names of each of the function
        arguments and return them in an array.
        ###
        args = []
        for arg in func.params
            args.push(arg.name.value)
        return args

    _parseModuleArray: (arr) ->
        ###
        Given a node of type 'Arr', gathers the module paths represented by
        each object in the array and returns them in an array.
        ###
        modules = []
        for module in arr.objects
            mod_path = this._getModulePath(module)
            if mod_path?
                modules.push(mod_path)
        return modules

    _getModulePath: (mod) ->
        if mod.type is 'Value'
            return this._stripQuotes(mod.base.value)
        else if mod.type is 'Op' and mod.operator is '+'
            return '.' + this._stripQuotes(mod.second.base.value)
        return null

    getDependencies: (nodes) ->
        ###
        This currently works with the following `require` calls:
            local_name = require("path/to/module")
            local_name = require(__dirname + "/path/to/module")
        The following `require` object assignments:
            require = {deps: ["path/to/module"]}
            require = {deps: ["path/to/module"], callback: (module) ->}
        And the following `require` and `define` calls:
            require(["path/to/module"], (module) -> ...)
            require({}, ["path/to/module"], (module) -> ...)
            define(["path/to/module"], (module) -> ...)
            define('', ["path/to/module"], (module) -> ...)
        ###
        deps = {}
        for n in nodes
            if n.type is 'Call' and n.variable.base.value in ['define', 'require']
                this._parseCall(n, deps)
            else if n.type is 'Assign'
                if n.value.type is 'Call' and n.value.variable.base.value is 'require'
                    this._parseAssign(n, deps)
                else if (n.level is 1 and n.variable.base.value is 'require' \
                         and n.value.base.type is 'Obj')
                    this._parseObject(n, deps)
        return deps


exports.commonjs  = CommonJSParser
exports.requirejs = RequireJSParser

umd = (root, factory) ->
  if typeof define is "function" and define.amd
    define(["angular", "d3", "lodash"], factory)
  else if typeof exports is "object"
    module.exports = factory(require("angular"), require("d3"), require("lodash"))
  else
    root.triangularjs = factory(root.angular, root.d3, root._)

#the actual module
umd(this, (angular, d3, _) ->
  angular.module('triangular', [])
  .factory 'd3ng', ($rootScope) ->
    return {
    animatePath: (newValue, oldValue, duration, updateFrame) ->
      start = null
      interpolate = d3.interpolateArray(oldValue, newValue)

      step = (now) ->
        start ?= now
        progress = now - start
        if (progress < duration)
          requestAnimationFrame(step)
          $rootScope.$apply ->
            updateFrame(interpolate(progress/duration))
          #console.log progress/duration, interpolate(progress/duration)
        else
          $rootScope.$apply ->
            updateFrame(interpolate(1))

      requestAnimationFrame(step)
    }

  .directive "axis", ($parse) ->
    return {
    restrict: 'A'
    scope: {
      scale: '='
      orient: '@'
      ticks: '='
      tickValues: '='
      tickSubdivide: '='
      tickSize: '='
      tickPadding: '='
      tickFormat: '@'
    }
    link: (scope, element) ->
      scope.tickFormat = ($parse scope.tickFormat)(d3: d3)
      axis = d3.svg.axis()

      scope.$watch "attrs", ->
        parameters = ['scale', 'orient', 'ticks', 'tickValues', 'tickSubdivide', 'tickSize', 'tickPadding', 'tickFormat']
        for p in parameters when scope[p]
          axis[p](scope[p])
        axis(element)

      scope.$watch 'scale.domain()', ->
        axis.scale(scope.scale)
        d3.select(element[0]).transition().duration(750).call(axis)
    }

  .directive "lineChart", (d3ng) ->
    return {
    restrict: "E"
    templateUrl: "template/lineChart.html"
    scope:
      width: '='
      height: '='
      marginLeft: '='
      marginRight: '='
      marginTop: '='
      marginBottom: '='
      ticksX: '='
      ticksY: '='
      textX: '='
      textY: '='
      data: '='
      lineColour: '='
      lineWidth: '='
    link: (scope) ->

      scope.total_subs_line = "M0,0"

      scope.$watch "data", (val, oldVal) ->
        scope.x = d3.scale.linear().range([0, scope.width - scope.marginLeft - scope.marginRight])
        scope.y = d3.scale.linear().range([scope.height - scope.marginTop - scope.marginBottom, 0])

        scope.x.domain(d3.extent(val, (d, i) -> i))
        scope.y.domain(d3.extent(val, (d) -> d))

        scope.line = d3.svg.line()
        .x((d, i) -> scope.x(i))
        .y((d) -> scope.y(d))
        .interpolate("cardinal")

        if _.some(val, _.isNaN)
          scope.total_subs_line = "M0,0"
        else if val
          val = val.map Math.round
          oldVal = ((if item then item else 0) for item in oldVal)

          d3ng.animatePath val, oldVal, 750, (value) ->
            scope.total_subs_line = scope.line(value)
        else
          console.warn "not implemented", val
    }

  .directive 'svgDragX', ($document, $parse) ->
    (scope, element, attr) ->
      startX = 0
      x = 0
      svgRootX = 0
      targetX = $parse(attr.svgDragX)

      element.on 'mousedown', (event) ->
        # Prevent default dragging of selected content
        event.preventDefault()

        svgRootX = targetX(scope)
        startX = event.screenX

        $document.on('mousemove', mousemove)
        $document.on('mouseup', mouseup)

      mousemove = (event) ->
        x = event.screenX - startX
        targetX.assign(scope, x + svgRootX)
        scope.$parent.$parent.$digest()

      mouseup = ->
        $document.off('mousemove', mousemove)
        $document.off('mouseup', mouseup)

  .directive 'svgDragY', ($document, $parse) ->
    (scope, element, attr) ->
      startY = 0
      y = 0
      svgRootY = 0
      targetY = $parse(attr.svgDragY)

      element.on 'mousedown', (event) ->
        # Prevent default dragging of selected content
        event.preventDefault()

        svgRootY = targetY(scope)
        startY = event.screenY

        $document.on('mousemove', mousemove)
        $document.on('mouseup', mouseup)

      mousemove = (event) ->
        y = event.screenY - startY
        targetY.assign(scope, y + svgRootY)
        scope.$parent.$parent.$digest()

      mouseup = ->
        $document.off('mousemove', mousemove)
        $document.off('mouseup', mouseup)
)

assert = require 'assert'
fs     = require 'fs'
ns     = require 'netstring'
url    = require 'url'

{Socket} = require 'net'
{Stream} = require 'stream'
{debug}  = require './util'

{BufferedRequest} = require './util'

# A **Client** establishes a connection to a worker process.
#
# It takes a `port` and `host` or a UNIX socket path.
#
# Its API is similar to `http.Client`.
#
#     var conn = client.createConnection('/tmp/nack.sock');
#     var request = conn.request('GET', '/', {'host', 'localhost'});
#     request.end();
#     request.on('response', function (response) {
#       console.log('STATUS: ' + response.statusCode);
#       console.log('HEADERS: ' + JSON.stringify(response.headers));
#       response.on('data', function (chunk) {
#         console.log('BODY: ' + chunk);
#       });
#     });
#
exports.Client = class Client extends Socket
  constructor: ->
    super

    debug "client created"

    # Initialize outgoing array to hold pending requests
    @_outgoing = []
    # Incoming is used to point to the current response
    @_incoming = null

    self = this

    # Once we've made the connect, process the next request
    @on 'connect', -> self._processRequest()

    @on 'error', (err) ->
      if req = self._outgoing[0]
        req.emit 'error', err

    # Finalize the request on close
    @on 'close', -> self._finishRequest()

    # Initialize the response netstring parser
    @_initResponseParser()

  _initResponseParser: ->
    self = this

    nsStream = new ns.Stream this

    nsStream.on 'data', (data) ->
      if self._incoming
        self._incoming._receiveData data

    nsStream.on 'error', (exception) ->
      self._incoming = null
      self.emit 'error', exception

  _processRequest: ->
    # Process the request now if the socket is open and
    # we aren't already handling a response
    if @readyState is 'open' and !@_incoming
      if request = @_outgoing[0]
        debug "processing outgoing request 1/#{@_outgoing.length}"

        @_incoming = new ClientResponse this, request

        # Flush the request buffer into socket
        request.pipe this
        request.flush()
    else
      # Try to reconnect and try again soon
      @reconnect()

  _finishRequest: ->
    debug "finishing request"

    req = @_outgoing.shift()
    req.destroy()

    res = @_incoming
    @_incoming = null

    if res is null or res.received is false
      req.emit 'error', new Error "Response was not received"
    else if res.readable and not res.statusCode
      req.emit 'error', new Error "Missing status code"
    else if res.readable and not res.headers
      req.emit 'error', new Error "Missing headers"

    # Anymore requests, continue processing
    if @_outgoing.length > 0
      @_processRequest()

  # Reconnect if the connection is closed.
  reconnect: ->
    if @readyState is 'closed' or @readyState is 'readOnly'
      debug "connecting to #{@port}"
      @connect @port, @host

  # Start the connection and create a ClientRequest.
  request: (args...) ->
    request = new ClientRequest args...
    @_outgoing.push request
    @_processRequest()
    request

# Public API for creating a **Client**
exports.createConnection = (port, host) ->
  client = new Client
  client.port = port
  client.host = host
  client

# A **ClientRequest** is returned when `Client.request()` is called.
#
# It is a Writable Stream and responds to the conventional
# `write` and `end` methods.
#
# Its also an EventEmitter with the following events:
#
# > **Event 'response'**
# >
# > `function (response) { }`
# >
# > Emitted when a response is received to this request. This event is
# > emitted only once. The response argument will be an instance of
# > `ClientResponse`.
# >
# > **Event: 'error'**
# >
# > `function (exception) { }`
# >
# > Emitted when an error occurs.
#
exports.ClientRequest = class ClientRequest extends BufferedRequest
  _buildEnv: ->
    env = {}

    env['REQUEST_METHOD'] = @method

    {pathname, query} = url.parse @url
    env['PATH_INFO']    = pathname
    env['QUERY_STRING'] = query ? ""
    env['SCRIPT_NAME']  = ""

    env['REMOTE_ADDR'] = "0.0.0.0"
    env['SERVER_ADDR'] = "0.0.0.0"

    if host = @headers.host
      parts = @headers.host.split ':'
      env['SERVER_NAME'] = parts[0]
      env['SERVER_PORT'] = parts[1]

    env['SERVER_NAME'] ?= "localhost"
    env['SERVER_PORT'] ?= "80"

    for key, value of @headers
      key = key.toUpperCase().replace /-/g, '_'
      key = "HTTP_#{key}" unless key == 'CONTENT_TYPE' or key == 'CONTENT_LENGTH'
      env[key] = value

    for key, value of @proxyMetaVariables
      env[key] = value

    env

  # Write chunk to client
  write: (chunk, encoding) ->
    super ns.nsWrite chunk, 0, chunk.length, null, 0, encoding

  # Closes writting socket.
  end: (chunk, encoding) ->
    if (chunk)
      @write chunk, encoding
    super ""

  flush: ->
    # Write Env header if queue hasn't been flushed
    if @_queue
      debug "requesting #{@method} #{@url}"
      chunk   = JSON.stringify @_buildEnv()
      nsChunk = ns.nsWrite chunk, 0, chunk.length, null, 0, 'utf8'
      debug "writing header #{nsChunk.length} bytes"
      @emit 'data', nsChunk

    super

# A **ClientResponse** is emitted from the client request's
# `response` event.
#
# It is a Readable Stream and emits the conventional events:
#
# > **Event: 'data'**
# >
# > `function (chunk) { }`
# >
# > Emitted when a piece of the message body is received.
#
# > **Event: 'end'**
# >
# > `function () { }`
# >
# > Emitted exactly once for each message. No arguments. After emitted
# > no other events will be emitted on the request.
# >
# > **Event: 'error'**
# >
# > `function (exception) { }`
# >
# > Emitted when an error occurs.
#
exports.ClientResponse = class ClientResponse extends Stream
  constructor: (@socket, @request) ->
    @client      = @socket
    @readable    = true
    @writable    = true
    @received    = false
    @completed   = false
    @statusCode  = null
    @httpVersion = '1.1'
    @headers     = null
    @_buffer     = null

  _receiveData: (data) ->
    debug "received #{data.length} bytes"

    return if !@readable or @completed
    @received = true

    try
      if data.length > 0
        # The first response part is the status
        if !@statusCode
          @statusCode = parseInt data
          assert.ok @statusCode >= 100, "Status must be >= 100"

        # The second part is the JSON encoded headers
        else if !@headers
          @headers = {}

          rawHeaders = JSON.parse data
          assert.ok rawHeaders, "Headers can not be null"
          assert.equal typeof rawHeaders, 'object', "Headers must be an object"

          for k, vs of rawHeaders
            # Support legacy Array headers
            vs = vs.join "\n" if vs.join

            # Split multiline Rack headers
            v = vs.split "\n"

            @headers[k] = if v.length > 1
              v
            else
              vs

          debug "response received: #{@statusCode}"

          if @_path = @headers['X-Sendfile']
            delete @headers['X-Sendfile']

            fs.stat @_path, (err, stat) =>
              unless stat.isFile()
                err = new Error "#{@_path} is not a file"

              if err
                @onError err
              else
                @headers['Content-Length'] = "#{stat.size}"
                @headers['Last-Modified']  = "#{stat.mtime.toUTCString()}"

                @request.emit 'response', this

                fs.createReadStream(@_path).pipe this
          else
            # Emit response once we've received the status and headers
            @request.emit 'response', this

        # Else its body parts
        else if data.length > 0 and not @_path
          @write data

      # Empty string means EOF
      else if not @_path
        @end()

    catch error
      # See if payload is an exception backtrace
      exception = try JSON.parse data
      if exception and exception.name and exception.message
        error       = new Error exception.message
        error.name  = exception.name
        error.stack = exception.stack

      @onError error

  onError: (error) ->
    debug "response error", error

    @readable = false
    @socket.emit 'error', error

  write: (data) ->
    return if not @readable or @completed

    @emit 'data', data

  end: (data) ->
    return if not @readable or @completed

    @emit 'data', data if data

    assert.ok @statusCode, "Missing status code"
    assert.ok @headers, "Missing headers"

    debug "response complete"

    @readable  = false
    @completed = true

    @emit 'end'

  pipe: (dest, options) ->
    # Detect when we are piping to another HttpResponse and copy over headers
    if dest.writeHead
      # Don't enable chunked encoding
      dest.useChunkedEncodingByDefault = false

      dest.writeHead @statusCode, @headers

      # Force chunkedEncoding off and pass through whatever data comes from the client
      dest.chunkedEncoding = false

    super

	{ Crypto, convert: { bytesToHex, base64ToBytes } } = require 'bitcoinjs-lib'
{ UTF8 } = Crypto.charenc
{ error_displayer } = require './lib/util.coffee'
{ get_address, parse_address, get_pub, ADDR_PUB, ADDR_PRIV } = require '../lib/bitcoin/index.coffee'
Key = require '../lib/bitcoin/key.coffee'
view = require './views/sign-message-dialog.jade'

# Sign terms with a public or private key
#
# If a public key is given, popup a dialog instructing the user to sign offline
sign_message_any = (key, message, cb) ->
  message = UTF8.stringToBytes message if typeof message is 'string'

  try
    if key.priv?     then cb null, key.sign_message message
    else if key.pub? then sign_message_dialog key, message, cb
    else throw new Error 'Invalid key'
  catch err then cb err

sign_message_dialog = (key, message, cb) ->
  dialog = $ view address: (get_address key.pub, ADDR_PUB), message: UTF8.bytesToString message
  display_error = error_displayer dialog.find('.errors')

  dialog.submit (e) ->
    e.preventDefault()
    try
      # Use user-provided private key
      if priv_text = dialog.find('input:visible[name=priv]').val()
        input_key = new Key 'priv', parse_address priv_text, ADDR_PRIV
        throw new Error 'Invalid private key provided' unless (bytesToHex input_key.pub) is (bytesToHex key.pub)
        cb null, input_key.sign_message message
      # Use user-provided signature
      else if sig = dialog.find('textarea:visible[name=sig]').val()
        sig = base64ToBytes sig
        throw new Error 'Invalid signature provided' unless key.verify_sig message, sig
        cb null, sig
      else throw new Error 'Please provide the private key or the signature'
      dialog.modal('hide')
    catch err then display_error err

  dialog.on 'hidden', -> do dialog.remove
  dialog.modal backdrop: 'static'

module.exports = sign_message_any

u = require 'underscore'

class Attribute
  constructor: (@relation, @name) ->
    Expressions = require './expressions'
    Predications = require './predications'
    u(@).extend Expressions
    u(@).extend Predications


exports = module.exports = Attribute

u = require 'underscore'
SelectManager = require './select-manager'
Range = require './range'

Predications =
  nodes: ->
    require './nodes/nodes'

  as: (other) ->
    n = @nodes()
    lit = new n.UnqualifiedName(other)
    new n.As @, lit
    
  notEq: (other) ->
    n = @nodes()
    new n.NotEqual @, other
  
  notEqAny: (others) ->
    @groupingAny 'not_eq', others
    
  notEqAll: (others) ->
    @groupingAll 'not_eq', others

  isNull: -> new (@nodes()).IsNull(@)
  notNull: -> new (@nodes()).NotNull(@)
    
  eq: (other) ->
    n = @nodes()
    new n.Equality @, other
    
  eqAny: (others) ->
    @groupingAny 'eq', others
    
  eqAll: (others) ->
    @groupingAll 'eq', others
    
  # TODO Ranges won't work here. Should support an array.
  in: (other) ->
    n = @nodes()
    switch other.constructor
      when SelectManager
        new n.In(@, other.ast)
      when Range
        new n.Between(@, new n.And([other.start, other.finish])) # Start and finish from range.
      else
        new n.In @, other
    
  inAny: (others) ->
    @groupingAny 'in', others
    
  inAll: (others) ->
    @groupingAll 'in', others
    
  # TODO Ranges won't work here. Should support an array.
  notIn: (other) ->
    n = @nodes()
    switch other.constructor
      when SelectManager
        new n.NotIn(@, other.ast)
      else
        new n.NotIn(@, other)
  
  notInAny: (others) ->
    @groupingAny 'not_in', others
    
  notInAll: (others) ->
    @groupingAll 'not_in', others
    
  matches: (other) ->
    n = @nodes()
    new n.Matches @, other
    
  matchesAny: (others) ->
    @groupingAny 'matches', others
    
  matchesAll: (others) ->
    @groupingAll 'matches', others
    
  doesNotMatch: (other) ->
    n = @nodes()
    new n.DoesNotMatch @, other
    
  doesNotMatchAny: (others) ->
    @groupingAny 'does_not_match', others
    
  doesNotMatchAll: (others) ->
    @groupingAll 'does_not_match', others
    
  # Greater than
  gteq: (right) ->
    n = @nodes()
    new n.GreaterThanOrEqual @, right
    
  gteqAny: (others) ->
    @groupingAny 'gteq', others
    
  gteqAll: (others) ->
    @groupingAll 'gteq', others
    
  gt: (right) ->
    n = @nodes()
    new n.GreaterThan @, right
    
  gtAny: (others) ->
    @groupingAny 'gt', others
    
  gtAll: (others) ->
    @groupingAll 'gt', others
    
  # Less than
  lteq: (right) ->
    n = @nodes()
    new n.LessThanOrEqual @, right
    
  lteqAny: (others) ->
    @groupingAny 'lteq', others
    
  lteqAll: (others) ->
    @groupingAll 'lteq', others
    
  lt: (right) ->
    n = @nodes().LessThan
    new n(@, right)
    
  ltAny: (others) ->
    @groupingAny 'lt', others
    
  ltAll: (others) ->
    @groupingAll 'lt', others

  like: (right) -> new (@nodes()).Like(@, right)
  ilike: (right) -> new (@nodes()).ILike(@, right)
    
  asc: ->
    n = @nodes()
    new n.Ordering @, 'asc'
    
  desc: ->
    n = @nodes()
    new n.Ordering @, 'desc'
    
  groupingAny: (methodId, others) ->
    others = u(others).clone()
    first = others[methodId](others.shift())
    
    n = @nodes()
    new n.Grouping u(others).reduce first, (memo, expr) ->
      new n.Or([memo, @[methodId](expr)])
    
  groupingAll: (methodId, others) ->
    others = u(others).clone()
    first = others[methodId](others.shift())
    
    n = @nodes()
    new n.Grouping u(others).reduce first, (memo, expr) ->
      new n.And([memo, @[methodId](expr)])

exports = module.exports = Predications

u = require 'underscore'
TreeManager = require './tree-manager'
UpdateStatement = require './nodes/update-statement'
Nodes = require './nodes/nodes'

class UpdateManager extends TreeManager
  constructor: ->
    super()
    @ast = new UpdateStatement()
    @ctx = @ast

  take: (limit) ->
    @ast.limit = new Nodes.Limit(limit) if limit?
    @

  key: (key) ->
    @ast.key = key

  order: (expr...) ->
    @ast.orders = expr
    @

  table: (table) ->
    @ast.relation = table
    @

  wheres: (expr...) ->
    @ast.wheres = expr

  where: (expr) ->
    @ast.wheres.push expr
    @

  set: (values) ->
    if values.constructor == String
      @ast.values = [values]
    else if values.constructor == Nodes.SqlLiteral
      @ast.values = [values]
    else
      @ast.values = values.map (val) =>
        column = val[0]
        value = val[1]
        new Nodes.Assignment(new Nodes.UnqualifiedName(column), value)
    @

exports = module.exports = UpdateManager

$ ->
  checksum = (string) ->
    chk = 0
    for i, chr of string
      chk += chr.charCodeAt(0) * (i + 1)
    chk % 10

  $('#save-button').click () ->
    input = $('#input-field').get(0).value
    deflated = RawDeflate.deflate input
    base64 = Base64.toBase64 deflated
    check = checksum base64
    encoded = base64 + check
    window.location.hash = encoded

  if window.location.hash
    encoded = window.location.hash.replace /^#/, ''
    base64 = encoded[0..encoded.length - 2]
    check = parseInt(encoded[encoded.length - 1..encoded.length])
    unless check == checksum(base64)
      alert 'Something got corrupted :('
    else
      deflated = Base64.fromBase64 base64
      input = RawDeflate.inflate deflated
      $('#input-field').get(0).value = input

	# By Frank Leenaars
# University of Twente - Department of Instructional Technology
# Licensed under the MIT license
"use strict"

# TODO:
# - use "for element, i in ..." where appropriate
# - chained comparisons: 1 < x < 100
# - disallow chains crossing gears' axes? (if gear on higher level)
# - allow gears to overlap other gears' axes when the larger gear is on a higher level?

# imports
Point = window.gearsketch.Point
ArcSegment = window.gearsketch.ArcSegment
LineSegment = window.gearsketch.LineSegment
Util = window.gearsketch.Util
Gear = window.gearsketch.model.Gear
Chain = window.gearsketch.model.Chain
Board = window.gearsketch.model.Board

# -- constants --
FPS = 60
MIN_GEAR_TEETH = 8
MIN_MOMENTUM = 0.2

# ---------------------------
# -------- GearSketch -------
# ---------------------------
class GearSketch
  # -- imported constants --
  MODULE = Util.MODULE
  AXIS_RADIUS = Util.AXIS_RADIUS

  BUTTON_INFO = [
    ["playButton", "PlayIcon.png"]
    ["clearButton", "ClearIcon.png"]
    ["cloudButton", "CloudIcon.png"]
    ["helpButton", "HelpIcon.png"]
  ]

  MovementAction =
    PEN_DOWN: "penDown"
    PEN_UP: "penUp"
    PEN_TAP: "penTap"

  MovementType =
    STRAIGHT: "straight"
    CIRCLE: "circle"
    LEFT_HALF_CIRCLE: "leftHalfCircle"
    RIGHT_HALF_CIRCLE: "rightHalfCircle"

  Action =
    DRAGGING: "dragging"
    SETTING_MOMENTUM: "settingMomentum"
    STROKING: "stroking"

  buttons: {}
  loadedButtons: 0
  areButtonsLoaded: false

  gearImages: {}

  currentAction: null
  isPenDown: false
  stroke: []
  offset: new Point()
  isPlaying: false

  message: ""
  messageColor: "black"

  # usage demo
  pointerLocation: new Point()
  currentDemoMovement: 0
  movementCompletion: 0
  restTimer: 0

  # Passing false to showButtons will hide them, unless the demo is
  # playing. This comes handy when adding controls outside the canvas.
  constructor: (showButtons = true) ->
    @loadButtons()
    @showButtons = showButtons
    @loadDemoPointer()
    @loadBoard()
    @canvas = document.getElementById("gearsketch_canvas")
    @canvasOffsetX = @canvas.getBoundingClientRect().left
    @canvasOffsetY = @canvas.getBoundingClientRect().top
    @isDemoPlaying = false
    @updateCanvasSize()
    @addCanvasListeners()
    @lastUpdateTime = new Date().getTime()
    @updateAndDraw()

  buttonLoaded: ->
    @loadedButtons++
    if @loadedButtons is BUTTON_INFO.length
      @areButtonsLoaded = true

  loadButtons: ->
    x = y = 20
    for [name, file] in BUTTON_INFO
      button = new Image()
      button.name = name
      button.onload = => @buttonLoaded()
      button.src = "img/" + file
      button.location = new Point(x, y)
      button.padding = 3
      @buttons[name] = button
      x += 80

  loadDemoPointer: ->
    image = new Image()
    image.onload = => @pointerImage = image
    image.src = "img/hand.png"

  loadBoard: ->
    @board =
      if parent.location.hash.length > 1
        try
          hash = parent.location.hash.substr(1)
          boardJSON = Util.sendGetRequest("boards/#{hash}.txt")
          Board.fromObject(JSON.parse(boardJSON))
        catch error
          @displayMessage("Error: could not load board", "red", 2000)
          new Board()
      else
        new Board()
    @addGearImage(gear) for id, gear of @board.getGears()

  displayMessage: (message, color = "black", time = 0) ->
    @message = message
    @messageColor = color
    if time > 0
      setTimeout((=> @clearMessage()), time)

  clearMessage: ->
    @message = ""

  shouldShowButtons: ->
    return @showButtons or @isDemoPlaying

  # Input callback methods
  addCanvasListeners: ->
    canvasEventHandler = Hammer(@canvas, {drag_min_distance: 1})
    canvasEventHandler.on("touch", ((e) => @forwardPenDownEvent.call(this, e)))
    canvasEventHandler.on("drag", ((e) => @forwardPenMoveEvent.call(this, e)))
    canvasEventHandler.on("release", ((e) => @forwardPenUpEvent.call(this, e)))

  forwardPenDownEvent: (event) ->
    event.gesture.preventDefault()
    if @isDemoPlaying
      @stopDemo()
    else
      x = event.gesture.center.pageX - @canvasOffsetX
      y = event.gesture.center.pageY - @canvasOffsetY
      @handlePenDown(x, y)

  forwardPenMoveEvent: (event) ->
    event.gesture.preventDefault()
    unless @isDemoPlaying
      x = event.gesture.center.pageX - @canvasOffsetX
      y = event.gesture.center.pageY - @canvasOffsetY
      @handlePenMove(x, y)

  forwardPenUpEvent: (event) ->
    unless @isDemoPlaying
      @handlePenUp()

  handlePenDown: (x, y) ->
    point = new Point(x, y)
    if @isPenDown
      # pen released outside of canvas
      @handlePenUp()
    else
      @isPlaying = false
      button = @getButtonAt(x, y)
      if button
        if button.name is "playButton"
          @isPlaying = true
          if @board.getGearList().every((g) -> g.momentum is 0)
            @displayMessage("Add some arrows!", "black", 2000)
        else if button.name is "clearButton"
          # remove hash from url and clear board
          parent.location.hash = ""
          @board.clear()
        else if button.name is "cloudButton"
          @uploadBoard()
        else if button.name is "helpButton"
          @playDemo()
      else
        {gear, selection} = @gearAt(x,y)
        if gear
          @selectedGear = gear
          if selection is "center"
            @currentAction = Action.DRAGGING
            @offset = point.minus(@selectedGear.location)
          else
            @currentAction = Action.SETTING_MOMENTUM
            @selectedGear.momentum = 0
            @selectedGearMomentum = @calculateMomentumFromCoords(@selectedGear, x, y)
        else
          @currentAction = Action.STROKING
          @stroke.push(point)
        @isPenDown = true


  handlePenMove: (x, y) ->
    point = new Point(x, y)
    if @isPenDown
      if @currentAction is Action.DRAGGING
        goalLocation = point.minus(@offset)
        canPlaceGear = @board.placeGear(@selectedGear, goalLocation)
        if canPlaceGear
          @goalLocationGear = null
        else
          @goalLocationGear =
            new Gear(goalLocation, @selectedGear.rotation, @selectedGear.numberOfTeeth, @selectedGear.id)
      else if @currentAction is Action.SETTING_MOMENTUM
        @selectedGearMomentum = @calculateMomentumFromCoords(@selectedGear, x, y)
      else if @currentAction is Action.STROKING
        @stroke.push(point)

  handlePenUp: ->
    if @isPenDown
      if @currentAction is Action.SETTING_MOMENTUM
        if Math.abs(@selectedGearMomentum) > MIN_MOMENTUM
          @selectedGear.momentum = @selectedGearMomentum
        else
          @selectedGear.momentum = 0
        @selectedGearMomentum = 0
      else if @currentAction is Action.STROKING
        @processStroke()
      @selectedGear = null
      @goalLocationGear = null
      @isPenDown = false
      @currentAction = null

  isButtonAt: (x, y, button) ->
    x > button.location.x and
    x < button.location.x + button.width + 2 * button.padding and
    y > button.location.y and
    y < button.location.y + button.height + 2 * button.padding

  getButtonAt: (x, y) ->
    if not @shouldShowButtons()
        return null

    for own buttonName, button of @buttons
      if @isButtonAt(x, y, button)
        return button
    null

  gearAt: (x, y) ->
    point = new Point(x, y)
    gear = @board.getGearAt(point)
    if not gear
      {gear: null}
    else if gear.location.distance(point) < 0.5 * gear.outerRadius
      {gear: gear, selection: "center"}
    else
      {gear: gear, selection: "edge"}

  normalizeStroke: (stroke) ->
    MIN_POINT_DISTANCE = 10
    normalizedStroke = []
    if stroke.length > 0
      [p1, strokeTail...] = stroke
      normalizedStroke.push(p1)
      for p2 in strokeTail
        if p1.distance(p2) > MIN_POINT_DISTANCE
          normalizedStroke.push(p2)
          p1 = p2
    normalizedStroke

  createGearFromStroke: (stroke) ->
    numberOfPoints = stroke.length
    if numberOfPoints > 0
      sumX = 0
      sumY = 0
      minX = Number.MAX_VALUE
      maxX = Number.MIN_VALUE
      minY = Number.MAX_VALUE
      maxY = Number.MIN_VALUE
      for p in stroke
        sumX += p.x
        sumY += p.y
        minX = Math.min(minX, p.x)
        maxX = Math.max(maxX, p.x)
        minY = Math.min(minY, p.y)
        maxY = Math.max(maxY, p.y)
      width = maxX - minX
      height = maxY - minY
      t = Math.floor(0.5 * (width + height) / MODULE)

      # find area, based on http://stackoverflow.com/questions/451426
      # /how-do-i-calculate-the-surface-area-of-a-2d-polygon
      doubleArea = 0
      for p1, i in stroke
        p2 = stroke[(i + 1) % numberOfPoints]
        doubleArea += p1.cross(p2)

      # create a new gear if the stroke is sufficiently circle-like and large enough
      area = Math.abs(doubleArea) / 2
      radius = 0.25 * ((maxX - minX) + (maxY - minY))
      idealTrueAreaRatio = (Math.PI * Math.pow(radius, 2)) / area
      if idealTrueAreaRatio > 0.80 and idealTrueAreaRatio < 1.20 and t > MIN_GEAR_TEETH
        x = sumX / numberOfPoints
        y = sumY / numberOfPoints
        return new Gear(new Point(x, y), 0, t)
    null

  removeStrokedGears: (stroke) ->
    for own id, gear of @board.getTopLevelGears()
      if Util.pointPathDistance(gear.location, stroke, false) < gear.innerRadius
        @board.removeGear(gear)

  gearImageLoaded: (numberOfTeeth, image) ->
    @gearImages[numberOfTeeth] = image

  addGearImage: (gear) ->
    # draw gear on temporary canvas
    gearCanvas = document.createElement("canvas")
    size = 2 * (gear.outerRadius + MODULE) # slightly larger than gear diameter
    gearCanvas.height = size
    gearCanvas.width = size
    ctx = gearCanvas.getContext("2d")
    gearCopy = new Gear(new Point(0.5 * size, 0.5 * size), 0, gear.numberOfTeeth, gear.id)
    @drawGear(ctx, gearCopy)

    # convert canvas to png
    image = new Image()
    image.onload = => @gearImageLoaded(gear.numberOfTeeth, image)
    image.src = gearCanvas.toDataURL("image/png")

  isChainStroked: (stroke) ->
    for own id, chain of @board.getChains()
      if chain.intersectsPath(stroke)
        return true
    false

  removeStrokedChains: (stroke) ->
    for own id, chain of @board.getChains()
      if chain.intersectsPath(stroke)
        @board.removeChain(chain)

  processStroke: ->
    normalizedStroke = @normalizeStroke(@stroke)
    if normalizedStroke.length >= 3
      if Util.findGearsInsidePolygon(normalizedStroke, @board.getGears()).length > 0
        chain = new Chain(normalizedStroke)
        @board.addChain(chain)
      else
        gear = @createGearFromStroke(normalizedStroke)
        if gear?
          if @board.addGear(gear) and !(gear.numberOfTeeth of @gearImages)
            @addGearImage(gear)
        else if @isChainStroked(normalizedStroke)
          @removeStrokedChains(normalizedStroke)
        else
          @removeStrokedGears(normalizedStroke)
    @stroke = []

  calculateMomentumFromCoords: (gear, x, y) ->
    angle = Math.atan2(y - gear.location.y, x - gear.location.x)
    angleFromTop = angle + 0.5 * Math.PI
    if angleFromTop < Math.PI
      angleFromTop
    else
      angleFromTop - 2 * Math.PI

  # -- updating --
  updateAndDraw: =>
    setTimeout((=>
      requestAnimationFrame(@updateAndDraw)
      @update()
      @draw()
    ), 1000 / FPS)

  update: =>
    updateTime = new Date().getTime()
    delta = updateTime - @lastUpdateTime
    if @isPlaying
      @board.rotateAllTurningObjects(delta)
    if @isDemoPlaying
      @updateDemo(delta)
    @lastUpdateTime = updateTime

  # -- rendering --
  drawGear: (ctx, gear, color = "black") ->
    {x, y} = gear.location
    rotation = gear.rotation
    numberOfTeeth = gear.numberOfTeeth

    gearImage = @gearImages[gear.numberOfTeeth]
    if color is "black" and gearImage?
      # use predrawn image instead of drawing it again
      gearImage = @gearImages[gear.numberOfTeeth]
      ctx.save()
      ctx.translate(x, y)
      ctx.rotate(rotation)
      ctx.drawImage(gearImage, -0.5 * gearImage.width, -0.5 * gearImage.height)
      ctx.restore()
      return

    # draw teeth
    angleStep = 2 * Math.PI / numberOfTeeth
    innerPoints = []
    outerPoints = []
    for i in [0...numberOfTeeth]
      for r in [0...4]
        if r is 0 or r is 3
          innerPoints.push(Point.polar((i + 0.25 * r) * angleStep, gear.innerRadius))
        else
          outerPoints.push(Point.polar((i + 0.25 * r) * angleStep, gear.outerRadius))
    ctx.save()
    ctx.fillStyle = "rgba(255, 255, 255, 0.8)"
    ctx.strokeStyle = color
    ctx.lineWidth = 2
    ctx.translate(x, y)
    ctx.rotate(rotation)
    ctx.beginPath()
    ctx.moveTo(gear.innerRadius, 0)
    for i in [0...numberOfTeeth * 2]
      if i % 2 is 0
        ctx.lineTo(innerPoints[i].x, innerPoints[i].y)
        ctx.lineTo(outerPoints[i].x, outerPoints[i].y)
      else
        ctx.lineTo(outerPoints[i].x, outerPoints[i].y)
        ctx.lineTo(innerPoints[i].x, innerPoints[i].y)
    ctx.closePath()
    ctx.fill()
    ctx.stroke()

    # draw axis
    ctx.beginPath()
    ctx.moveTo(AXIS_RADIUS, 0)
    ctx.arc(0, 0, AXIS_RADIUS, 0, 2 * Math.PI, true)
    ctx.closePath()
    ctx.stroke()

    # draw rotation indicator line
    ctx.beginPath()
    ctx.moveTo(AXIS_RADIUS, 0)
    ctx.lineTo(gear.innerRadius, 0)
    ctx.closePath()
    ctx.stroke()
    ctx.restore()

  drawButton: (ctx, button) ->
    {x, y} = button.location
    padding = button.padding
    ctx.save()
    ctx.translate(x, y)
    ctx.beginPath()

    # draw a round rectangle
    radius = 10
    width = button.width + 2 * padding
    height = button.height + 2 * padding
    ctx.moveTo(radius, 0)
    ctx.lineTo(width - radius, 0)
    ctx.quadraticCurveTo(width, 0, width, radius)
    ctx.lineTo(width, height - radius)
    ctx.quadraticCurveTo(width, height, width - radius, height)
    ctx.lineTo(radius, height)
    ctx.quadraticCurveTo(0, height, 0, height - radius);
    ctx.lineTo(0, radius)
    ctx.quadraticCurveTo(0, 0, radius, 0);

    if button.name is @selectedButton
      ctx.fillStyle = "rgba(50, 150, 255, 0.8)"
    else
      ctx.fillStyle = "rgba(255, 255, 255, 0.8)"
    ctx.fill()
    ctx.lineWidth = 1
    ctx.strokeStyle = "black"
    ctx.stroke()
    ctx.drawImage(button, padding, padding)
    ctx.restore()

  drawMomentum: (ctx, gear, momentum, color = "red") ->
    pitchRadius = gear.pitchRadius
    top = new Point(gear.location.x, gear.location.y - pitchRadius)
    ctx.save()
    ctx.lineWidth = 5
    ctx.lineCap = "round"
    ctx.strokeStyle = color
    ctx.translate(top.x, top.y)

    # draw arc
    ctx.beginPath()
    ctx.arc(0, pitchRadius, pitchRadius, -0.5 * Math.PI, momentum - 0.5 * Math.PI, momentum < 0)
    ctx.stroke()

    # draw arrow head
    length = 15
    angle = 0.2 * Math.PI
    headX = -Math.cos(momentum + 0.5 * Math.PI) * pitchRadius
    headY = pitchRadius - Math.sin(momentum + 0.5 * Math.PI) * pitchRadius
    head = new Point(headX, headY)
    sign = Util.sign(momentum)
    p1 = head.minus(Point.polar(momentum + angle, sign * length))
    ctx.beginPath()
    ctx.moveTo(headX, headY)
    ctx.lineTo(p1.x, p1.y)
    ctx.stroke()
    p2 = head.minus(Point.polar(momentum - angle, sign * length))
    ctx.beginPath()
    ctx.moveTo(headX, headY)
    ctx.lineTo(p2.x, p2.y)
    ctx.stroke()
    ctx.restore()

  drawChain: (ctx, chain) ->
    ctx.save()
    ctx.lineWidth = Chain.WIDTH
    ctx.lineCap = "round"
    ctx.strokeStyle = "rgb(0, 0, 255)"
    ctx.moveTo(chain.segments[0].start.x, chain.segments[0].start.y)
    for segment in chain.segments
      if segment instanceof ArcSegment
        isCounterClockwise = (segment.direction is Util.Direction.COUNTER_CLOCKWISE)
        ctx.beginPath()
        ctx.arc(segment.center.x, segment.center.y, segment.radius,
          segment.startAngle, segment.endAngle, isCounterClockwise)
        ctx.stroke()
      else
        ctx.beginPath()
        ctx.moveTo(segment.start.x, segment.start.y)
        ctx.lineTo(segment.end.x, segment.end.y)
        ctx.stroke()
    ctx.fillStyle = "white"
    for point in chain.findPointsOnChain(25)
      ctx.beginPath()
      ctx.arc(point.x, point.y, 3, 0, 2 * Math.PI, true)
      ctx.fill()
    ctx.restore()

  drawDemoPointer: (ctx, location) ->
    ctx.drawImage(@pointerImage, location.x - 0.5 * @pointerImage.width, location.y)

  draw: ->
    if @canvas.getContext?
      @updateCanvasSize()
      ctx = @canvas.getContext("2d")
      ctx.clearRect(0, 0, @canvas.width, @canvas.height)

      # draw gears
      sortedGears = @board.getGearsSortedByGroupAndLevel()
      arrowsToDraw = []
      for i in [0...sortedGears.length]
        gear = sortedGears[i]
        momentum = gear.momentum
        if gear is @selectedGear and @goalLocationGear
          @drawGear(ctx, gear, "grey")
          if momentum
            arrowsToDraw.push([gear, momentum, "grey"])
        else
          @drawGear(ctx, gear)
          if momentum
            arrowsToDraw.push([gear, momentum, "red"])

        # draw chains and arrows when all the gears in current group on current level are drawn
        shouldDrawChainsAndArrows =
          (i is sortedGears.length - 1) or
          (@board.getLevelScore(gear) isnt @board.getLevelScore(sortedGears[i + 1]))
        if shouldDrawChainsAndArrows
          for chain in @board.getChainsInGroupOnLevel(gear.group, gear.level)
            @drawChain(ctx, chain)
          for arrow in arrowsToDraw
            @drawMomentum(ctx, arrow[0], arrow[1], arrow[2])
          arrowsToDraw = []

      # draw goalLocationGear
      if @goalLocationGear
        @drawGear(ctx, @goalLocationGear, "red")

      # draw selected gear momentum
      if @selectedGear? and @selectedGearMomentum
        @drawMomentum(ctx, @selectedGear, @selectedGearMomentum)

      # draw stroke
      if @stroke.length > 0
        ctx.save()
        ctx.strokeStyle = "black"
        ctx.lineWidth = 2
        ctx.beginPath()
        ctx.moveTo(@stroke[0].x, @stroke[0].y)
        for i in [1...@stroke.length]
          ctx.lineTo(@stroke[i].x, @stroke[i].y)
        ctx.stroke()
        ctx.restore()

      # draw buttons
      if @areButtonsLoaded and @shouldShowButtons()
        for own buttonName of @buttons
          @drawButton(ctx, @buttons[buttonName])

      # draw message
      if @message.length > 0
        ctx.save()
        ctx.fillStyle = @messageColor
        ctx.font = "bold 20px Arial"
        ctx.fillText(@message, 20, 120)
        ctx.restore()

      # draw demo text and pointer
      if @isDemoPlaying and @pointerImage
        @drawDemoPointer(ctx, @pointerLocation)

  updateCanvasSize: () ->
    @canvas.width = @canvas.parentElement.getBoundingClientRect().width
    @canvas.height = @canvas.parentElement.getBoundingClientRect().height
    @buttons["clearButton"].location.x = Math.max(@canvas.width - 260, @buttons["playButton"].location.x + 80)
    @buttons["cloudButton"].location.x = @buttons["clearButton"].location.x + 80
    @buttons["helpButton"].location.x = @buttons["cloudButton"].location.x + 80

  # -- usage demo --
  loadDemoMovements: ->
    @demoMovements = [
      from: @getButtonCenter("helpButton")
      to: new Point(400, 200)
      type: MovementType.STRAIGHT
      duration: 1500
    ,
      atStart: MovementAction.PEN_DOWN
      atEnd: MovementAction.PEN_UP
      type: MovementType.CIRCLE
      radius: 100
      duration: 1500
    ,
      to: new Point(600, 200)
      type: MovementType.STRAIGHT
      duration: 1000
    ,
      atStart: MovementAction.PEN_DOWN
      atEnd: MovementAction.PEN_UP
      type: MovementType.CIRCLE
      radius: 40
      duration: 1000
    ,
      to: new Point(600, 240)
      type: MovementType.STRAIGHT
      duration: 500
    ,
      to: new Point(400, 300)
      atStart: MovementAction.PEN_DOWN
      atEnd: MovementAction.PEN_UP
      type: MovementType.STRAIGHT
      duration: 1500
    ,
      to: new Point(200, 180)
      type: MovementType.STRAIGHT
      duration: 1000
    ,
      atStart: MovementAction.PEN_DOWN
      atEnd: MovementAction.PEN_UP
      type: MovementType.CIRCLE
      radius: 90
      duration: 1000
    ,
      to: new Point(200, 260)
      type: MovementType.STRAIGHT
      duration: 500
    ,
      to: new Point(280, 260)
      atStart: MovementAction.PEN_DOWN
      atEnd: MovementAction.PEN_UP
      type: MovementType.STRAIGHT
      duration: 1500
    ,
      to: new Point(650, 220)
      type: MovementType.STRAIGHT
      duration: 1500
    ,
      atStart: MovementAction.PEN_DOWN
      atEnd: MovementAction.PEN_UP
      type: MovementType.CIRCLE
      radius: 80
      duration: 1000
    ,
      to: new Point(380, 150)
      type: MovementType.STRAIGHT
      duration: 1500
    ,
      atStart: MovementAction.PEN_DOWN
      type: MovementType.LEFT_HALF_CIRCLE
      radius: 140
      duration: 1500
      pause: 0
    ,
      to: new Point(700, 400)
      type: MovementType.STRAIGHT
      duration: 1000
      pause: 0
    ,
      type: MovementType.RIGHT_HALF_CIRCLE
      radius: 110
      duration: 1000
      pause: 0
    ,
      to: new Point(380, 150)
      atEnd: MovementAction.PEN_UP
      type: MovementType.STRAIGHT
      duration: 1000
    ,
      to: new Point(285, 180)
      type: MovementType.STRAIGHT
      duration: 1500
    ,
      to: new Point(250, 190)
      atStart: MovementAction.PEN_DOWN
      atEnd: MovementAction.PEN_UP
      type: MovementType.STRAIGHT
      duration: 1000
    , # press play button
      to: @getButtonCenter("playButton")
      atEnd: MovementAction.PEN_TAP
      type: MovementType.STRAIGHT
      duration: 1000
    ,
      to: new Point(525, 250)
      type: MovementType.STRAIGHT
      duration: 3000
    ,
      to: new Point(625, 150)
      atStart: MovementAction.PEN_DOWN
      atEnd: MovementAction.PEN_UP
      type: MovementType.STRAIGHT
      duration: 1000
    ,
      to: new Point(120, 250)
      type: MovementType.STRAIGHT
      duration: 1000
    ,
      to: new Point(750, 300)
      atStart: MovementAction.PEN_DOWN
      atEnd: MovementAction.PEN_UP
      type: MovementType.STRAIGHT
      duration: 1500
    ,
      to: new Point(525, 200)
      type: MovementType.STRAIGHT
      duration: 1000
    ,
      to: new Point(300, 400)
      atStart: MovementAction.PEN_DOWN
      atEnd: MovementAction.PEN_UP
      type: MovementType.STRAIGHT
      duration: 1500
    ]

  getButtonCenter: (buttonName) ->
    button = @buttons[buttonName]
    buttonCorner = new Point(button.location.x, button.location.y)
    buttonCorner.plus(new Point(0.5 * button.width + button.padding, 0.5 * button.height + button.padding))

  updateDemo: (delta) ->
    # check if resting or if last movement completed
    if @restTimer > 0
      @restTimer = Math.max(@restTimer - delta, 0)
      return
    else if @currentDemoMovement is @demoMovements.length
      @stopDemo()
      return

    # advance movement
    movement = @demoMovements[@currentDemoMovement]
    if @movementCompletion is 0
      movement.from ?= @pointerLocation
      movement.pause ?= 500
      @pointerLocation = movement.from.clone()
      if movement.atStart is MovementAction.PEN_DOWN
        @handlePenDown(@pointerLocation.x, @pointerLocation.y)
    if @movementCompletion < 1
      @movementCompletion = Math.min(1, @movementCompletion + delta / movement.duration)
      @updatePointerLocation(movement, @movementCompletion)
      @handlePenMove(@pointerLocation.x, @pointerLocation.y)
    if @movementCompletion is 1
      if movement.atEnd is MovementAction.PEN_TAP
        @handlePenDown(@pointerLocation.x, @pointerLocation.y)
        @handlePenUp()
      else if movement.atEnd is MovementAction.PEN_UP
        @handlePenUp()
      @restTimer = movement.pause
      @movementCompletion = 0
      @currentDemoMovement++

  updatePointerLocation: (movement, movementCompletion) ->
    if movement.type is MovementType.STRAIGHT
      delta = movement.to.minus(movement.from)
      @pointerLocation = movement.from.plus(delta.times(movementCompletion))
    else if movement.type is MovementType.CIRCLE
      center = new Point(movement.from.x , movement.from.y + movement.radius)
      @pointerLocation = center.plus(Point.polar(Math.PI - (movementCompletion - 0.25) * 2 * Math.PI, movement.radius))
    else if movement.type is MovementType.LEFT_HALF_CIRCLE
      center = new Point(movement.from.x , movement.from.y + movement.radius)
      angle = 1.5 * Math.PI - movementCompletion * Math.PI
      @pointerLocation = center.plus(Point.polar(angle, movement.radius))
    else if movement.type is MovementType.RIGHT_HALF_CIRCLE
      center = new Point(movement.from.x , movement.from.y - movement.radius)
      angle = 0.5 * Math.PI - movementCompletion * Math.PI
      @pointerLocation = center.plus(Point.polar(angle, movement.radius))

  playDemo: ->
    @loadDemoMovements() # load these on each play in case canvas size changed
    @boardBackup = @board.clone()
    @board.clear()
    @currentDemoMovement = 0
    @movementCompletion = 0
    @isDemoPlaying = true
    @displayMessage("click anywhere to stop the demo")

  stopDemo: ->
    @isDemoPlaying = false
    @restTimer = 0
    @stroke = []
    @selectedGear = null
    @selectedIcon = "gearIcon"
    @board.restoreAfterDemo(@boardBackup)
    @clearMessage()

  boardUploaded: (event) ->
    parent.location.hash = event.target.responseText.trim()
    @displayMessage("Board saved. Share it by copying the text in your address bar.", "black", 4000)

  uploadBoard: ->
    boardJSON = JSON.stringify(@board)
    Util.sendPostRequest(boardJSON, "upload_board.php", ((event) => @boardUploaded(event)))

window.gearsketch.GearSketch = GearSketch