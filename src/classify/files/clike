#define _GNU_SOURCE

#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <monome.h>
#include "internal.h"
#include "platform.h"
#include "rotation.h"
#include "devices.h"

#ifndef LIBSUFFIX
#define LIBSUFFIX ".so"
#endif

#ifndef LIBDIR
#define LIBDIR "/usr/lib"
#endif

/**
 * private
 */

static monome_devmap_t *map_serial_to_device(const char *serial) {
	monome_devmap_t *m;
	int serialnum;

	for( m = mapping; m->sermatch; m++ )
		if( sscanf(serial, m->sermatch, &serialnum) )
			return m;

	return NULL;
}

/**
 * public
 */

monome_t *monome_open(const char *dev, ...) {
	monome_t *monome;
	monome_devmap_t *m;

	va_list arguments;
	char *serial, *proto;
	int error;

	if( !dev )
		return NULL;

	serial = NULL;
	m = NULL;

	/* first let's figure out which protocol to use */
	if( !strstr(dev, "://") ) {
		/* assume that the device is a tty...let's probe and see what device
		   we're dealing with */

		if( !(serial = monome_platform_get_dev_serial(dev)) )
			return NULL;

		if( (m = map_serial_to_device(serial)) )
			proto = m->proto;
		else
			return NULL;
	} else
		/* otherwise, we'll assume that what we have is an OSC URL.
		   in the future, maybe we'll have more protocol modules...something
		   to think about. */
		proto = "osc";

	if( !(monome = monome_platform_load_protocol(proto)) )
		goto err_init;

	va_start(arguments, dev);
	error = monome->open(monome, dev, serial, m, arguments);
	va_end(arguments);

	if( error )
		goto err_init;

	monome->proto = proto;

	if( !(monome->device = m_strdup(dev)) )
		goto err_nomem;

	monome->rotation = MONOME_ROTATE_0;
	return monome;

err_nomem:
	monome->free(monome);

err_init:
	if( serial ) m_free(serial);
	return NULL;
}

void monome_close(monome_t *monome) {
	assert(monome);

	if( monome->serial )
		m_free((char *) monome->serial);

	if( monome->device )
		m_free((char *) monome->device);

	monome->close(monome);
	monome_platform_free(monome);
}

const char *monome_get_serial(monome_t *monome) {
	return monome->serial;
}

const char *monome_get_devpath(monome_t *monome) {
	return monome->device;
}

const char *monome_get_friendly_name(monome_t *monome) {
	return monome->friendly;
}

const char *monome_get_proto(monome_t *monome) {
	return monome->proto;
}

int monome_get_rows(monome_t *monome) {
	if( ROTSPEC(monome).flags & ROW_COL_SWAP )
		return monome->cols;
	else
		return monome->rows;
}

int monome_get_cols(monome_t *monome) {
	if( ROTSPEC(monome).flags & ROW_COL_SWAP )
		return monome->rows;
	else
		return monome->cols;
}

monome_rotate_t monome_get_rotation(monome_t *monome) {
	return monome->rotation;
}

void monome_set_rotation(monome_t *monome, monome_rotate_t rotation) {
	monome->rotation = rotation & 3;
}

int monome_register_handler(monome_t *monome, monome_event_type_t event_type,
                            monome_event_callback_t cb, void *data) {
	monome_callback_t *handler;

	if( event_type >= MONOME_EVENT_MAX )
		return EINVAL;

	handler       = &monome->handlers[event_type];
	handler->cb   = cb;
	handler->data = data;

	return 0;
}

int monome_unregister_handler(monome_t *monome,
                              monome_event_type_t event_type) {
	return monome_register_handler(monome, event_type, NULL, NULL);
}

int monome_event_next(monome_t *monome, monome_event_t *e) {
	e->monome = monome;

	return monome->next_event(monome, e);
}

int monome_event_handle_next(monome_t *monome) {
	monome_callback_t *handler;
	monome_event_t e;
	int status;

	status = monome_event_next(monome, &e);
	if (status <= 0)
		return status;

	handler = &monome->handlers[e.event_type];

	if( !handler->cb )
		return 0;

	handler->cb(&e, handler->data);
	return 1;
}

int monome_get_fd(monome_t *monome) {
	return monome->fd;
}

#define REQUIRE(capability) if (!monome->capability) return -1

int monome_led_set(monome_t *monome, uint_t x, uint_t y, uint_t on) {
	REQUIRE(led);
	return monome->led->set(monome, x, y, on);
}

int monome_led_on(monome_t *monome, uint_t x, uint_t y) {
	REQUIRE(led);
	return monome_led_set(monome, x, y, 1);
}

int monome_led_off(monome_t *monome, uint_t x, uint_t y) {
	REQUIRE(led);
	return monome_led_set(monome, x, y, 0);
}

int monome_led_all(monome_t *monome, uint_t status) {
	REQUIRE(led);
	return monome->led->all(monome, status);
}

int monome_led_map(monome_t *monome, uint_t x_off, uint_t y_off,
                   const uint8_t *data) {
	REQUIRE(led);
	return monome->led->map(monome, x_off, y_off, data);
}

int monome_led_row(monome_t *monome, uint_t x_off, uint_t y,
				   size_t count, const uint8_t *data) {
	REQUIRE(led);
	return monome->led->row(monome, x_off, y, count, data);
}

int monome_led_col(monome_t *monome, uint_t x, uint_t y_off,
				   size_t count, const uint8_t *data) {
	REQUIRE(led);
	return monome->led->col(monome, x, y_off, count, data);
}

int monome_led_intensity(monome_t *monome, uint_t brightness) {
	REQUIRE(led);
	return monome->led->intensity(monome, brightness);
}

int monome_led_level_set(monome_t *monome, uint_t x, uint_t y, uint_t level) {
	REQUIRE(led_level);
	return monome->led_level->set(monome, x, y, level);
}

int monome_led_level_all(monome_t *monome, uint_t level) {
	REQUIRE(led_level);
	return monome->led_level->all(monome, level);
}

int monome_led_level_map(monome_t *monome, uint_t x_off, uint_t y_off,
                         const uint8_t *data) {
	REQUIRE(led_level);
	return monome->led_level->map(monome, x_off, y_off, data);
}

int monome_led_level_row(monome_t *monome, uint_t x_off, uint_t y,
                         size_t count, const uint8_t *data) {
	REQUIRE(led_level);
	return monome->led_level->row(monome, x_off, y, count, data);
}

int monome_led_level_col(monome_t *monome, uint_t x, uint_t y_off,
                         size_t count, const uint8_t *data) {
	REQUIRE(led_level);
	return monome->led_level->col(monome, x, y_off, count, data);
}

int monome_led_ring_set(monome_t *monome, uint_t ring, uint_t led,
                        uint_t level) {
	REQUIRE(led_ring);
	return monome->led_ring->set(monome, ring, led, level);
}

int monome_led_ring_all(monome_t *monome, uint_t ring, uint_t level) {
	REQUIRE(led_ring);
	return monome->led_ring->all(monome, ring, level);
}

int monome_led_ring_map(monome_t *monome, uint_t ring, const uint8_t *levels) {
	REQUIRE(led_ring);
	return monome->led_ring->map(monome, ring, levels);
}

int monome_led_ring_range(monome_t *monome, uint_t ring, uint_t start,
                          uint_t end, uint_t level) {
	REQUIRE(led_ring);
	return monome->led_ring->range(monome, ring, start, end, level);
}

int monome_tilt_enable(monome_t *monome, uint_t sensor) {
	REQUIRE(tilt);
	return monome->tilt->enable(monome, sensor);
}

int monome_tilt_disable(monome_t *monome, uint_t sensor) {
	REQUIRE(tilt);
	return monome->tilt->disable(monome, sensor);
}

#define _GNU_SOURCE

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include <poll.h>

#include <getopt.h>
#include <lo/lo.h>

#include <monome.h>
#include "platform.h"

#define DEFAULT_MONOME_DEVICE   "/dev/ttyUSB0"
#define DEFAULT_MONOME_PROTOCOL "series"

#define DEFAULT_OSC_PREFIX      "monome"
#define DEFAULT_OSC_SERVER_PORT "8080"
#define DEFAULT_OSC_APP_PORT    "8000"
#define DEFAULT_OSC_APP_HOST    "127.0.0.1"

#ifdef DEBUG
#define DPRINTF(...) fprintf(stderr, __VA_ARGS__)
#else
#define DPRINTF(...) ((void) 0)
#endif

typedef struct {
	monome_t *monome;
	lo_address *outgoing;
	lo_server *server;

	char *lo_prefix;
} ms_state;

ms_state state;

static void lo_error(int num, const char *error_msg, const char *path) {
	printf("monomeserial: lo server error %d in %s: %s\n",
		   num, path, error_msg);
	fflush(stdout);
}

static int osc_led_handler(const char *path, const char *types,
						   lo_arg **argv, int argc,
						   lo_message data, void *user_data) {
	monome_t *monome = user_data;

	if( (argc != 3 || strcmp("iii", types)) ||
		(argv[0]->i > 15 || argv[0]->i < 0) ||
		(argv[1]->i > 15 || argv[1]->i < 0) ||
		(argv[2]->i > 1  || argv[2]->i < 0) )
		return -1;

	return monome_led_set(monome, argv[0]->i, argv[1]->i, argv[2]->i);
}

static int osc_led_all_handler(const char *path, const char *types,
							 lo_arg **argv, int argc,
							 lo_message data, void *user_data) {
	monome_t *monome = user_data;
	int mode = (argc) ? argv[0]->i : 0;

	return monome_led_all(monome, mode);
}

static int osc_led_col_row_handler(const char *path, const char *types,
								   lo_arg **argv, int argc,
								   lo_message data, void *user_data) {
	monome_t *monome = user_data;
	uint8_t buf[2] = {argv[1]->i};

	if( argc == 3 )
		buf[1] = argv[2]->i;

	if( strstr(path, "led_col") )
		return monome_led_col(monome, argv[0]->i, 0, argc - 1, buf);
	else
		return monome_led_row(monome, 0, argv[0]->i, argc - 1, buf);
}

static int osc_led_map_handler(const char *path, const char *types,
                               lo_arg **argv, int argc,
                               lo_message data, void *user_data) {
	monome_t *monome = user_data;
	uint8_t buf[8];
	uint i;

	for( i = 0; i < 8; i++ )
		buf[i] = argv[i + (argc - 8)]->i;

	switch( argc ) {
	case 8:
		return monome_led_map(monome, 0, 0, buf);

	case 10:
		return monome_led_map(monome, argv[0]->i, argv[1]->i, buf);
	}

	return -1;
}

static int osc_intensity_handler(const char *path, const char *types,
								 lo_arg **argv, int argc,
								 lo_message data, void *user_data) {
	monome_t *monome = user_data;
	int intensity = (argc) ? argv[0]->i : 0xF;

	return monome_led_intensity(monome, intensity);
}

#define ASPRINTF_OR_BAIL(...) do { \
	if (asprintf(__VA_ARGS__) < 0) \
		return;                    \
	} while (0);

static void register_osc_methods(char *prefix, monome_t *monome) {
	lo_server_thread srv = state.server;
	char *cmd_buf;

	ASPRINTF_OR_BAIL(&cmd_buf, "/%s/led", prefix);
	lo_server_add_method(srv, cmd_buf, "iii", osc_led_handler, monome);
	m_free(cmd_buf);

	ASPRINTF_OR_BAIL(&cmd_buf, "/%s/clear", prefix);
	lo_server_add_method(srv, cmd_buf, "", osc_led_all_handler, monome);
	lo_server_add_method(srv, cmd_buf, "i", osc_led_all_handler, monome);
	m_free(cmd_buf);

	ASPRINTF_OR_BAIL(&cmd_buf, "/%s/frame", prefix);
	lo_server_add_method(srv, cmd_buf, "iiiiiiii", osc_led_map_handler, monome);
	lo_server_add_method(srv, cmd_buf, "iiiiiiiiii",
						 osc_led_map_handler, monome);
	m_free(cmd_buf);

	ASPRINTF_OR_BAIL(&cmd_buf, "/%s/led_row", prefix);
	lo_server_add_method(srv, cmd_buf, "ii", osc_led_col_row_handler, monome);
	lo_server_add_method(srv, cmd_buf, "iii", osc_led_col_row_handler, monome);
	m_free(cmd_buf);

	ASPRINTF_OR_BAIL(&cmd_buf, "/%s/led_col", prefix);
	lo_server_add_method(srv, cmd_buf, "ii", osc_led_col_row_handler, monome);
	lo_server_add_method(srv, cmd_buf, "iii", osc_led_col_row_handler, monome);
	m_free(cmd_buf);

	ASPRINTF_OR_BAIL(&cmd_buf, "/%s/intensity", prefix);
	lo_server_add_method(srv, cmd_buf, "", osc_intensity_handler, monome);
	lo_server_add_method(srv, cmd_buf, "i", osc_intensity_handler, monome);
	m_free(cmd_buf);
}

static void unregister_osc_methods(char *prefix) {
	lo_server_thread srv = state.server;
	char *cmd_buf;

	ASPRINTF_OR_BAIL(&cmd_buf, "/%s/clear", prefix);
	lo_server_del_method(srv, cmd_buf, "");
	lo_server_del_method(srv, cmd_buf, "i");
	m_free(cmd_buf);

	ASPRINTF_OR_BAIL(&cmd_buf, "/%s/intensity", prefix);
	lo_server_del_method(srv, cmd_buf, "");
	lo_server_del_method(srv, cmd_buf, "i");
	m_free(cmd_buf);

	ASPRINTF_OR_BAIL(&cmd_buf, "/%s/led", prefix);
	lo_server_del_method(srv, cmd_buf, "iii");
	m_free(cmd_buf);

	ASPRINTF_OR_BAIL(&cmd_buf, "/%s/led_row", prefix);
	lo_server_del_method(srv, cmd_buf, "ii");
	lo_server_del_method(srv, cmd_buf, "iii");
	m_free(cmd_buf);

	ASPRINTF_OR_BAIL(&cmd_buf, "/%s/led_col", prefix);
	lo_server_del_method(srv, cmd_buf, "ii");
	lo_server_del_method(srv, cmd_buf, "iii");
	m_free(cmd_buf);

	ASPRINTF_OR_BAIL(&cmd_buf, "/%s/frame", prefix);
	lo_server_del_method(srv, cmd_buf, "iiiiiiii");
	lo_server_del_method(srv, cmd_buf, "iiiiiiiiii");
	m_free(cmd_buf);

}

static void monome_handle_press(const monome_event_t *e, void *data) {
	char *cmd;
	char *prefix = data;

	ASPRINTF_OR_BAIL(&cmd, "/%s/press", prefix);
	lo_send_from(state.outgoing, state.server, LO_TT_IMMEDIATE, cmd, "iii",
				 e->grid.x, e->grid.y, e->event_type);
	m_free(cmd);
}

#undef ASPRINTF_OR_BAIL

static void usage(const char *app) {
	printf(
		"usage: %s [options...] [prefix]\n"
		"\n"
		"  -h, --help			display this information\n"
		"\n"
		"  -d, --device <device>		the monome serial device\n"

		/*
		 * protocol cannot currently be explicitly specified.
		 * this functionality will be re-added at a later date.
		 *
		"  -p, --protocol <protocol>	which protocol to use"
			"(\"40h\" or \"series\")\n" */

		"\n"
		"  -s, --server-port <port>	what port to listen on\n"
		"  -a, --application-port <port>	what port to talk to\n"
		"  -o, --application-host <host> the host your application is on\n"
		"\n"
		"  -r, --rotation <degrees>	rotate the monome. "
			"degrees can only be one of 0, 90, 180, or 270.\n"
		"\n", app);
}

static int is_numstr(const char *s) {
	while((48 <= *s) && (*s++ <= 57)); /* 48 is ASCII '0', 57 is '9' */

	/* if the character we stopped on isn't a null,
	   we didn't make it through the string */
	if( *s )
		return 0; /* oh well :( */
	return 1;
}

/* on OSX, poll() does not work with devices (i.e. ttys). */

#ifndef HAVE_BROKEN_POLL
static int main_loop() {
	struct pollfd fds[2];

	fds[0].fd = monome_get_fd(state.monome);
	fds[1].fd = lo_server_get_socket_fd(state.server);

	fds[0].events = fds[1].events = 
		POLLIN;

	do {
		/* block until either the monome or liblo have data */
		poll(fds, 2, -1);

		/* is the monome still connected? */
		if( fds[0].revents & (POLLHUP | POLLERR) )
			return 1;

		/* is there data available for reading from the monome? */
		if( fds[0].revents & POLLIN )
			monome_event_handle_next(state.monome);

		/* how about from OSC? */
		if( fds[1].revents & POLLIN )
			lo_server_recv_noblock(state.server, 0);
	} while( 1 );
}
#else
static int main_loop() {
	fd_set rfds, efds;
	int maxfd, mfd, lofd;

	mfd  = monome_get_fd(state.monome);
	lofd = lo_server_get_socket_fd(state.server);
	maxfd = ((lofd > mfd) ? lofd : mfd) + 1;

	do {
		FD_ZERO(&rfds);
		FD_SET(mfd, &rfds);
		FD_SET(lofd, &rfds);

		FD_ZERO(&efds);
		FD_SET(mfd, &efds);

		/* block until either the monome or liblo have data */
		select(maxfd, &rfds, NULL, &efds, NULL);

		/* is the monome still connected? */
		if( FD_ISSET(mfd, &efds) )
			return 1;

		/* is there data available for reading from the monome? */
		if( FD_ISSET(mfd, &rfds) )
			monome_event_handle_next(state.monome);

		/* how about from OSC? */
		if( FD_ISSET(lofd, &rfds) )
			lo_server_recv_noblock(state.server, 0);
	} while( 1 );
}
#endif

int main(int argc, char *argv[]) {
	char c, *device, *sport, *aport, *ahost;
	monome_rotate_t rotate = MONOME_ROTATE_0;
	int i;

	struct option arguments[] = {
		{"help",             no_argument,       0, 'h'},

		{"device",           required_argument, 0, 'd'},

		{"server-port",      required_argument, 0, 's'},
		{"application-port", required_argument, 0, 'a'},
		{"application-host", required_argument, 0, 'o'},

		{"rotation",         required_argument, 0, 'r'}
	};

	device = DEFAULT_MONOME_DEVICE;
	sport  = DEFAULT_OSC_SERVER_PORT;
	aport  = DEFAULT_OSC_APP_PORT;
	ahost  = DEFAULT_OSC_APP_HOST;

	while( (c = getopt_long(argc, argv, "hd:s:a:o:r:",
							arguments, &i)) > 0 ) {
		switch( c ) {
		case 'h':
			usage(argv[0]);
			return 1;

		case 'd':
			device = optarg;
			break;

		case 's':
			if( is_numstr(optarg) )
				sport = optarg;
			else
				printf("warning: \"%s\" is not a valid server port.\n",
					   optarg);

			break;

		case 'a':
			if( is_numstr(optarg) )
				aport = optarg;
			else
				printf("warning: \"%s\" is not a valid application port.\n",
					   optarg);

			break;

		case 'o':
			ahost = optarg;
			break;

		case 'r':
			switch(*optarg) {
			case 'l': case '0': rotate = MONOME_ROTATE_0;   break;
			case 't': case '9': rotate = MONOME_ROTATE_90;  break;
			case 'r': case '1': rotate = MONOME_ROTATE_180; break;
			case 'b': case '2': rotate = MONOME_ROTATE_270; break;
			}
			break;
		}
	}

	if( optind == argc )
		state.lo_prefix = m_strdup(DEFAULT_OSC_PREFIX);
	else
		state.lo_prefix = m_strdup(argv[optind]);

	if( !(state.monome = monome_open(device)) ) {
		printf("failed to open %s\n", device);
		return EXIT_FAILURE;
	}

	if( !(state.server = lo_server_new(sport, lo_error)) )
		return EXIT_FAILURE;

	state.outgoing = lo_address_new(ahost, aport);

	monome_register_handler(state.monome, MONOME_BUTTON_DOWN,
							monome_handle_press, state.lo_prefix);
	monome_register_handler(state.monome, MONOME_BUTTON_UP,
							monome_handle_press, state.lo_prefix);

	register_osc_methods(state.lo_prefix, state.monome);

	monome_set_rotation(state.monome, rotate);
	monome_led_all(state.monome, 0);

	printf("monomeserial version %s, yay!\n\n", VERSION);
	printf("initialized device %s (%s) at %s, which is %dx%d using proto %s\n",
		   monome_get_serial(state.monome), monome_get_friendly_name(state.monome),
		   monome_get_devpath(state.monome),
		   monome_get_rows(state.monome), monome_get_cols(state.monome),
		   monome_get_proto(state.monome));
	printf("running with prefix /%s\n\n", state.lo_prefix);

	/* main_loop() returns 1 if the monome was disconnected */
	if( main_loop() )
		printf("%s disconnected, monomeserial exiting.\nsee you later!\n\n",
			   monome_get_devpath(state.monome));

	monome_close(state.monome);

	unregister_osc_methods(state.lo_prefix);
	m_free(state.lo_prefix);

	lo_address_free(state.outgoing);
	lo_server_free(state.server);

	return EXIT_SUCCESS;
}

#include <stdio.h>
#include <stdint.h>
#include <string.h>

#include <monome.h>
#include "internal.h"

#define ROWS(monome) (monome_get_rows(monome) - 1)
#define COLS(monome) (monome_get_cols(monome) - 1)

/* you may notice the gratituous use of modulo when translating input
   coordinates...this is because it's possible to translate into negatives
   when pretending a bigger monome (say, a 256) is a smaller monome (say,
   a 128). because we're using unsigned integers, this will cause a wrap-around
   into some very big numbers, which makes several of the example programs
   segfault (simple.c, in particular).

   while this bug is arguably contrived, I'd rather pay the minute
   computational cost here and avoid causing trouble in application code. */

/**
 * 0 degrees
 */

static void r0_cb(monome_t *monome, uint_t *x, uint_t *y) {
	return;
}

static void r0_map_cb(monome_t *monome, uint8_t *data) {
	return;
}

static void r0_level_map_cb(monome_t *monome, uint8_t *dst,
                            const uint8_t *src) {
	memcpy(dst, src, 64);
}

/**
 * 90 degrees
 */

static void r90_output_cb(monome_t *monome, uint_t *x, uint_t *y) {
	uint_t t = *x;

	*x = *y;
	*y = COLS(monome) - t;
}

static void r90_input_cb(monome_t *monome, uint_t *x, uint_t *y) {
	uint_t t = *x;

	*x = (COLS(monome) - *y) % (COLS(monome) + 1);
	*y = t;
}

static void r90_map_cb(monome_t *monome, uint8_t *data) {
	/* this is an algorithm for rotation of a bit matrix by 90 degrees.
	   in the case of r270_map_cb, the rotation is clockwise, in the case
	   of r90_map_cb it is counter-clockwise.

	   the matrix is made up of an array of 8 bytes, which, laid out
	   contiguously in memory, can be treated as a 64 bit integer, which I've
	   opted to do here. this allows rotation to be accomplished solely with
	   bitwise operations.

	   on 64 bit architectures, we treat data as a 64 bit integer, on 32
	   bit architectures we treat it as two 32 bit integers.

	   inspired by "hacker's delight" by henry s. warren
	   see section 7-3 "transposing a bit matrix" */

#ifdef __LP64__
	uint64_t t, x = *((uint64_t *) data);

# define swap(f, c)\
	t = (x ^ (x << f)) & c; x ^= t ^ (t >> f);

# ifdef LM_BIG_ENDIAN
	swap(8, 0xFF00FF00FF00FF00LLU);
	swap(7, 0x5500550055005500LLU);

	swap(16, 0xFFFF0000FFFF0000LLU);
	swap(14, 0x3333000033330000LLU);

	swap(32, 0xFFFFFFFF00000000LLU);
	swap(28, 0x0F0F0F0F00000000LLU);
# else
	swap(8, 0xFF00FF00FF00FF00LLU);
	swap(9, 0xAA00AA00AA00AA00LLU);

	swap(16, 0xFFFF0000FFFF0000LLU);
	swap(18, 0xCCCC0000CCCC0000LLU);

	swap(32, 0xFFFFFFFF00000000LLU);
	swap(36, 0xF0F0F0F000000000LLU);
# endif /* defined LM_BIG_ENDIAN */
# undef swap

	*((uint64_t *) data) = x;
#else /* __LP64__ */
	uint32_t x, y, t;

	x = *((uint32_t *) data);
	y = *(((uint32_t *) data) + 1);
	t = 0;

# define swap(x, f, c)\
	t = (x ^ (x << f)) & c; x ^= t ^ (t >> f);

# ifdef LM_BIG_ENDIAN
	swap(x, 8, 0xFF00FF00);
	swap(x, 7, 0x55005500);

	swap(x, 16, 0xFFFF0000);
	swap(x, 14, 0x33330000);

	swap(y, 8, 0xFF00FF00);
	swap(y, 7, 0x55005500);

	swap(y, 16, 0xFFFF0000);
	swap(y, 14, 0x33330000);
# else
	swap(x, 8, 0xFF00FF00);
	swap(x, 9, 0xAA00AA00);

	swap(x, 16, 0xFFFF0000);
	swap(x, 18, 0xCCCC0000);

	swap(y, 8, 0xFF00FF00);
	swap(y, 9, 0xAA00AA00);

	swap(y, 16, 0xFFFF0000);
	swap(y, 18, 0xCCCC0000);
# endif /* defined LM_BIG_ENDIAN */
# undef swap

	*((uint32_t *) data) = ((x & 0xF0F0F0F0) >> 4) | (y & 0xF0F0F0F0);
	*(((uint32_t *) data) + 1) = (x & 0x0F0F0F0F) | ((y & 0x0F0F0F0F) << 4);
#endif /* __LP64__ */
}

static void r90_level_map_cb(monome_t *monome, uint8_t *dst,
                             const uint8_t *src) {
	int i;

	for( i = 0; i < 64; i++ )
		dst[i] = src[(7 - (i >> 3)) + ((i & 7) << 3)];
}

/**
 * 180 degrees
 */

static void r180_output_cb(monome_t *monome, uint_t *x, uint_t *y) {
	*x = COLS(monome) - *x;
	*y = ROWS(monome) - *y;
}

static void r180_input_cb(monome_t *monome, uint_t *x, uint_t *y) {
	*x = (COLS(monome) - *x) % (COLS(monome) + 1);
	*y = (ROWS(monome) - *y) % (ROWS(monome) + 1);
}

static void r180_map_cb(monome_t *monome, uint8_t *data) {
	/* integer reversal. */

#ifdef __LP64__
	uint64_t x = *((uint64_t *) data);

	x = x >> 32 | x << 32;
	x = (x & 0xFFFF0000FFFF0000LLU) >> 16 | (x & 0x0000FFFF0000FFFFLLU) << 16;
	x = (x & 0xFF00FF00FF00FF00LLU) >> 8  | (x & 0x00FF00FF00FF00FFLLU) << 8;
	x = (x & 0xF0F0F0F0F0F0F0F0LLU) >> 4  | (x & 0x0F0F0F0F0F0F0F0FLLU) << 4;
	x = (x & 0xCCCCCCCCCCCCCCCCLLU) >> 2  | (x & 0x3333333333333333LLU) << 2;
	x = (x & 0xAAAAAAAAAAAAAAAALLU) >> 1  | (x & 0x5555555555555555LLU) << 1;

	*((uint64_t *) data) = x;
#else /* __LP64__ */
	uint32_t x, y;

	x = *((uint32_t *) data);
	y = *(((uint32_t *) data) + 1);

	x = x >> 16 | x << 16;
	x = (x & 0xFF00FF00) >> 8  | (x & 0x00FF00FF) << 8;
	x = (x & 0xF0F0F0F0) >> 4  | (x & 0x0F0F0F0F) << 4;
	x = (x & 0xCCCCCCCC) >> 2  | (x & 0x33333333) << 2;
	x = (x & 0xAAAAAAAA) >> 1  | (x & 0x55555555) << 1;

	y = y >> 16 | y << 16;
	y = (y & 0xFF00FF00) >> 8  | (y & 0x00FF00FF) << 8;
	y = (y & 0xF0F0F0F0) >> 4  | (y & 0x0F0F0F0F) << 4;
	y = (y & 0xCCCCCCCC) >> 2  | (y & 0x33333333) << 2;
	y = (y & 0xAAAAAAAA) >> 1  | (y & 0x55555555) << 1;

	*((uint32_t *) data) = y;
	*(((uint32_t *) data) + 1) = x;
#endif /* defined __LP64__ */
}

static void r180_level_map_cb(monome_t *monome, uint8_t *dst,
                              const uint8_t *src) {
	int i;

	for( i = 0; i < 64; i++ )
		dst[63 - i] = src[i];
}

/**
 * 270 degrees
 */

static void r270_output_cb(monome_t *monome, uint_t *x, uint_t *y) {
	uint_t t = *x;

	*x = ROWS(monome) - *y;
	*y = t;
}

static void r270_input_cb(monome_t *monome, uint_t *x, uint_t *y) {
	uint_t t = *x;

	*x = *y;
	*y = (ROWS(monome) - t) % (ROWS(monome) + 1);
}

static void r270_map_cb(monome_t *monome, uint8_t *data) {
	/* see r90_map_cb for a brief explanation */

#ifdef __LP64__
	uint64_t t, x = *((uint64_t *) data);

# define swap(f, c)\
	t = (x ^ (x << f)) & c; x ^= t ^ (t >> f);

# ifdef LM_BIG_ENDIAN
	swap(8, 0xFF00FF00FF00FF00LLU);
	swap(9, 0xAA00AA00AA00AA00LLU);

	swap(16, 0xFFFF0000FFFF0000LLU);
	swap(18, 0xCCCC0000CCCC0000LLU);

	swap(32, 0xFFFFFFFF00000000LLU);
	swap(36, 0xF0F0F0F000000000LLU);
# else
	swap(8, 0xFF00FF00FF00FF00LLU);
	swap(7, 0x5500550055005500LLU);

	swap(16, 0xFFFF0000FFFF0000LLU);
	swap(14, 0x3333000033330000LLU);

	swap(32, 0xFFFFFFFF00000000LLU);
	swap(28, 0x0F0F0F0F00000000LLU);
# endif /* defined LM_BIG_ENDIAN */
# undef swap

	*((uint64_t *) data) = x;
#else /* __LP64__ */
	uint32_t x, y, t;

	x = *((uint32_t *) data);
	y = *(((uint32_t *) data) + 1);
	t = 0;

# define swap(x, f, c)\
	t = (x ^ (x << f)) & c; x ^= t ^ (t >> f);

# ifdef LM_BIG_ENDIAN
	swap(x, 8, 0xFF00FF00);
	swap(x, 9, 0xAA00AA00);

	swap(x, 16, 0xFFFF0000);
	swap(x, 18, 0xCCCC0000);

	swap(y, 8, 0xFF00FF00);
	swap(y, 9, 0xAA00AA00);

	swap(y, 16, 0xFFFF0000);
	swap(y, 18, 0xCCCC0000);
# else
	swap(x, 8, 0xFF00FF00);
	swap(x, 7, 0x55005500);

	swap(x, 16, 0xFFFF0000);
	swap(x, 14, 0x33330000);

	swap(y, 8, 0xFF00FF00);
	swap(y, 7, 0x55005500);

	swap(y, 16, 0xFFFF0000);
	swap(y, 14, 0x33330000);
# endif /* defined LM_BIG_ENDIAN */

	*((uint32_t *) data) = ((x & 0x0F0F0F0F) << 4) | (y & 0x0F0F0F0F);
	*(((uint32_t *) data) + 1) = (x & 0xF0F0F0F0) | ((y & 0xF0F0F0F0) >> 4);
# undef swap

#endif /* defined __LP64__ */
}

static void r270_level_map_cb(monome_t *monome, uint8_t *dst,
                              const uint8_t *src) {
	int i;

	for( i = 0; i < 64; i++ )
		dst[i] = src[(i >> 3) + ((7 - (i & 7)) << 3)];
}

monome_rotspec_t rotspec[4] = {
	[MONOME_ROTATE_0] = {
		.output_cb    = r0_cb,
		.input_cb     = r0_cb,
		.map_cb       = r0_map_cb,
		.level_map_cb = r0_level_map_cb,

		.flags        = 0,
	},
	
	[MONOME_ROTATE_90] = {
		.output_cb    = r90_output_cb,
		.input_cb     = r90_input_cb,
		.map_cb       = r90_map_cb,
		.level_map_cb = r90_level_map_cb,

		.flags        = ROW_COL_SWAP | ROW_REVBITS
	},

	[MONOME_ROTATE_180] = {
		.output_cb    = r180_output_cb,
		.input_cb     = r180_input_cb,
		.map_cb       = r180_map_cb,
		.level_map_cb = r180_level_map_cb,

		.flags        = ROW_REVBITS | COL_REVBITS
	},

	[MONOME_ROTATE_270] = {
		.output_cb    = r270_output_cb,
		.input_cb     = r270_input_cb,
		.map_cb       = r270_map_cb,
		.level_map_cb = r270_level_map_cb,

		.flags        = ROW_COL_SWAP | COL_REVBITS
	},
};

#define _GNU_SOURCE

#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <sys/select.h>

#include "platform.h"

char *monome_platform_get_dev_serial(const char *path) {
	char *serial;

	assert(path);

	/* osx serial paths are of the form
	   /dev/tty.usbserial-<device serial> or
	   /dev/tty.usbmodem<device serial> (arduino uno)
	   we'll locate to one past the first hyphen
	   or the first occurrence of usbmodem sequence */

	if( (serial = strstr(path, "usbmodem")) )
		serial += 7;
	else if( !(serial = strchr(path, '-')) )
		return NULL;

	return strdup(serial + 1);
}

int monome_platform_wait_for_input(monome_t *monome, uint_t msec) {
	struct timeval timeout[1];
	fd_set rfds[1];
	fd_set efds[1];
	int fd;

	fd = monome_get_fd(monome);

	timeout->tv_sec  = msec / 1000;
	timeout->tv_usec = (msec - (timeout->tv_sec * 1000)) * 1000;

	FD_ZERO(rfds);
	FD_SET(fd, rfds);
	FD_ZERO(efds);
	FD_SET(fd, efds);

	if( !select(fd + 1, rfds, NULL, efds, timeout) )
		return 1;

	if( FD_ISSET(fd, efds) )
		return -1;

	return 0;
}

#define _GNU_SOURCE

#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <dlfcn.h>
#include <sys/select.h>
#include <termios.h>
#include <errno.h>

#include <monome.h>
#include "internal.h"
#include "platform.h"

#define MONOME_BAUD_RATE B115200
#define READ_TIMEOUT 25

#if !defined(EMBED_PROTOS)
/* stops gcc from complaining when compiled with -pedantic */
typedef union {
	void *vptr;
	monome_t *(*func)();
} func_vptr_t;

monome_t *monome_platform_load_protocol(const char *proto) {
	void *dl_handle;
	func_vptr_t protocol_new;
	monome_t *monome;
	char *buf;

	if( asprintf(&buf, LIBDIR "/monome/protocol_%s" LIBSUFFIX, proto) < 0 )
		return NULL;

	dl_handle = dlopen(buf, RTLD_LAZY);
	free(buf);

	if( !dl_handle ) {
		fprintf(stderr, "couldn't load monome protocol module.  "
				"dlopen said: \n\t%s\n\n"
				"please make sure that libmonome is installed correctly!\n",
				dlerror());
		return NULL;
	}

	protocol_new.vptr = dlsym(dl_handle, "monome_protocol_new");

	if( !protocol_new.func ) {
		fprintf(stderr, "couldn't initialize monome protocol module.  "
				"dlopen said:\n\t%s\n\n"
				"please make sure you're using a valid protocol library!\n"
				"if this is a protocol library you wrote, make sure you're"
				"providing a \033[1mmonome_protocol_new\033[0m function.\n",
				dlerror());
		goto err;
	}

	monome = (*protocol_new.func)();

	if( !monome )
		goto err;

	monome->dl_handle = dl_handle;
	return monome;

err:
	dlclose(dl_handle);
	return NULL;
}

void monome_platform_free(monome_t *monome) {
	void *dl_handle = monome->dl_handle;

	monome->free(monome);
	dlclose(dl_handle);
}
#endif

int monome_platform_open(monome_t *monome, const monome_devmap_t *m,
                         const char *dev) {
	struct termios nt, ot;
	int fd;

	if( (fd = open(dev, O_RDWR | O_NOCTTY | O_NONBLOCK)) < 0 ) {
		perror("libmonome: could not open monome device");
		return 1;
	}

	tcgetattr(fd, &ot);
	nt = ot;

	/* baud rate */
	if( m->quirks & QUIRK_57600_BAUD ) {
		cfsetispeed(&nt, B57600);
		cfsetospeed(&nt, B57600);
	} else {
		cfsetispeed(&nt, MONOME_BAUD_RATE);
		cfsetospeed(&nt, MONOME_BAUD_RATE);
	}

	/* parity (8N1) */
	nt.c_cflag &= ~(PARENB | CSTOPB | CSIZE);
	nt.c_cflag |=  (CS8 | CLOCAL | CREAD);

	/* no line processing */
	nt.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG | IEXTEN);

	/* raw input */
	nt.c_iflag &= ~(IGNBRK | BRKINT | ICRNL | INLCR | PARMRK |
	                INPCK | ISTRIP | IXON);

	/* raw output */
	nt.c_oflag &= ~(OCRNL | ONLCR | ONLRET | ONOCR |
	                OFILL | OPOST);

	nt.c_cc[VMIN]  = 1;
	nt.c_cc[VTIME] = 0;

	if( tcsetattr(fd, TCSANOW, &nt) < 0 )
		goto err_tcsetattr;

	tcflush(fd, TCIOFLUSH);

	monome->fd = fd;
	return 0;

err_tcsetattr:
	perror("libmonome: could not set terminal attributes");

	close(fd);
	return 1;
}

int monome_platform_close(monome_t *monome) {
	return close(monome->fd);
}

ssize_t monome_platform_write(monome_t *monome, const uint8_t *buf, size_t nbyte) {
	ssize_t ret = write(monome->fd, buf, nbyte);

	if( ret < nbyte )
		perror("libmonome: write is missing bytes");

	if( ret < 0 )
		perror("libmonome: error in write");

	return ret;
}

ssize_t monome_platform_read(monome_t *monome, uint8_t *buf, size_t nbyte) {
	ssize_t bytes, ret = 0;
	int err;

	goto start;

	for( ; nbyte; nbyte -= bytes ) {
		err = monome_platform_wait_for_input(monome, READ_TIMEOUT);
		if( err > 0 )
			return ret;
		if( err < 0 )
			return -1;

start:
		if ((bytes = read(monome->fd, buf, nbyte)) < 0) {
			if (errno == EAGAIN || errno == EWOULDBLOCK)
				return 0;
			if (errno == EINTR)
				goto start;

			return bytes;
		}

		ret += bytes;
		buf += bytes;
	}

	return ret;
}

void monome_event_loop(monome_t *monome) {
	monome_callback_t *handler;
	monome_event_t e;

	fd_set fds;

	e.monome = monome;

	do {
		FD_ZERO(&fds);
		FD_SET(monome->fd, &fds);

		if( select(monome->fd + 1, &fds, NULL, NULL, NULL) < 0 ) {
			perror("libmonome: error in select()");
			break;
		}

		if( monome->next_event(monome, &e) < 1 )
			continue;

		handler = &monome->handlers[e.event_type];
		if( !handler->cb )
			continue;

		handler->cb(&e, handler->data);
	} while( 1 );
}

void *m_malloc(size_t size) {
	return malloc(size);
}

void *m_calloc(size_t nmemb, size_t size) {
	return calloc(nmemb, size);
}

void *m_strdup(const char *s) {
	return strdup(s);
}

void m_free(void *ptr) {
	free(ptr);
}

void m_sleep(uint_t msec) {
	usleep(msec * 1000);
}

#ifdef __STRICT_ANSI__
#undef __STRICT_ANSI__
#endif

#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdarg.h>
#include <stdio.h>

/* THIS WAY LIES MADNESS */
#include <windows.h>
#include <winreg.h>
#include <io.h>

#include <monome.h>
#include "internal.h"
#include "platform.h"

#define FTDI_REG_PATH "SYSTEM\\CurrentControlSet\\Enum\\FTDIBUS"

static char *m_asprintf(const char *fmt, ...) {
	va_list args;
	char *buf;
	int len;

	va_start(args, fmt);

	len = _vscprintf(fmt, args) + 1;
	if( !(buf = m_calloc(sizeof(char), len)) )
		return NULL;

	vsprintf(buf, fmt, args);
	va_end(args);

	return buf;
}

monome_t *monome_platform_load_protocol(const char *proto) {
	monome_proto_new_func_t protocol_new;

	monome_t *monome;
	HMODULE proto_mod;
	char *modname;

	if( !(modname = m_asprintf("monome\\protocol_%s.dll", proto)) )
		goto err_loadlibrary;

	proto_mod = LoadLibrary(modname);
	m_free(modname);

	if( !proto_mod )
		goto err_loadlibrary;

	protocol_new = (monome_proto_new_func_t) GetProcAddress(proto_mod, "monome_protocol_new");

	if( !protocol_new )
		goto err_protocol_new;

	if( !(monome = protocol_new()) )
		goto err_protocol_new;

	monome->dl_handle = proto_mod;
	return monome;

err_protocol_new:
	FreeLibrary(proto_mod);
err_loadlibrary:
	return NULL;
}

void monome_platform_free(monome_t *monome) {
	void *dl_handle = monome->dl_handle;

	monome->free(monome);
	FreeLibrary(dl_handle);
}

int monome_platform_open(monome_t *monome, const monome_devmap_t *m,
                         const char *dev) {
	DCB serparm = {0};
	char *devesc;
	HANDLE hser;
	COMMTIMEOUTS timeouts = {
		.ReadIntervalTimeout         = MAXDWORD,
		.ReadTotalTimeoutConstant    = 0,
		.ReadTotalTimeoutMultiplier  = 0,
		.WriteTotalTimeoutConstant   = 0,
		.WriteTotalTimeoutMultiplier = 0
	};

	if( !(devesc = m_asprintf("\\\\.\\%s", dev)) ) {
		fprintf(stderr, "libmonome: could not open %s: out of memory\n", dev);
		return 1;
	}

	hser = CreateFile(devesc, GENERIC_READ | GENERIC_WRITE, 0, NULL,
	                  OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL |
	                  FILE_FLAG_OVERLAPPED, 0);

	free(devesc);

	if( hser == INVALID_HANDLE_VALUE )
		goto err_open;

	serparm.DCBlength = sizeof(serparm);

	if( !GetCommState(hser, &serparm) )
		goto err_commstate;

	if( m->quirks & QUIRK_57600_BAUD )
		serparm.BaudRate = CBR_57600;
	else
		serparm.BaudRate = CBR_115200;

	serparm.ByteSize = 8;
	serparm.StopBits = ONESTOPBIT;
	serparm.Parity   = NOPARITY;
	serparm.fBinary  = 1;

	if( !SetCommState(hser, &serparm) )
		goto err_commstate;

	if( !SetCommTimeouts(hser, &timeouts) )
		goto err_commstate;

	PurgeComm(hser, PURGE_RXCLEAR | PURGE_TXCLEAR);

	monome->fd = _open_osfhandle((intptr_t) hser, _O_RDWR | _O_BINARY);
	return 0;

err_commstate:
	CloseHandle(hser);
err_open:
	if( GetLastError() != ERROR_FILE_NOT_FOUND )
		printf("libmonome: could not open %s: error %ld", dev,
		       GetLastError());
	return 1;
}

int monome_platform_close(monome_t *monome) {
	return !!_close(monome->fd);
}

ssize_t monome_platform_write(monome_t *monome, const uint8_t *buf, size_t nbyte) {
	HANDLE hres = (HANDLE) _get_osfhandle(monome->fd);
	OVERLAPPED ov = {0, 0, {{0, 0}}};
	DWORD written = 0;

	if( !(ov.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL)) ) {
		fprintf(stderr,
				"monome_plaform_write(): could not allocate event (%ld)\n",
				GetLastError());
		return -1;
	}

	if( !WriteFile(hres, buf, nbyte, &written, &ov) ) {
		if( GetLastError() != ERROR_IO_PENDING ) {
			fprintf(stderr, "monome_platform_write(): write failed (%ld)\n",
					GetLastError());
			return -1;
		}

		GetOverlappedResult(hres, &ov, &written, TRUE);
	}

	CloseHandle(ov.hEvent);
	return written;
}

ssize_t monome_platform_read(monome_t *monome, uint8_t *buf, size_t nbyte) {
	HANDLE hres = (HANDLE) _get_osfhandle(monome->fd);
	OVERLAPPED ov = {0, 0, {{0, 0}}};
	DWORD read = 0;

	if( !(ov.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL)) ) {
		fprintf(stderr,
				"monome_plaform_read(): could not allocate event (%ld)\n",
				GetLastError());
		return -1;
	}

	if( !ReadFile(hres, buf, nbyte, &read, &ov) ) {
		if( GetLastError() != ERROR_IO_PENDING ) {
			fprintf(stderr, "monome_platform_read(): read failed (%ld)\n",
					GetLastError());
			return -1;
		}

		GetOverlappedResult(hres, &ov, &read, TRUE);
	}

	CloseHandle(ov.hEvent);
	return read;
}

char *monome_platform_get_dev_serial(const char *path) {
	HKEY key, subkey;
	char subkey_name[MAX_PATH], *subkey_path, *serial;
	unsigned char port_name[64];
	DWORD klen, plen, ptype;
	int i = 0;

	serial = NULL;

	switch( RegOpenKeyEx(
			HKEY_LOCAL_MACHINE, FTDI_REG_PATH,
			0, KEY_READ, &key) ) {
	case ERROR_SUCCESS:
		/* ERROR: request was (unexpectedly) successful */
		break;

	case ERROR_FILE_NOT_FOUND:
		/* print message about needing the FTDI driver maybe? */
		/* fall through also */
	default:
		return NULL;
	}

	do {
		klen = sizeof(subkey_name) / sizeof(char);
		switch( RegEnumKeyEx(key, i++, subkey_name, &klen,
							 NULL, NULL, NULL, NULL) ) {
		case ERROR_MORE_DATA:
		case ERROR_SUCCESS:
			break;

		default:
			goto done;
		}

		subkey_path = m_asprintf("%s\\%s\\0000\\Device Parameters",
								 FTDI_REG_PATH, subkey_name);

		switch( RegOpenKeyEx(
				HKEY_LOCAL_MACHINE, subkey_path,
				0, KEY_READ, &subkey) ) {
		case ERROR_SUCCESS:
			break;

		default:
			continue;
		}

		free(subkey_path);

		plen = sizeof(port_name) / sizeof(char);
		ptype = REG_SZ;
		switch( RegQueryValueEx(subkey, "PortName", 0, &ptype,
								port_name, &plen) ) {
		case ERROR_SUCCESS:
			port_name[plen] = '\0';
			break;

		default:
			goto nomatch;
		}

		if( !strcmp((char *) port_name, path) ) {
			/* there's a fucking "A" right after the serial number */
			subkey_name[klen - 1] = '\0';
			serial = strrchr(subkey_name, '+') + 1;

			RegCloseKey(subkey);
			break;
		}

nomatch:
		RegCloseKey(subkey);
	} while( 1 );

done:
	RegCloseKey(key);
	return ( serial ) ? strdup(serial) : NULL;
}

int monome_platform_wait_for_input(monome_t *monome, uint_t msec) {
	Sleep(msec); /* fuck it */
	return 1;
}

void monome_event_loop(monome_t *monome) {
	printf("monome_event_loop() is unimplemented\n");
	return;
}

void *m_malloc(size_t size) {
	return malloc(size);
}

void *m_calloc(size_t nmemb, size_t size) {
	return calloc(nmemb, size);
}

void *m_strdup(const char *s) {
	return _strdup(s);
}

void m_free(void *ptr) {
	free(ptr);
}

void m_sleep(uint_t msec) {
	Sleep(msec);
}

#include "AlphaChooser.h"
#include "cinder/gl/gl.h"
#include "cinder/Text.h"
#include "Globals.h"
#include "BloomGl.h"
#include "BloomScene.h"
#include "cinder/Utilities.h" // for toString
#include <sstream>

using namespace ci;
using namespace ci::app;
using namespace std;

void AlphaChooser::setup( const Font &font, const Vec2f &interfaceSize )
{	
	// Textures
	mAlphaString	= "ABCDEFGHIJKLMNOPQRSTUVWXYZ#";
	mAlphaIndex		= 0;
	mAlphaChar		= 'A';

	for( int i=0; i<mAlphaString.length(); i++ ){
		TextLayout layout;	
		layout.setFont( font );
		layout.setColor( Color::white() );
		layout.addCenteredLine( ci::toString(mAlphaString[i]) );
		mAlphaTextures.push_back( gl::Texture( layout.render( true, false ) ) );
	}
    
    mInterfaceSize = interfaceSize;
    
    setRects();
}

void AlphaChooser::setRects()
{
	mAlphaRects.clear();
    mAlphaHitRects.clear();
    float totalWidth = 0.0f;
    float maxHeight = 0.0f;
	for( int i=0; i<mAlphaString.length(); i++ ){
        totalWidth += mAlphaTextures[i].getWidth();
        maxHeight = max( maxHeight, (float)mAlphaTextures[i].getHeight() );
    }    
    const float hPadding = 20.0f;
    const float vTopPadding = 11.0f;
    const float vBottomPadding = 9.0f;
    const float spacing = (mInterfaceSize.x - totalWidth - (hPadding * 2.0f)) / 26.0f;
    float x = hPadding;
	for( int i = 0; i < mAlphaString.length(); i++ ){
		const float w = mAlphaTextures[i].getWidth();
		const float h = mAlphaTextures[i].getHeight();
		mAlphaRects.push_back( Rectf( x, vTopPadding, x + w, h + vTopPadding ) );
		mAlphaHitRects.push_back( Rectf( x - spacing/2.0f, 0.0f, x + w + spacing/2.0f, h + vTopPadding + vBottomPadding ) );
        x += w + spacing;
	}
    mFullRect.set( 0.0f, 0.0f, mInterfaceSize.x, maxHeight + vTopPadding + vBottomPadding );
}

bool AlphaChooser::touchBegan( TouchEvent::Touch touch )
{
    if (!isVisible()) return false;    
    Vec2f pos = globalToLocal( touch.getPos() );
    return mFullRect.contains( pos );
}

bool AlphaChooser::touchMoved( TouchEvent::Touch touch )
{	
    if (!isVisible()) return false;
    
    Vec2f pos = globalToLocal( touch.getPos() );
    for (int i = 0; i < mAlphaRects.size(); i++) {
        if ( mNumberAlphaPerChar[i] ) {                        
            if ( mAlphaHitRects[i].contains( pos ) ) {
                mAlphaIndex = i;
                if( mAlphaChar != mAlphaString[i] ){            
                    mAlphaChar = mAlphaString[i];
                    mCallbacksAlphaCharSelected.call( mAlphaChar );
                }
                return true;
            }
        }
    }
    
    return mFullRect.contains( pos );
}

bool AlphaChooser::touchEnded( TouchEvent::Touch touch )
{	
    if (!isVisible()) return false;

    Vec2f pos = globalToLocal( touch.getPos() );
    for (int i = 0; i < mAlphaRects.size(); i++) {
        if ( mNumberAlphaPerChar[i] ) {            
            if ( mAlphaHitRects[i].contains( pos ) ) {
                mAlphaIndex = i;
                mAlphaChar = mAlphaString[i];
                mCallbacksAlphaCharSelected.call( mAlphaChar );
                return true;
            }
        }
    }

    return mFullRect.contains( pos );
}

void AlphaChooser::setNumberAlphaPerChar( float *numberAlphaPerChar )
{
    mNumberAlphaPerChar = numberAlphaPerChar;
}

void AlphaChooser::update( )
{    
    Vec2f interfaceSize = getRoot()->getInterfaceSize();    
    if (mInterfaceSize != interfaceSize) {
        mInterfaceSize = interfaceSize;
        setRects();        
    }
}

void AlphaChooser::draw()
{	        
    // we'll use the bright blue components to draw by frequency
    float r = BRIGHT_BLUE.r;
    float g = BRIGHT_BLUE.g;
    float b = BRIGHT_BLUE.b;

    gl::color( ColorA( r, g, b, mOpacity * 0.125f ) );
    gl::drawLine( mFullRect.getUpperLeft(), mFullRect.getUpperRight() );
            
    for( int i=0; i<27; i++ ){
        float c = mNumberAlphaPerChar[i];
        if ( mAlphaString[i] == mAlphaChar ) {
            gl::color( ColorA( 1.0f, 1.0f, 1.0f, 1.0f * mOpacity ) );
        } else if( c > 0.0f ){
            c += 0.3f;
            gl::color( ColorA( r*c, g*c, b*c, mOpacity ) );
        } else {
            gl::color( ColorA( 0.1f, 0.1f, 0.15f, mOpacity ) );
        }
        mAlphaTextures[i].enableAndBind();
        gl::drawSolidRect( mAlphaRects[i] );
        mAlphaTextures[i].disable();            
    }
}

float AlphaChooser::getHeight()
{
    return mFullRect.getHeight();
}

#pragma once
#include <vector>
#include "cinder/Vector.h"
#include "cinder/gl/Texture.h"
#include "cinder/Rect.h"
#include "cinder/Color.h"
#include "cinder/Font.h"
#include "BloomNode.h"
#include "PlaylistChooser.h"
#include "AlphaChooser.h"
#include "PlayControls.h"
#include "SettingsPanel.h"

class UiLayer : public BloomNode {
 public:
	
    UiLayer(): 
        BloomNode(), // get a default ID
        mChooserY(0.0f), 
        mSettingsY(0.0f), 
        mChooserDestY(0.0f), 
        mSettingsDestY(0.0f) 
    { }; 
    
	~UiLayer() {};
    
	void	setup( PlaylistChooserRef playlistChooser, 
                   AlphaChooserRef alphaChooser, 
                   PlayControlsRef playControls, 
                   SettingsPanelRef settingsPanel,
                   const ci::gl::Texture &uiButtonsTex, 
                   const bool &showSettings, 
                   const ci::Vec2f interfaceSize );
	
    bool	touchBegan( ci::app::TouchEvent::Touch touch );
	bool	touchMoved( ci::app::TouchEvent::Touch touch );
	bool	touchEnded( ci::app::TouchEvent::Touch touch );

    void    setShowSettings( bool visible );
    
	void    update();
	void    draw();
    
	float   getPanelYPos(){ return mPanelY; }	

	bool	getIsPanelOpen() { return mIsPanelOpen; }
	void	setIsPanelOpen( bool b ){ mIsPanelOpen = b; mHasPanelBeenDragged = false; }
	
    bool    hitTest( ci::Vec2f globalPos );
    
    //// expand/collapse/query panels
    void    setShowAlphaFilter(bool visible);
    bool    isShowingAlphaFilter();
    void    setShowPlaylistFilter(bool visible);
    bool    isShowingPlaylistFilter();
    bool    isShowingFilter();    
    
 private:

    void updateLayout( ci::Vec2f interfaceSize );
    
    ci::Vec2f       mInterfaceSize; // for detecting orientation changes    
    ci::gl::Texture mButtonsTex;
    
    float           mPanelY;                // used in setTransform
    float           mPanelOpenY;            // updated in setShowSettings/updateLayout
    float           mPanelClosedY;          // updated in updateLayout
	ci::Rectf		mPanelTabRect;			// Rect defining the panel tab
    
	bool			mIsPanelTabTouched;		// Is the Panel Tab currently being touched
	bool			mIsPanelOpen;			// Is the Panel fully open
	bool			mHasPanelBeenDragged;   // Are we dragging or just animating?
    ci::Vec2f		mPanelTabTouchOffset;	// Remember the touch position value when dragging	
    
    float           getPanelHeight();
    float           getMaxPanelHeight();
    
    float           mChooserY, mSettingsY;
    float           mChooserDestY, mSettingsDestY;
    
    PlaylistChooserRef mPlaylistChooser;
    AlphaChooserRef    mAlphaChooser;
    PlayControlsRef    mPlayControls;
    SettingsPanelRef   mSettingsPanel;
};

typedef std::shared_ptr<UiLayer> UiLayerRef;

#include "TimeLabel.h"
#include "cinder/gl/gl.h"
#include "cinder/Text.h"
#include "BloomGl.h"

void TimeLabel::setSeconds(int seconds)
{ 
    if (mSeconds != seconds) { 
        mSeconds = seconds; 
        updateTexture(); 
    }
}

void TimeLabel::updateTexture()
{
	int hours	= floor(abs(mSeconds)/3600.0f);
    int minutes = floor(abs(mSeconds)/60.0f);
	minutes = minutes - hours * 60;
    int seconds = (int)abs(mSeconds)%60;
    
	string hourStr = ci::toString( hours );
    string minsStr = ci::toString( minutes );
    string secsStr = ci::toString( seconds );
    if( minsStr.length() == 1 ) minsStr = "0" + minsStr;
    if( secsStr.length() == 1 ) secsStr = "0" + secsStr;		
	
    stringstream ss;
	if( hours > 0 )
		ss << hourStr << ":";
    ss << minsStr << ":" << secsStr << endl;
        
    TextLayout layout;
    layout.setFont( mFont );
    layout.setColor( mColor );
    layout.addLine( ss.str() );
    mTexture = layout.render( true, false );

    if (mSeconds <= 0) {
        TextLayout hyphenLayout;
        hyphenLayout.setFont( mFont );
        hyphenLayout.setColor( mColor );
        hyphenLayout.addLine( "-" );
        mHyphenTexture = hyphenLayout.render( true, false );
    }
    else {
        mHyphenTexture.reset();
    }
}

void TimeLabel::draw()
{
    // to keep the digit left-aligned in the box, squeeze the minus sign in before it
    if (mHyphenTexture) {
        bloom::gl::batchRect( mHyphenTexture, mRect.getUpperLeft() - Vec2f(mHyphenTexture.getWidth()-1.0f,0) );
    }    
    if (mTexture) {
        bloom::gl::batchRect( mTexture, mRect.getUpperLeft() );
    }
}

bool TimeLabel::touchBegan(ci::app::TouchEvent::Touch touch)
{
    return mRect.contains( globalToLocal( touch.getPos() ) );
}
bool TimeLabel::touchEnded(ci::app::TouchEvent::Touch touch)
{
    return mRect.contains( globalToLocal( touch.getPos() ) );
}

#include "TextureRect.h"
#include "cinder/gl/gl.h"
#include "BloomGl.h"

using namespace ci;

void TextureRect::draw()
{
    bloom::gl::batchRect( mTexture, mArea, mRect );
}

#include "Stats.h"
#include <sstream>
#include "cinder/gl/gl.h"
#include "cinder/Text.h"

using namespace std;
using namespace ci;

void Stats::setup(const Font &font, const Color &fpsColor, const Color &color)
{
    mFont = font;
    mFpsColor = fpsColor;
    mColor = color;
}

void Stats::update(const float &fps, 
                   const float &playheadTime, 
                   const float &fov,
				   const float &camDist,
				   const float &pinchPer,
                   const float &currentLevel, 
                   const float &zoom)
{
    stringstream s;
	TextLayout layout;	
	layout.setFont( mFont );
	layout.setColor( mColor );

	s.str("");
	s << "FPS: " << fps;
	layout.addLine( s.str() );
	
//	s.str("");
//	s << "FOV: " << fov;
//	layout.addLine( s.str() );
//	
//	s.str("");
//	s << "mCamDist: " << camDist;
//	layout.addLine( s.str() );
//	
//	s.str("");
//	s << "mPinchTotalDest: " << pinchPer;
//	layout.addLine( s.str() );
	
	mParamsTex = gl::Texture( layout.render( true, false ) );    
}

void Stats::draw(const Matrix44f &mtx)
{
    if (mParamsTex) {
        glPushMatrix();
        glMultMatrixf( mtx );
        gl::color( ColorA( Color::white(), 0.1f ) );
        gl::draw( mParamsTex, Vec2f( 23.0f, 15.0f ) );
        glPopMatrix();    
    }
}

#include "xpcprivate.h"
#include "nsString.h"
#include "nsIObjectOutputStream.h"
#include "nsIObjectInputStream.h"
#include "nsJSPrincipals.h"
#include "plstr.h"
#include "nsXPIDLString.h"
#include "nsCOMPtr.h"
#include "nsIJSRuntimeService.h"
#include "nsIServiceManager.h"
#include "nsMemory.h"
#include "nsStringBuffer.h"

// for mozilla::dom::workers::kJSPrincipalsDebugToken
#include "mozilla/dom/workers/Workers.h"

/* static */ bool
nsJSPrincipals::Subsume(JSPrincipals *jsprin, JSPrincipals *other)
{
    bool result;
    nsresult rv = nsJSPrincipals::get(jsprin)->Subsumes(nsJSPrincipals::get(other), &result);
    return NS_SUCCEEDED(rv) && result;
}

/* static */ void
nsJSPrincipals::Destroy(JSPrincipals *jsprin)
{
    // The JS runtime can call this method during the last GC when
    // nsScriptSecurityManager is destroyed. So we must not assume here that
    // the security manager still exists.

    nsJSPrincipals *nsjsprin = nsJSPrincipals::get(jsprin);

    // We need to destroy the nsIPrincipal. We'll do this by adding
    // to the refcount and calling release

#ifdef NS_BUILD_REFCNT_LOGGING
    // The refcount logging considers AddRef-to-1 to indicate creation,
    // so trick it into thinking it's otherwise, but balance the
    // Release() we do below.
    nsjsprin->refcount++;
    nsjsprin->AddRef();
    nsjsprin->refcount--;
#else
    nsjsprin->refcount++;
#endif
    nsjsprin->Release();
}

#ifdef DEBUG

// Defined here so one can do principals->dump() in the debugger
JS_EXPORT_API(void)
JSPrincipals::dump()
{
    if (debugToken == nsJSPrincipals::DEBUG_TOKEN) {
        static_cast<nsJSPrincipals *>(this)->dumpImpl();
    } else if (debugToken == mozilla::dom::workers::kJSPrincipalsDebugToken) {
        fprintf(stderr, "Web Worker principal singleton (%p)\n", this);
    } else {
        fprintf(stderr,
                "!!! JSPrincipals (%p) is not nsJSPrincipals instance - bad token: "
                "actual=0x%x expected=0x%x\n",
                this, unsigned(debugToken), unsigned(nsJSPrincipals::DEBUG_TOKEN));
    }
}

#endif 

#include "nscore.h"
#include "nsSystemPrincipal.h"
#include "nsIComponentManager.h"
#include "nsIServiceManager.h"
#include "nsIURL.h"
#include "nsCOMPtr.h"
#include "nsXPIDLString.h"
#include "nsReadableUtils.h"
#include "nsCRT.h"
#include "nsString.h"
#include "nsIClassInfoImpl.h"
#include "nsIScriptSecurityManager.h"
#include "pratom.h"

NS_IMPL_CLASSINFO(nsSystemPrincipal, nullptr,
                  nsIClassInfo::SINGLETON | nsIClassInfo::MAIN_THREAD_ONLY,
                  NS_SYSTEMPRINCIPAL_CID)
NS_IMPL_QUERY_INTERFACE2_CI(nsSystemPrincipal,
                            nsIPrincipal,
                            nsISerializable)
NS_IMPL_CI_INTERFACE_GETTER2(nsSystemPrincipal,
                             nsIPrincipal,
                             nsISerializable)

NS_IMETHODIMP_(nsrefcnt) 
nsSystemPrincipal::AddRef()
{
  NS_PRECONDITION(int32_t(refcount) >= 0, "illegal refcnt");
  nsrefcnt count = PR_ATOMIC_INCREMENT(&refcount);
  NS_LOG_ADDREF(this, count, "nsSystemPrincipal", sizeof(*this));
  return count;
}

NS_IMETHODIMP_(nsrefcnt)
nsSystemPrincipal::Release()
{
  NS_PRECONDITION(0 != refcount, "dup release");
  nsrefcnt count = PR_ATOMIC_DECREMENT(&refcount);
  NS_LOG_RELEASE(this, count, "nsSystemPrincipal");
  if (count == 0) {
    delete this;
  }

  return count;
}

static const char SYSTEM_PRINCIPAL_SPEC[] = "[System Principal]";

void
nsSystemPrincipal::GetScriptLocation(nsACString &aStr)
{
    aStr.Assign(SYSTEM_PRINCIPAL_SPEC);
}

#ifdef DEBUG
void nsSystemPrincipal::dumpImpl()
{
  fprintf(stderr, "nsSystemPrincipal (%p)\n", this);
}
#endif 


///////////////////////////////////////
// Methods implementing nsIPrincipal //
///////////////////////////////////////

NS_IMETHODIMP
nsSystemPrincipal::Equals(nsIPrincipal *other, bool *result)
{
    *result = (other == this);
    return NS_OK;
}

NS_IMETHODIMP
nsSystemPrincipal::EqualsIgnoringDomain(nsIPrincipal *other, bool *result)
{
    return Equals(other, result);
}

NS_IMETHODIMP
nsSystemPrincipal::Subsumes(nsIPrincipal *other, bool *result)
{
    *result = true;
    return NS_OK;
}

NS_IMETHODIMP
nsSystemPrincipal::SubsumesIgnoringDomain(nsIPrincipal *other, bool *result)
{
    *result = true;
    return NS_OK;
}

NS_IMETHODIMP
nsSystemPrincipal::CheckMayLoad(nsIURI* uri, bool aReport, bool aAllowIfInheritsPrincipal)
{
    return NS_OK;
}

NS_IMETHODIMP
nsSystemPrincipal::GetHashValue(uint32_t *result)
{
    *result = NS_PTR_TO_INT32(this);
    return NS_OK;
}

NS_IMETHODIMP 
nsSystemPrincipal::GetURI(nsIURI** aURI)
{
    *aURI = nullptr;
    return NS_OK;
}

NS_IMETHODIMP 
nsSystemPrincipal::GetOrigin(char** aOrigin)
{
    *aOrigin = ToNewCString(NS_LITERAL_CSTRING(SYSTEM_PRINCIPAL_SPEC));
    return *aOrigin ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
}

NS_IMETHODIMP
nsSystemPrincipal::GetCsp(nsIContentSecurityPolicy** aCsp)
{
  *aCsp = nullptr;
  return NS_OK;
}

NS_IMETHODIMP
nsSystemPrincipal::SetCsp(nsIContentSecurityPolicy* aCsp)
{
  // CSP on a null principal makes no sense
  return NS_OK;
}

NS_IMETHODIMP
nsSystemPrincipal::GetDomain(nsIURI** aDomain)
{
    *aDomain = nullptr;
    return NS_OK;
}

NS_IMETHODIMP
nsSystemPrincipal::SetDomain(nsIURI* aDomain)
{
  return NS_OK;
}

NS_IMETHODIMP
nsSystemPrincipal::GetSecurityPolicy(void** aSecurityPolicy)
{
    *aSecurityPolicy = nullptr;
    return NS_OK;
}

NS_IMETHODIMP
nsSystemPrincipal::SetSecurityPolicy(void* aSecurityPolicy)
{
    return NS_OK;
}

NS_IMETHODIMP
nsSystemPrincipal::GetJarPrefix(nsACString& aJarPrefix)
{
  aJarPrefix.Truncate();
  return NS_OK;
}

NS_IMETHODIMP
nsSystemPrincipal::GetAppStatus(uint16_t* aAppStatus)
{
  *aAppStatus = nsIPrincipal::APP_STATUS_NOT_INSTALLED;
  return NS_OK;
}

NS_IMETHODIMP
nsSystemPrincipal::GetAppId(uint32_t* aAppId)
{
  *aAppId = nsIScriptSecurityManager::NO_APP_ID;
  return NS_OK;
}

NS_IMETHODIMP
nsSystemPrincipal::GetIsInBrowserElement(bool* aIsInBrowserElement)
{
  *aIsInBrowserElement = false;
  return NS_OK;
}

NS_IMETHODIMP
nsSystemPrincipal::GetUnknownAppId(bool* aUnknownAppId)
{
  *aUnknownAppId = false;
  return NS_OK;
}

NS_IMETHODIMP
nsSystemPrincipal::GetIsNullPrincipal(bool* aIsNullPrincipal)
{
  *aIsNullPrincipal = false;
  return NS_OK;
}

NS_IMETHODIMP
nsSystemPrincipal::GetBaseDomain(nsACString& aBaseDomain)
{
  // No base domain for chrome.
  return NS_OK;
}

//////////////////////////////////////////
// Methods implementing nsISerializable //
//////////////////////////////////////////

NS_IMETHODIMP
nsSystemPrincipal::Read(nsIObjectInputStream* aStream)
{
    // no-op: CID is sufficient to identify the mSystemPrincipal singleton
    return NS_OK;
}

NS_IMETHODIMP
nsSystemPrincipal::Write(nsIObjectOutputStream* aStream)
{
    // no-op: CID is sufficient to identify the mSystemPrincipal singleton
    return NS_OK;
}

/////////////////////////////////////////////
// Constructor, Destructor, initialization //
/////////////////////////////////////////////

nsSystemPrincipal::nsSystemPrincipal()
{
}

nsSystemPrincipal::~nsSystemPrincipal()
{
}

/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
/* vim: set ts=4 et sw=4 tw=80: */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#include "nsScriptSecurityManager.h"

#include "mozilla/Util.h"

#include "js/OldDebugAPI.h"
#include "xpcprivate.h"
#include "XPCWrapper.h"
#include "nsIServiceManager.h"
#include "nsIScriptObjectPrincipal.h"
#include "nsIScriptContext.h"
#include "nsIURL.h"
#include "nsINestedURI.h"
#include "nspr.h"
#include "nsJSPrincipals.h"
#include "nsSystemPrincipal.h"
#include "nsPrincipal.h"
#include "nsNullPrincipal.h"
#include "DomainPolicy.h"
#include "nsXPIDLString.h"
#include "nsCRT.h"
#include "nsCRTGlue.h"
#include "nsError.h"
#include "nsDOMCID.h"
#include "nsIXPConnect.h"
#include "nsIXPCSecurityManager.h"
#include "nsTextFormatter.h"
#include "nsIStringBundle.h"
#include "nsNetUtil.h"
#include "nsIProperties.h"
#include "nsDirectoryServiceDefs.h"
#include "nsIFile.h"
#include "nsIFileURL.h"
#include "nsIZipReader.h"
#include "nsIXPConnect.h"
#include "nsIScriptGlobalObject.h"
#include "nsPIDOMWindow.h"
#include "nsIDocShell.h"
#include "nsIPrompt.h"
#include "nsIWindowWatcher.h"
#include "nsIConsoleService.h"
#include "nsISecurityCheckedComponent.h"
#include "nsIJSRuntimeService.h"
#include "nsIObserverService.h"
#include "nsIContent.h"
#include "nsAutoPtr.h"
#include "nsDOMJSUtils.h"
#include "nsAboutProtocolUtils.h"
#include "nsIClassInfo.h"
#include "nsIURIFixup.h"
#include "nsCDefaultURIFixup.h"
#include "nsIChromeRegistry.h"
#include "nsIContentSecurityPolicy.h"
#include "nsIAsyncVerifyRedirectCallback.h"
#include "mozilla/Preferences.h"
#include "mozilla/dom/BindingUtils.h"
#include <stdint.h>
#include "mozilla/ClearOnShutdown.h"
#include "mozilla/StaticPtr.h"
#include "nsContentUtils.h"
#include "nsCxPusher.h"
#include "nsJSUtils.h"

// This should be probably defined on some other place... but I couldn't find it
#define WEBAPPS_PERM_NAME "webapps-manage"

using namespace mozilla;
using namespace mozilla::dom;

static NS_DEFINE_CID(kZipReaderCID, NS_ZIPREADER_CID);

nsIIOService    *nsScriptSecurityManager::sIOService = nullptr;
nsIStringBundle *nsScriptSecurityManager::sStrBundle = nullptr;
JSRuntime       *nsScriptSecurityManager::sRuntime   = 0;
bool nsScriptSecurityManager::sStrictFileOriginPolicy = true;

// Lazily initialized. Use the getter below.
static jsid sEnabledID = JSID_VOID;
static JS::HandleId
EnabledID()
{
    if (sEnabledID != JSID_VOID)
        return JS::HandleId::fromMarkedLocation(&sEnabledID);
    AutoSafeJSContext cx;
    sEnabledID = INTERNED_STRING_TO_JSID(cx, JS_InternString(cx, "enabled"));
    return JS::HandleId::fromMarkedLocation(&sEnabledID);
}

bool
nsScriptSecurityManager::SubjectIsPrivileged()
{
    JSContext *cx = GetCurrentJSContext();
    if (cx && xpc::IsUniversalXPConnectEnabled(cx))
        return true;
    bool isSystem = false;
    return NS_SUCCEEDED(SubjectPrincipalIsSystem(&isSystem)) && isSystem;
}

///////////////////////////
// Convenience Functions //
///////////////////////////
// Result of this function should not be freed.
static inline const PRUnichar *
IDToString(JSContext *cx, jsid id_)
{
    JS::RootedId id(cx, id_);
    if (JSID_IS_STRING(id))
        return JS_GetInternedStringChars(JSID_TO_STRING(id));

    JS::Rooted<JS::Value> idval(cx);
    if (!JS_IdToValue(cx, id, idval.address()))
        return nullptr;
    JSString *str = JS::ToString(cx, idval);
    if(!str)
        return nullptr;
    return JS_GetStringCharsZ(cx, str);
}

class nsAutoInPrincipalDomainOriginSetter {
public:
    nsAutoInPrincipalDomainOriginSetter() {
        ++sInPrincipalDomainOrigin;
    }
    ~nsAutoInPrincipalDomainOriginSetter() {
        --sInPrincipalDomainOrigin;
    }
    static uint32_t sInPrincipalDomainOrigin;
};
uint32_t nsAutoInPrincipalDomainOriginSetter::sInPrincipalDomainOrigin;

static
nsresult
GetOriginFromURI(nsIURI* aURI, nsACString& aOrigin)
{
  if (nsAutoInPrincipalDomainOriginSetter::sInPrincipalDomainOrigin > 1) {
      // Allow a single recursive call to GetPrincipalDomainOrigin, since that
      // might be happening on a different principal from the first call.  But
      // after that, cut off the recursion; it just indicates that something
      // we're doing in this method causes us to reenter a security check here.
      return NS_ERROR_NOT_AVAILABLE;
  }

  nsAutoInPrincipalDomainOriginSetter autoSetter;

  nsCOMPtr<nsIURI> uri = NS_GetInnermostURI(aURI);
  NS_ENSURE_TRUE(uri, NS_ERROR_UNEXPECTED);

  nsAutoCString hostPort;

  nsresult rv = uri->GetHostPort(hostPort);
  if (NS_SUCCEEDED(rv)) {
    nsAutoCString scheme;
    rv = uri->GetScheme(scheme);
    NS_ENSURE_SUCCESS(rv, rv);
    aOrigin = scheme + NS_LITERAL_CSTRING("://") + hostPort;
  }
  else {
    // Some URIs (e.g., nsSimpleURI) don't support host. Just
    // get the full spec.
    rv = uri->GetSpec(aOrigin);
    NS_ENSURE_SUCCESS(rv, rv);
  }

  return NS_OK;
}

static
nsresult
GetPrincipalDomainOrigin(nsIPrincipal* aPrincipal,
                         nsACString& aOrigin)
{

  nsCOMPtr<nsIURI> uri;
  aPrincipal->GetDomain(getter_AddRefs(uri));
  if (!uri) {
    aPrincipal->GetURI(getter_AddRefs(uri));
  }
  NS_ENSURE_TRUE(uri, NS_ERROR_UNEXPECTED);

  return GetOriginFromURI(uri, aOrigin);
}

inline void SetPendingException(JSContext *cx, const char *aMsg)
{
    JS_ReportError(cx, "%s", aMsg);
}

inline void SetPendingException(JSContext *cx, const PRUnichar *aMsg)
{
    JS_ReportError(cx, "%hs", aMsg);
}

// DomainPolicy members
uint32_t DomainPolicy::sGeneration = 0;

// Helper class to get stuff from the ClassInfo and not waste extra time with
// virtual method calls for things it has already gotten
class ClassInfoData
{
public:
    ClassInfoData(nsIClassInfo *aClassInfo, const char *aName)
        : mClassInfo(aClassInfo),
          mName(const_cast<char *>(aName)),
          mDidGetFlags(false),
          mMustFreeName(false)
    {
    }

    ~ClassInfoData()
    {
        if (mMustFreeName)
            nsMemory::Free(mName);
    }

    uint32_t GetFlags()
    {
        if (!mDidGetFlags) {
            if (mClassInfo) {
                nsresult rv = mClassInfo->GetFlags(&mFlags);
                if (NS_FAILED(rv)) {
                    mFlags = 0;
                }
            } else {
                mFlags = 0;
            }

            mDidGetFlags = true;
        }

        return mFlags;
    }

    bool IsDOMClass()
    {
        return !!(GetFlags() & nsIClassInfo::DOM_OBJECT);
    }

    const char* GetName()
    {
        if (!mName) {
            if (mClassInfo) {
                mClassInfo->GetClassDescription(&mName);
            }

            if (mName) {
                mMustFreeName = true;
            } else {
                mName = const_cast<char *>("UnnamedClass");
            }
        }

        return mName;
    }

private:
    nsIClassInfo *mClassInfo; // WEAK
    uint32_t mFlags;
    char *mName;
    bool mDidGetFlags;
    bool mMustFreeName;
};

JSContext *
nsScriptSecurityManager::GetCurrentJSContext()
{
    // Get JSContext from stack.
    return nsXPConnect::XPConnect()->GetCurrentJSContext();
}

JSContext *
nsScriptSecurityManager::GetSafeJSContext()
{
    // Get JSContext from stack.
    return nsXPConnect::XPConnect()->GetSafeJSContext();
}

/* static */
bool
nsScriptSecurityManager::SecurityCompareURIs(nsIURI* aSourceURI,
                                             nsIURI* aTargetURI)
{
    return NS_SecurityCompareURIs(aSourceURI, aTargetURI, sStrictFileOriginPolicy);
}

// SecurityHashURI is consistent with SecurityCompareURIs because NS_SecurityHashURI
// is consistent with NS_SecurityCompareURIs.  See nsNetUtil.h.
uint32_t
nsScriptSecurityManager::SecurityHashURI(nsIURI* aURI)
{
    return NS_SecurityHashURI(aURI);
}

NS_IMETHODIMP
nsScriptSecurityManager::GetChannelPrincipal(nsIChannel* aChannel,
                                             nsIPrincipal** aPrincipal)
{
    NS_PRECONDITION(aChannel, "Must have channel!");
    nsCOMPtr<nsISupports> owner;
    aChannel->GetOwner(getter_AddRefs(owner));
    if (owner) {
        CallQueryInterface(owner, aPrincipal);
        if (*aPrincipal) {
            return NS_OK;
        }
    }

    // OK, get the principal from the URI.  Make sure this does the same thing
    // as nsDocument::Reset and XULDocument::StartDocumentLoad.
    nsCOMPtr<nsIURI> uri;
    nsresult rv = NS_GetFinalChannelURI(aChannel, getter_AddRefs(uri));
    NS_ENSURE_SUCCESS(rv, rv);

    nsCOMPtr<nsIDocShell> docShell;
    NS_QueryNotificationCallbacks(aChannel, docShell);

    if (docShell) {
        return GetDocShellCodebasePrincipal(uri, docShell, aPrincipal);
    }

    return GetCodebasePrincipalInternal(uri, UNKNOWN_APP_ID,
        /* isInBrowserElement */ false, aPrincipal);
}

NS_IMETHODIMP
nsScriptSecurityManager::IsSystemPrincipal(nsIPrincipal* aPrincipal,
                                           bool* aIsSystem)
{
    *aIsSystem = (aPrincipal == mSystemPrincipal);
    return NS_OK;
}

NS_IMETHODIMP_(nsIPrincipal *)
nsScriptSecurityManager::GetCxSubjectPrincipal(JSContext *cx)
{
    NS_ASSERTION(cx == GetCurrentJSContext(),
                 "Uh, cx is not the current JS context!");

    nsresult rv = NS_ERROR_FAILURE;
    nsIPrincipal *principal = GetSubjectPrincipal(cx, &rv);
    if (NS_FAILED(rv))
        return nullptr;

    return principal;
}

////////////////////
// Policy Storage //
////////////////////

// Table of security levels
static bool
DeleteCapability(nsHashKey *aKey, void *aData, void* closure)
{
    NS_Free(aData);
    return true;
}

//-- Per-Domain Policy - applies to one or more protocols or hosts
struct DomainEntry
{
    DomainEntry(const char* aOrigin,
                DomainPolicy* aDomainPolicy) : mOrigin(aOrigin),
                                               mDomainPolicy(aDomainPolicy),
                                               mNext(nullptr)
    {
        mDomainPolicy->Hold();
    }

    ~DomainEntry()
    {
        mDomainPolicy->Drop();
    }

    bool Matches(const char *anOrigin)
    {
        int len = strlen(anOrigin);
        int thisLen = mOrigin.Length();
        if (len < thisLen)
            return false;
        if (mOrigin.RFindChar(':', thisLen-1, 1) != -1)
        //-- Policy applies to all URLs of this scheme, compare scheme only
            return mOrigin.EqualsIgnoreCase(anOrigin, thisLen);

        //-- Policy applies to a particular host; compare domains
        if (!mOrigin.Equals(anOrigin + (len - thisLen)))
            return false;
        if (len == thisLen)
            return true;
        char charBefore = anOrigin[len-thisLen-1];
        return (charBefore == '.' || charBefore == ':' || charBefore == '/');
    }

    nsCString         mOrigin;
    DomainPolicy*     mDomainPolicy;
    DomainEntry*      mNext;
};

static bool
DeleteDomainEntry(nsHashKey *aKey, void *aData, void* closure)
{
    DomainEntry *entry = (DomainEntry*) aData;
    do
    {
        DomainEntry *next = entry->mNext;
        delete entry;
        entry = next;
    } while (entry);
    return true;
}

/////////////////////////////
// nsScriptSecurityManager //
/////////////////////////////

////////////////////////////////////
// Methods implementing ISupports //
////////////////////////////////////
NS_IMPL_ISUPPORTS4(nsScriptSecurityManager,
                   nsIScriptSecurityManager,
                   nsIXPCSecurityManager,
                   nsIChannelEventSink,
                   nsIObserver)

///////////////////////////////////////////////////
// Methods implementing nsIScriptSecurityManager //
///////////////////////////////////////////////////

///////////////// Security Checks /////////////////

bool
nsScriptSecurityManager::ContentSecurityPolicyPermitsJSAction(JSContext *cx)
{
    // Get the security manager
    nsScriptSecurityManager *ssm =
        nsScriptSecurityManager::GetScriptSecurityManager();

    NS_ASSERTION(ssm, "Failed to get security manager service");
    if (!ssm)
        return false;

    nsresult rv;
    nsIPrincipal* subjectPrincipal = ssm->GetSubjectPrincipal(cx, &rv);

    NS_ASSERTION(NS_SUCCEEDED(rv), "CSP: Failed to get nsIPrincipal from js context");
    if (NS_FAILED(rv))
        return false; // Not just absence of principal, but failure.

    if (!subjectPrincipal)
        return true;

    nsCOMPtr<nsIContentSecurityPolicy> csp;
    rv = subjectPrincipal->GetCsp(getter_AddRefs(csp));
    NS_ASSERTION(NS_SUCCEEDED(rv), "CSP: Failed to get CSP from principal.");

    // don't do anything unless there's a CSP
    if (!csp)
        return true;

    bool evalOK = true;
    bool reportViolation = false;
    rv = csp->GetAllowsEval(&reportViolation, &evalOK);

    if (NS_FAILED(rv))
    {
        NS_WARNING("CSP: failed to get allowsEval");
        return true; // fail open to not break sites.
    }

    if (reportViolation) {
        nsAutoString fileName;
        unsigned lineNum = 0;
        NS_NAMED_LITERAL_STRING(scriptSample, "call to eval() or related function blocked by CSP");

        JS::RootedScript script(cx);
        if (JS_DescribeScriptedCaller(cx, &script, &lineNum)) {
            if (const char *file = JS_GetScriptFilename(cx, script)) {
                CopyUTF8toUTF16(nsDependentCString(file), fileName);
            }
        }
        csp->LogViolationDetails(nsIContentSecurityPolicy::VIOLATION_TYPE_EVAL,
                                 fileName,
                                 scriptSample,
                                 lineNum,
                                 EmptyString());
    }

    return evalOK;
}


bool
nsScriptSecurityManager::CheckObjectAccess(JSContext *cx, JS::Handle<JSObject*> obj,
                                           JS::Handle<jsid> id, JSAccessMode mode,
                                           JS::MutableHandle<JS::Value> vp)
{
    // Get the security manager
    nsScriptSecurityManager *ssm =
        nsScriptSecurityManager::GetScriptSecurityManager();

    NS_WARN_IF_FALSE(ssm, "Failed to get security manager service");
    if (!ssm)
        return false;

    // Get the object being accessed.  We protect these cases:
    // 1. The Function.prototype.caller property's value, which might lead
    //    an attacker up a call-stack to a function or another object from
    //    a different trust domain.
    // 2. A user-defined getter or setter function accessible on another
    //    trust domain's window or document object.
    // vp can be a primitive, in that case, we use obj as the target
    // object.
    JSObject* target = JSVAL_IS_PRIMITIVE(vp) ? obj : JSVAL_TO_OBJECT(vp);

    // Do the same-origin check -- this sets a JS exception if the check fails.
    // Pass the parent object's class name, as we have no class-info for it.
    nsresult rv =
        ssm->CheckPropertyAccess(cx, target, js::GetObjectClass(obj)->name, id,
                                 (mode & JSACC_WRITE) ?
                                 (int32_t)nsIXPCSecurityManager::ACCESS_SET_PROPERTY :
                                 (int32_t)nsIXPCSecurityManager::ACCESS_GET_PROPERTY);

    if (NS_FAILED(rv))
        return false; // Security check failed (XXX was an error reported?)

    return true;
}

NS_IMETHODIMP
nsScriptSecurityManager::CheckPropertyAccess(JSContext* cx,
                                             JSObject* aJSObject,
                                             const char* aClassName,
                                             jsid aProperty,
                                             uint32_t aAction)
{
    return CheckPropertyAccessImpl(aAction, nullptr, cx, aJSObject,
                                   nullptr, nullptr,
                                   aClassName, aProperty, nullptr);
}

NS_IMETHODIMP
nsScriptSecurityManager::CheckSameOrigin(JSContext* cx,
                                         nsIURI* aTargetURI)
{
    nsresult rv;

    // Get a context if necessary
    if (!cx)
    {
        cx = GetCurrentJSContext();
        if (!cx)
            return NS_OK; // No JS context, so allow access
    }

    // Get a principal from the context
    nsIPrincipal* sourcePrincipal = GetSubjectPrincipal(cx, &rv);
    if (NS_FAILED(rv))
        return rv;

    if (!sourcePrincipal)
    {
        NS_WARNING("CheckSameOrigin called on script w/o principals; should this happen?");
        return NS_OK;
    }

    if (sourcePrincipal == mSystemPrincipal)
    {
        // This is a system (chrome) script, so allow access
        return NS_OK;
    }

    // Get the original URI from the source principal.
    // This has the effect of ignoring any change to document.domain
    // which must be done to avoid DNS spoofing (bug 154930)
    nsCOMPtr<nsIURI> sourceURI;
    sourcePrincipal->GetDomain(getter_AddRefs(sourceURI));
    if (!sourceURI) {
      sourcePrincipal->GetURI(getter_AddRefs(sourceURI));
      NS_ENSURE_TRUE(sourceURI, NS_ERROR_FAILURE);
    }

    // Compare origins
    if (!SecurityCompareURIs(sourceURI, aTargetURI))
    {
         ReportError(cx, NS_LITERAL_STRING("CheckSameOriginError"), sourceURI, aTargetURI);
         return NS_ERROR_DOM_BAD_URI;
    }
    return NS_OK;
}

NS_IMETHODIMP
nsScriptSecurityManager::CheckSameOriginURI(nsIURI* aSourceURI,
                                            nsIURI* aTargetURI,
                                            bool reportError)
{
    if (!SecurityCompareURIs(aSourceURI, aTargetURI))
    {
         if (reportError) {
            ReportError(nullptr, NS_LITERAL_STRING("CheckSameOriginError"),
                     aSourceURI, aTargetURI);
         }
         return NS_ERROR_DOM_BAD_URI;
    }
    return NS_OK;
}

nsresult
nsScriptSecurityManager::CheckPropertyAccessImpl(uint32_t aAction,
                                                 nsAXPCNativeCallContext* aCallContext,
                                                 JSContext* cx, JSObject* aJSObject,
                                                 nsISupports* aObj,
                                                 nsIClassInfo* aClassInfo,
                                                 const char* aClassName, jsid aProperty,
                                                 void** aCachedClassPolicy)
{
    nsresult rv;
    JS::RootedObject jsObject(cx, aJSObject);
    JS::RootedId property(cx, aProperty);
    nsIPrincipal* subjectPrincipal = GetSubjectPrincipal(cx, &rv);
    if (NS_FAILED(rv))
        return rv;

    if (!subjectPrincipal || subjectPrincipal == mSystemPrincipal)
        // We have native code or the system principal: just allow access
        return NS_OK;

    nsCOMPtr<nsIPrincipal> objectPrincipal;

    // Hold the class info data here so we don't have to go back to virtual
    // methods all the time
    ClassInfoData classInfoData(aClassInfo, aClassName);

    //-- Look up the security policy for this class and subject domain
    SecurityLevel securityLevel;
    rv = LookupPolicy(subjectPrincipal, classInfoData, property, aAction,
                      (ClassPolicy**)aCachedClassPolicy, &securityLevel);
    if (NS_FAILED(rv))
        return rv;

    if (securityLevel.level == SCRIPT_SECURITY_UNDEFINED_ACCESS)
    {
        // No policy found for this property so use the default of last resort.
        // If we were called from somewhere other than XPConnect
        // (no XPC call context), assume this is a DOM class. Otherwise,
        // ask the ClassInfo.
        if (!aCallContext || classInfoData.IsDOMClass())
            securityLevel.level = SCRIPT_SECURITY_SAME_ORIGIN_ACCESS;
        else
            securityLevel.level = SCRIPT_SECURITY_NO_ACCESS;
    }

    if (SECURITY_ACCESS_LEVEL_FLAG(securityLevel))
    // This flag means securityLevel is allAccess, noAccess, or sameOrigin
    {
        switch (securityLevel.level)
        {
        case SCRIPT_SECURITY_NO_ACCESS:
            rv = NS_ERROR_DOM_PROP_ACCESS_DENIED;
            break;

        case SCRIPT_SECURITY_ALL_ACCESS:
            rv = NS_OK;
            break;

        case SCRIPT_SECURITY_SAME_ORIGIN_ACCESS:
            {
                nsCOMPtr<nsIPrincipal> principalHolder;
                if (jsObject)
                {
                    objectPrincipal = doGetObjectPrincipal(jsObject);
                    if (!objectPrincipal)
                        rv = NS_ERROR_DOM_SECURITY_ERR;
                }
                else
                {
                    NS_ERROR("CheckPropertyAccessImpl called without a target object or URL");
                    return NS_ERROR_FAILURE;
                }
                if(NS_SUCCEEDED(rv))
                    rv = CheckSameOriginDOMProp(subjectPrincipal, objectPrincipal,
                                                aAction);
                break;
            }
        default:
            NS_ERROR("Bad Security Level Value");
            return NS_ERROR_FAILURE;
        }
    }
    else // if SECURITY_ACCESS_LEVEL_FLAG is false, securityLevel is a capability
    {
        rv = SubjectIsPrivileged() ? NS_OK : NS_ERROR_DOM_SECURITY_ERR;
    }

    if (NS_SUCCEEDED(rv))
    {
        return rv;
    }

    //--See if the object advertises a non-default level of access
    //  using nsISecurityCheckedComponent
    nsCOMPtr<nsISecurityCheckedComponent> checkedComponent =
        do_QueryInterface(aObj);

    nsXPIDLCString objectSecurityLevel;
    if (checkedComponent)
    {
        nsCOMPtr<nsIXPConnectWrappedNative> wrapper;
        nsCOMPtr<nsIInterfaceInfo> interfaceInfo;
        const nsIID* objIID = nullptr;
        rv = aCallContext->GetCalleeWrapper(getter_AddRefs(wrapper));
        if (NS_SUCCEEDED(rv) && wrapper)
            rv = wrapper->FindInterfaceWithMember(property, getter_AddRefs(interfaceInfo));
        if (NS_SUCCEEDED(rv) && interfaceInfo)
            rv = interfaceInfo->GetIIDShared(&objIID);
        if (NS_SUCCEEDED(rv) && objIID)
        {
            switch (aAction)
            {
            case nsIXPCSecurityManager::ACCESS_GET_PROPERTY:
                checkedComponent->CanGetProperty(objIID,
                                                 IDToString(cx, property),
                                                 getter_Copies(objectSecurityLevel));
                break;
            case nsIXPCSecurityManager::ACCESS_SET_PROPERTY:
                checkedComponent->CanSetProperty(objIID,
                                                 IDToString(cx, property),
                                                 getter_Copies(objectSecurityLevel));
                break;
            case nsIXPCSecurityManager::ACCESS_CALL_METHOD:
                checkedComponent->CanCallMethod(objIID,
                                                IDToString(cx, property),
                                                getter_Copies(objectSecurityLevel));
            }
        }
    }
    rv = CheckXPCPermissions(cx, aObj, jsObject, subjectPrincipal,
                             objectSecurityLevel);

    if (NS_FAILED(rv)) //-- Security tests failed, access is denied, report error
    {
        nsAutoString stringName;
        switch(aAction)
        {
        case nsIXPCSecurityManager::ACCESS_GET_PROPERTY:
            stringName.AssignLiteral("GetPropertyDeniedOrigins");
            break;
        case nsIXPCSecurityManager::ACCESS_SET_PROPERTY:
            stringName.AssignLiteral("SetPropertyDeniedOrigins");
            break;
        case nsIXPCSecurityManager::ACCESS_CALL_METHOD:
            stringName.AssignLiteral("CallMethodDeniedOrigins");
        }

        // Null out objectPrincipal for now, so we don't leak information about
        // it.  Whenever we can report different error strings to content and
        // the UI we can take this out again.
        objectPrincipal = nullptr;

        NS_ConvertUTF8toUTF16 className(classInfoData.GetName());
        nsAutoCString subjectOrigin;
        nsAutoCString subjectDomain;
        if (!nsAutoInPrincipalDomainOriginSetter::sInPrincipalDomainOrigin) {
            nsCOMPtr<nsIURI> uri, domain;
            subjectPrincipal->GetURI(getter_AddRefs(uri));
            if (uri) { // Object principal might be expanded
                GetOriginFromURI(uri, subjectOrigin);
            }
            subjectPrincipal->GetDomain(getter_AddRefs(domain));
            if (domain) {
                GetOriginFromURI(domain, subjectDomain);
            }
        } else {
            subjectOrigin.AssignLiteral("the security manager");
        }
        NS_ConvertUTF8toUTF16 subjectOriginUnicode(subjectOrigin);
        NS_ConvertUTF8toUTF16 subjectDomainUnicode(subjectDomain);

        nsAutoCString objectOrigin;
        nsAutoCString objectDomain;
        if (!nsAutoInPrincipalDomainOriginSetter::sInPrincipalDomainOrigin &&
            objectPrincipal) {
            nsCOMPtr<nsIURI> uri, domain;
            objectPrincipal->GetURI(getter_AddRefs(uri));
            if (uri) { // Object principal might be system
                GetOriginFromURI(uri, objectOrigin);
            }
            objectPrincipal->GetDomain(getter_AddRefs(domain));
            if (domain) {
                GetOriginFromURI(domain, objectDomain);
            }
        }
        NS_ConvertUTF8toUTF16 objectOriginUnicode(objectOrigin);
        NS_ConvertUTF8toUTF16 objectDomainUnicode(objectDomain);

        nsXPIDLString errorMsg;
        const PRUnichar *formatStrings[] =
        {
            subjectOriginUnicode.get(),
            className.get(),
            IDToString(cx, property),
            objectOriginUnicode.get(),
            subjectDomainUnicode.get(),
            objectDomainUnicode.get()
        };

        uint32_t length = ArrayLength(formatStrings);

        // XXXbz Our localization system is stupid and can't handle not showing
        // some strings that get passed in.  Which means that we have to get
        // our length precisely right: it has to be exactly the number of
        // strings our format string wants.  This means we'll have to move
        // strings in the array as needed, sadly...
        if (nsAutoInPrincipalDomainOriginSetter::sInPrincipalDomainOrigin ||
            !objectPrincipal) {
            stringName.AppendLiteral("OnlySubject");
            length -= 3;
        } else {
            // default to a length that doesn't include the domains, then
            // increase it as needed.
            length -= 2;
            if (!subjectDomainUnicode.IsEmpty()) {
                stringName.AppendLiteral("SubjectDomain");
                length += 1;
            }
            if (!objectDomainUnicode.IsEmpty()) {
                stringName.AppendLiteral("ObjectDomain");
                length += 1;
                if (length != ArrayLength(formatStrings)) {
                    // We have an object domain but not a subject domain.
                    // Scoot our string over one slot.  See the XXX comment
                    // above for why we need to do this.
                    formatStrings[length-1] = formatStrings[length];
                }
            }
        }
        
        // We need to keep our existing failure rv and not override it
        // with a likely success code from the following string bundle
        // call in order to throw the correct security exception later.
        nsresult rv2 = sStrBundle->FormatStringFromName(stringName.get(),
                                                        formatStrings,
                                                        length,
                                                        getter_Copies(errorMsg));
        if (NS_FAILED(rv2)) {
            // Might just be missing the string...  Do our best
            errorMsg = stringName;
        }

        SetPendingException(cx, errorMsg.get());
    }

    return rv;
}

/* static */
nsresult
nsScriptSecurityManager::CheckSameOriginPrincipal(nsIPrincipal* aSubject,
                                                  nsIPrincipal* aObject)
{
    /*
    ** Get origin of subject and object and compare.
    */
    if (aSubject == aObject)
        return NS_OK;

    if (!AppAttributesEqual(aSubject, aObject)) {
        return NS_ERROR_DOM_PROP_ACCESS_DENIED;
    }

    // Default to false, and change if that turns out wrong.
    bool subjectSetDomain = false;
    bool objectSetDomain = false;
    
    nsCOMPtr<nsIURI> subjectURI;
    nsCOMPtr<nsIURI> objectURI;

    aSubject->GetDomain(getter_AddRefs(subjectURI));
    if (!subjectURI) {
        aSubject->GetURI(getter_AddRefs(subjectURI));
    } else {
        subjectSetDomain = true;
    }

    aObject->GetDomain(getter_AddRefs(objectURI));
    if (!objectURI) {
        aObject->GetURI(getter_AddRefs(objectURI));
    } else {
        objectSetDomain = true;
    }

    if (SecurityCompareURIs(subjectURI, objectURI))
    {   // If either the subject or the object has changed its principal by
        // explicitly setting document.domain then the other must also have
        // done so in order to be considered the same origin. This prevents
        // DNS spoofing based on document.domain (154930)

        // If both or neither explicitly set their domain, allow the access
        if (subjectSetDomain == objectSetDomain)
            return NS_OK;
    }

    /*
    ** Access tests failed, so now report error.
    */
    return NS_ERROR_DOM_PROP_ACCESS_DENIED;
}

// It's important that
//
//   CheckSameOriginPrincipal(A, B) == NS_OK
//
// imply
//
//   HashPrincipalByOrigin(A) == HashPrincipalByOrigin(B)
//
// if principals A and B could ever be used as keys in a hashtable.
// Violation of this invariant leads to spurious failures of hashtable
// lookups.  See bug 454850.

/*static*/ uint32_t
nsScriptSecurityManager::HashPrincipalByOrigin(nsIPrincipal* aPrincipal)
{
    nsCOMPtr<nsIURI> uri;
    aPrincipal->GetDomain(getter_AddRefs(uri));
    if (!uri)
        aPrincipal->GetURI(getter_AddRefs(uri));
    return SecurityHashURI(uri);
}

/* static */ bool
nsScriptSecurityManager::AppAttributesEqual(nsIPrincipal* aFirst,
                                            nsIPrincipal* aSecond)
{
    MOZ_ASSERT(aFirst && aSecond, "Don't pass null pointers!");

    uint32_t firstAppId = nsIScriptSecurityManager::UNKNOWN_APP_ID;
    if (!aFirst->GetUnknownAppId()) {
        firstAppId = aFirst->GetAppId();
    }

    uint32_t secondAppId = nsIScriptSecurityManager::UNKNOWN_APP_ID;
    if (!aSecond->GetUnknownAppId()) {
        secondAppId = aSecond->GetAppId();
    }

    return ((firstAppId == secondAppId) &&
            (aFirst->GetIsInBrowserElement() == aSecond->GetIsInBrowserElement()));
}

nsresult
nsScriptSecurityManager::CheckSameOriginDOMProp(nsIPrincipal* aSubject,
                                                nsIPrincipal* aObject,
                                                uint32_t aAction)
{
    nsresult rv;
    bool subsumes;
    rv = aSubject->Subsumes(aObject, &subsumes);
    if (NS_SUCCEEDED(rv) && !subsumes) {
        rv = NS_ERROR_DOM_PROP_ACCESS_DENIED;
    }
    
    if (NS_SUCCEEDED(rv))
        return NS_OK;

    /*
    * Content can't ever touch chrome (we check for UniversalXPConnect later)
    */
    if (aObject == mSystemPrincipal)
        return NS_ERROR_DOM_PROP_ACCESS_DENIED;

    /*
    ** Access tests failed, so now report error.
    */
    return NS_ERROR_DOM_PROP_ACCESS_DENIED;
}

nsresult
nsScriptSecurityManager::LookupPolicy(nsIPrincipal* aPrincipal,
                                      ClassInfoData& aClassData,
                                      JS::Handle<jsid> aProperty,
                                      uint32_t aAction,
                                      ClassPolicy** aCachedClassPolicy,
                                      SecurityLevel* result)
{
    AutoJSContext cx;
    nsresult rv;
    JS::RootedId property(cx, aProperty);
    result->level = SCRIPT_SECURITY_UNDEFINED_ACCESS;

    DomainPolicy* dpolicy = nullptr;
    //-- Initialize policies if necessary
    if (mPolicyPrefsChanged)
    {
        if (!mPrefInitialized) {
            rv = InitPrefs();
            NS_ENSURE_SUCCESS(rv, rv);
        }
        rv = InitPolicies();
        if (NS_FAILED(rv))
            return rv;
    }
    else
    {
        aPrincipal->GetSecurityPolicy((void**)&dpolicy);
    }

    if (!dpolicy && mOriginToPolicyMap)
    {
        //-- Look up the relevant domain policy, if any
        if (nsCOMPtr<nsIExpandedPrincipal> exp = do_QueryInterface(aPrincipal)) 
        {
            // For expanded principals domain origin is not defined so let's just
            // use the default policy
            dpolicy = mDefaultPolicy;
        }
        else
        {
            nsAutoCString origin;
            rv = GetPrincipalDomainOrigin(aPrincipal, origin);
            NS_ENSURE_SUCCESS(rv, rv);
 
            char *start = origin.BeginWriting();
            const char *nextToLastDot = nullptr;
            const char *lastDot = nullptr;
            const char *colon = nullptr;
            char *p = start;

            //-- search domain (stop at the end of the string or at the 3rd slash)
            for (uint32_t slashes=0; *p; p++)
            {
                if (*p == '/' && ++slashes == 3) 
                {
                    *p = '\0'; // truncate at 3rd slash
                    break;
                }
                if (*p == '.')
                {
                    nextToLastDot = lastDot;
                    lastDot = p;
                } 
                else if (!colon && *p == ':')
                    colon = p;
            }

            nsCStringKey key(nextToLastDot ? nextToLastDot+1 : start);
            DomainEntry *de = (DomainEntry*) mOriginToPolicyMap->Get(&key);
            if (!de)
            {
                nsAutoCString scheme(start, colon-start+1);
                nsCStringKey schemeKey(scheme);
                de = (DomainEntry*) mOriginToPolicyMap->Get(&schemeKey);
            }

            while (de)
            {
                if (de->Matches(start))
                {
                    dpolicy = de->mDomainPolicy;
                    break;
                }
                de = de->mNext;
            }

            if (!dpolicy)
                dpolicy = mDefaultPolicy;
        }

        aPrincipal->SetSecurityPolicy((void*)dpolicy);
    }

    ClassPolicy* cpolicy = nullptr;

    if ((dpolicy == mDefaultPolicy) && aCachedClassPolicy)
    {
        // No per-domain policy for this principal (the more common case)
        // so look for a cached class policy from the object wrapper
        cpolicy = *aCachedClassPolicy;
    }

    if (!cpolicy)
    { //-- No cached policy for this class, need to look it up
        cpolicy = static_cast<ClassPolicy*>
                             (PL_DHashTableOperate(dpolicy,
                                                      aClassData.GetName(),
                                                      PL_DHASH_LOOKUP));

        if (PL_DHASH_ENTRY_IS_FREE(cpolicy))
            cpolicy = NO_POLICY_FOR_CLASS;

        if ((dpolicy == mDefaultPolicy) && aCachedClassPolicy)
            *aCachedClassPolicy = cpolicy;
    }

    NS_ASSERTION(JSID_IS_INT(property) || JSID_IS_OBJECT(property) ||
                 JSID_IS_STRING(property), "Property must be a valid id");

    // Only atomized strings are stored in the policies' hash tables.
    if (!JSID_IS_STRING(property))
        return NS_OK;

    JS::RootedString propertyKey(cx, JSID_TO_STRING(property));

    // We look for a PropertyPolicy in the following places:
    // 1)  The ClassPolicy for our class we got from our DomainPolicy
    // 2)  The mWildcardPolicy of our DomainPolicy
    // 3)  The ClassPolicy for our class we got from mDefaultPolicy
    // 4)  The mWildcardPolicy of our mDefaultPolicy
    PropertyPolicy* ppolicy = nullptr;
    if (cpolicy != NO_POLICY_FOR_CLASS)
    {
        ppolicy = static_cast<PropertyPolicy*>
                             (PL_DHashTableOperate(cpolicy->mPolicy,
                                                      propertyKey,
                                                      PL_DHASH_LOOKUP));
    }

    // If there is no class policy for this property, and we have a wildcard
    // policy, try that.
    if (dpolicy->mWildcardPolicy &&
        (!ppolicy || PL_DHASH_ENTRY_IS_FREE(ppolicy)))
    {
        ppolicy =
            static_cast<PropertyPolicy*>
                       (PL_DHashTableOperate(dpolicy->mWildcardPolicy->mPolicy,
                                                propertyKey,
                                                PL_DHASH_LOOKUP));
    }

    // If dpolicy is not the defauly policy and there's no class or wildcard
    // policy for this property, check the default policy for this class and
    // the default wildcard policy
    if (dpolicy != mDefaultPolicy &&
        (!ppolicy || PL_DHASH_ENTRY_IS_FREE(ppolicy)))
    {
        cpolicy = static_cast<ClassPolicy*>
                             (PL_DHashTableOperate(mDefaultPolicy,
                                                      aClassData.GetName(),
                                                      PL_DHASH_LOOKUP));

        if (PL_DHASH_ENTRY_IS_BUSY(cpolicy))
        {
            ppolicy =
                static_cast<PropertyPolicy*>
                           (PL_DHashTableOperate(cpolicy->mPolicy,
                                                    propertyKey,
                                                    PL_DHASH_LOOKUP));
        }

        if ((!ppolicy || PL_DHASH_ENTRY_IS_FREE(ppolicy)) &&
            mDefaultPolicy->mWildcardPolicy)
        {
            ppolicy =
              static_cast<PropertyPolicy*>
                         (PL_DHashTableOperate(mDefaultPolicy->mWildcardPolicy->mPolicy,
                                                  propertyKey,
                                                  PL_DHASH_LOOKUP));
        }
    }

    if (!ppolicy || PL_DHASH_ENTRY_IS_FREE(ppolicy))
        return NS_OK;

    // Get the correct security level from the property policy
    if (aAction == nsIXPCSecurityManager::ACCESS_SET_PROPERTY)
        *result = ppolicy->mSet;
    else
        *result = ppolicy->mGet;

    return NS_OK;
}


NS_IMETHODIMP
nsScriptSecurityManager::CheckLoadURIFromScript(JSContext *cx, nsIURI *aURI)
{
    // Get principal of currently executing script.
    nsresult rv;
    nsIPrincipal* principal = GetSubjectPrincipal(cx, &rv);
    if (NS_FAILED(rv))
        return rv;

    // Native code can load all URIs.
    if (!principal)
        return NS_OK;

    rv = CheckLoadURIWithPrincipal(principal, aURI,
                                   nsIScriptSecurityManager::STANDARD);
    if (NS_SUCCEEDED(rv)) {
        // OK to load
        return NS_OK;
    }

    // See if we're attempting to load a file: URI. If so, let a
    // UniversalXPConnect capability trump the above check.
    bool isFile = false;
    bool isRes = false;
    if (NS_FAILED(aURI->SchemeIs("file", &isFile)) ||
        NS_FAILED(aURI->SchemeIs("resource", &isRes)))
        return NS_ERROR_FAILURE;
    if (isFile || isRes)
    {
        if (SubjectIsPrivileged())
            return NS_OK;
    }

    // Report error.
    nsAutoCString spec;
    if (NS_FAILED(aURI->GetAsciiSpec(spec)))
        return NS_ERROR_FAILURE;
    nsAutoCString msg("Access to '");
    msg.Append(spec);
    msg.AppendLiteral("' from script denied");
    SetPendingException(cx, msg.get());
    return NS_ERROR_DOM_BAD_URI;
}

/**
 * Helper method to handle cases where a flag passed to
 * CheckLoadURIWithPrincipal means denying loading if the given URI has certain
 * nsIProtocolHandler flags set.
 * @return if success, access is allowed. Otherwise, deny access
 */
static nsresult
DenyAccessIfURIHasFlags(nsIURI* aURI, uint32_t aURIFlags)
{
    NS_PRECONDITION(aURI, "Must have URI!");
    
    bool uriHasFlags;
    nsresult rv =
        NS_URIChainHasFlags(aURI, aURIFlags, &uriHasFlags);
    NS_ENSURE_SUCCESS(rv, rv);

    if (uriHasFlags) {
        return NS_ERROR_DOM_BAD_URI;
    }

    return NS_OK;
}

NS_IMETHODIMP
nsScriptSecurityManager::CheckLoadURIWithPrincipal(nsIPrincipal* aPrincipal,
                                                   nsIURI *aTargetURI,
                                                   uint32_t aFlags)
{
    NS_PRECONDITION(aPrincipal, "CheckLoadURIWithPrincipal must have a principal");
    // If someone passes a flag that we don't understand, we should
    // fail, because they may need a security check that we don't
    // provide.
    NS_ENSURE_FALSE(aFlags & ~(nsIScriptSecurityManager::LOAD_IS_AUTOMATIC_DOCUMENT_REPLACEMENT |
                               nsIScriptSecurityManager::ALLOW_CHROME |
                               nsIScriptSecurityManager::DISALLOW_SCRIPT |
                               nsIScriptSecurityManager::DISALLOW_INHERIT_PRINCIPAL |
                               nsIScriptSecurityManager::DONT_REPORT_ERRORS),
                    NS_ERROR_UNEXPECTED);
    NS_ENSURE_ARG_POINTER(aPrincipal);
    NS_ENSURE_ARG_POINTER(aTargetURI);

    // If DISALLOW_INHERIT_PRINCIPAL is set, we prevent loading of URIs which
    // would do such inheriting. That would be URIs that do not have their own
    // security context. We do this even for the system principal.
    if (aFlags & nsIScriptSecurityManager::DISALLOW_INHERIT_PRINCIPAL) {
        nsresult rv =
            DenyAccessIfURIHasFlags(aTargetURI,
                                    nsIProtocolHandler::URI_INHERITS_SECURITY_CONTEXT);
        NS_ENSURE_SUCCESS(rv, rv);
    }

    if (aPrincipal == mSystemPrincipal) {
        // Allow access
        return NS_OK;
    }

    nsCOMPtr<nsIURI> sourceURI;
    aPrincipal->GetURI(getter_AddRefs(sourceURI));
    if (!sourceURI) {
        nsCOMPtr<nsIExpandedPrincipal> expanded = do_QueryInterface(aPrincipal);
        if (expanded) {
            nsTArray< nsCOMPtr<nsIPrincipal> > *whiteList;
            expanded->GetWhiteList(&whiteList);
            for (uint32_t i = 0; i < whiteList->Length(); ++i) {
                nsresult rv = CheckLoadURIWithPrincipal((*whiteList)[i],
                                                        aTargetURI,
                                                        aFlags);
                if (NS_SUCCEEDED(rv)) {
                    // Allow access if it succeeded with one of the white listed principals
                    return NS_OK;
                }
            }
            // None of our whitelisted principals worked.
            return NS_ERROR_DOM_BAD_URI;
        }
        NS_ERROR("Non-system principals or expanded principal passed to CheckLoadURIWithPrincipal "
                 "must have a URI!");
        return NS_ERROR_UNEXPECTED;
    }
    
    // Automatic loads are not allowed from certain protocols.
    if (aFlags & nsIScriptSecurityManager::LOAD_IS_AUTOMATIC_DOCUMENT_REPLACEMENT) {
        nsresult rv =
            DenyAccessIfURIHasFlags(sourceURI,
                                    nsIProtocolHandler::URI_FORBIDS_AUTOMATIC_DOCUMENT_REPLACEMENT);
        NS_ENSURE_SUCCESS(rv, rv);
    }

    // If either URI is a nested URI, get the base URI
    nsCOMPtr<nsIURI> sourceBaseURI = NS_GetInnermostURI(sourceURI);
    nsCOMPtr<nsIURI> targetBaseURI = NS_GetInnermostURI(aTargetURI);

    //-- get the target scheme
    nsAutoCString targetScheme;
    nsresult rv = targetBaseURI->GetScheme(targetScheme);
    if (NS_FAILED(rv)) return rv;

    //-- Some callers do not allow loading javascript:
    if ((aFlags & nsIScriptSecurityManager::DISALLOW_SCRIPT) &&
         targetScheme.EqualsLiteral("javascript"))
    {
       return NS_ERROR_DOM_BAD_URI;
    }

    NS_NAMED_LITERAL_STRING(errorTag, "CheckLoadURIError");
    bool reportErrors = !(aFlags & nsIScriptSecurityManager::DONT_REPORT_ERRORS);

    // Check for uris that are only loadable by principals that subsume them
    bool hasFlags;
    rv = NS_URIChainHasFlags(targetBaseURI,
                             nsIProtocolHandler::URI_LOADABLE_BY_SUBSUMERS,
                             &hasFlags);
    NS_ENSURE_SUCCESS(rv, rv);

    if (hasFlags) {
        return aPrincipal->CheckMayLoad(targetBaseURI, true, false);
    }

    //-- get the source scheme
    nsAutoCString sourceScheme;
    rv = sourceBaseURI->GetScheme(sourceScheme);
    if (NS_FAILED(rv)) return rv;

    if (sourceScheme.LowerCaseEqualsLiteral(NS_NULLPRINCIPAL_SCHEME)) {
        // A null principal can target its own URI.
        if (sourceURI == aTargetURI) {
            return NS_OK;
        }
    }
    else if (targetScheme.Equals(sourceScheme,
                                 nsCaseInsensitiveCStringComparator()))
    {
        // every scheme can access another URI from the same scheme,
        // as long as they don't represent null principals...
        // Or they don't require an special permission to do so
        // See bug#773886

        bool hasFlags;
        rv = NS_URIChainHasFlags(targetBaseURI,
                                 nsIProtocolHandler::URI_CROSS_ORIGIN_NEEDS_WEBAPPS_PERM,
                                 &hasFlags);
        NS_ENSURE_SUCCESS(rv, rv);

        if (hasFlags) {
            // In this case, we allow opening only if the source and target URIS
            // are on the same domain, or the opening URI has the webapps
            // permision granted
            if (!SecurityCompareURIs(sourceBaseURI,targetBaseURI) &&
                !nsContentUtils::IsExactSitePermAllow(aPrincipal,WEBAPPS_PERM_NAME)){
                return NS_ERROR_DOM_BAD_URI;
            }
        }
        return NS_OK;
    }

    // If the schemes don't match, the policy is specified by the protocol
    // flags on the target URI.  Note that the order of policy checks here is
    // very important!  We start from most restrictive and work our way down.
    // Note that since we're working with the innermost URI, we can just use
    // the methods that work on chains of nested URIs and they will only look
    // at the flags for our one URI.

    // Check for system target URI
    rv = DenyAccessIfURIHasFlags(targetBaseURI,
                                 nsIProtocolHandler::URI_DANGEROUS_TO_LOAD);
    if (NS_FAILED(rv)) {
        // Deny access, since the origin principal is not system
        if (reportErrors) {
            ReportError(nullptr, errorTag, sourceURI, aTargetURI);
        }
        return rv;
    }

    // Check for chrome target URI
    rv = NS_URIChainHasFlags(targetBaseURI,
                             nsIProtocolHandler::URI_IS_UI_RESOURCE,
                             &hasFlags);
    NS_ENSURE_SUCCESS(rv, rv);
    if (hasFlags) {
        if (aFlags & nsIScriptSecurityManager::ALLOW_CHROME) {
            if (!targetScheme.EqualsLiteral("chrome")) {
                // for now don't change behavior for resource: or moz-icon:
                return NS_OK;
            }

            // allow load only if chrome package is whitelisted
            nsCOMPtr<nsIXULChromeRegistry> reg(do_GetService(
                                                 NS_CHROMEREGISTRY_CONTRACTID));
            if (reg) {
                bool accessAllowed = false;
                reg->AllowContentToAccess(targetBaseURI, &accessAllowed);
                if (accessAllowed) {
                    return NS_OK;
                }
            }
        }

        // resource: and chrome: are equivalent, securitywise
        // That's bogus!!  Fix this.  But watch out for
        // the view-source stylesheet?
        bool sourceIsChrome;
        rv = NS_URIChainHasFlags(sourceBaseURI,
                                 nsIProtocolHandler::URI_IS_UI_RESOURCE,
                                 &sourceIsChrome);
        NS_ENSURE_SUCCESS(rv, rv);
        if (sourceIsChrome) {
            return NS_OK;
        }
        if (reportErrors) {
            ReportError(nullptr, errorTag, sourceURI, aTargetURI);
        }
        return NS_ERROR_DOM_BAD_URI;
    }

    // Check for target URI pointing to a file
    rv = NS_URIChainHasFlags(targetBaseURI,
                             nsIProtocolHandler::URI_IS_LOCAL_FILE,
                             &hasFlags);
    NS_ENSURE_SUCCESS(rv, rv);
    if (hasFlags) {
        // resource: and chrome: are equivalent, securitywise
        // That's bogus!!  Fix this.  But watch out for
        // the view-source stylesheet?
        bool sourceIsChrome;
        rv = NS_URIChainHasFlags(sourceURI,
                                 nsIProtocolHandler::URI_IS_UI_RESOURCE,
                                 &sourceIsChrome);
        NS_ENSURE_SUCCESS(rv, rv);
        if (sourceIsChrome) {
            return NS_OK;
        }

        // Now check capability policies
        static const char loadURIPrefGroup[] = "checkloaduri";
        ClassInfoData nameData(nullptr, loadURIPrefGroup);

        SecurityLevel secLevel;
        rv = LookupPolicy(aPrincipal, nameData, EnabledID(),
                          nsIXPCSecurityManager::ACCESS_GET_PROPERTY,
                          nullptr, &secLevel);
        if (NS_SUCCEEDED(rv) && secLevel.level == SCRIPT_SECURITY_ALL_ACCESS)
        {
            // OK for this site!
            return NS_OK;
        }

        if (reportErrors) {
            ReportError(nullptr, errorTag, sourceURI, aTargetURI);
        }
        return NS_ERROR_DOM_BAD_URI;
    }

    // OK, everyone is allowed to load this, since unflagged handlers are
    // deprecated but treated as URI_LOADABLE_BY_ANYONE.  But check whether we
    // need to warn.  At some point we'll want to make this warning into an
    // error and treat unflagged handlers as URI_DANGEROUS_TO_LOAD.
    rv = NS_URIChainHasFlags(targetBaseURI,
                             nsIProtocolHandler::URI_LOADABLE_BY_ANYONE,
                             &hasFlags);
    NS_ENSURE_SUCCESS(rv, rv);
    if (!hasFlags) {
        nsXPIDLString message;
        NS_ConvertASCIItoUTF16 ucsTargetScheme(targetScheme);
        const PRUnichar* formatStrings[] = { ucsTargetScheme.get() };
        rv = sStrBundle->
            FormatStringFromName(NS_LITERAL_STRING("ProtocolFlagError").get(),
                                 formatStrings,
                                 ArrayLength(formatStrings),
                                 getter_Copies(message));
        if (NS_SUCCEEDED(rv)) {
            nsCOMPtr<nsIConsoleService> console(
              do_GetService("@mozilla.org/consoleservice;1"));
            NS_ENSURE_TRUE(console, NS_ERROR_FAILURE);

            console->LogStringMessage(message.get());
        }
    }
    
    return NS_OK;
}

nsresult
nsScriptSecurityManager::ReportError(JSContext* cx, const nsAString& messageTag,
                                     nsIURI* aSource, nsIURI* aTarget)
{
    nsresult rv;
    NS_ENSURE_TRUE(aSource && aTarget, NS_ERROR_NULL_POINTER);

    // Get the source URL spec
    nsAutoCString sourceSpec;
    rv = aSource->GetAsciiSpec(sourceSpec);
    NS_ENSURE_SUCCESS(rv, rv);

    // Get the target URL spec
    nsAutoCString targetSpec;
    rv = aTarget->GetAsciiSpec(targetSpec);
    NS_ENSURE_SUCCESS(rv, rv);

    // Localize the error message
    nsXPIDLString message;
    NS_ConvertASCIItoUTF16 ucsSourceSpec(sourceSpec);
    NS_ConvertASCIItoUTF16 ucsTargetSpec(targetSpec);
    const PRUnichar *formatStrings[] = { ucsSourceSpec.get(), ucsTargetSpec.get() };
    rv = sStrBundle->FormatStringFromName(PromiseFlatString(messageTag).get(),
                                          formatStrings,
                                          ArrayLength(formatStrings),
                                          getter_Copies(message));
    NS_ENSURE_SUCCESS(rv, rv);

    // If a JS context was passed in, set a JS exception.
    // Otherwise, print the error message directly to the JS console
    // and to standard output
    if (cx)
    {
        SetPendingException(cx, message.get());
    }
    else // Print directly to the console
    {
        nsCOMPtr<nsIConsoleService> console(
            do_GetService("@mozilla.org/consoleservice;1"));
        NS_ENSURE_TRUE(console, NS_ERROR_FAILURE);

        console->LogStringMessage(message.get());
    }
    return NS_OK;
}

NS_IMETHODIMP
nsScriptSecurityManager::CheckLoadURIStrWithPrincipal(nsIPrincipal* aPrincipal,
                                                      const nsACString& aTargetURIStr,
                                                      uint32_t aFlags)
{
    nsresult rv;
    nsCOMPtr<nsIURI> target;
    rv = NS_NewURI(getter_AddRefs(target), aTargetURIStr,
                   nullptr, nullptr, sIOService);
    NS_ENSURE_SUCCESS(rv, rv);

    rv = CheckLoadURIWithPrincipal(aPrincipal, target, aFlags);
    if (rv == NS_ERROR_DOM_BAD_URI) {
        // Don't warn because NS_ERROR_DOM_BAD_URI is one of the expected
        // return values.
        return rv;
    }
    NS_ENSURE_SUCCESS(rv, rv);

    // Now start testing fixup -- since aTargetURIStr is a string, not
    // an nsIURI, we may well end up fixing it up before loading.
    // Note: This needs to stay in sync with the nsIURIFixup api.
    nsCOMPtr<nsIURIFixup> fixup = do_GetService(NS_URIFIXUP_CONTRACTID);
    if (!fixup) {
        return rv;
    }

    uint32_t flags[] = {
        nsIURIFixup::FIXUP_FLAG_NONE,
        nsIURIFixup::FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP,
        nsIURIFixup::FIXUP_FLAGS_MAKE_ALTERNATE_URI,
        nsIURIFixup::FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP |
        nsIURIFixup::FIXUP_FLAGS_MAKE_ALTERNATE_URI
    };

    for (uint32_t i = 0; i < ArrayLength(flags); ++i) {
        rv = fixup->CreateFixupURI(aTargetURIStr, flags[i], nullptr,
                                   getter_AddRefs(target));
        NS_ENSURE_SUCCESS(rv, rv);

        rv = CheckLoadURIWithPrincipal(aPrincipal, target, aFlags);
        if (rv == NS_ERROR_DOM_BAD_URI) {
            // Don't warn because NS_ERROR_DOM_BAD_URI is one of the expected
            // return values.
            return rv;
        }
        NS_ENSURE_SUCCESS(rv, rv);
    }

    return rv;
}

bool
nsScriptSecurityManager::ScriptAllowed(JSObject *aGlobal)
{
    MOZ_ASSERT(aGlobal);
    MOZ_ASSERT(JS_IsGlobalObject(aGlobal) || js::IsOuterObject(aGlobal));
    AutoJSContext cx;
    JS::RootedObject global(cx, js::UncheckedUnwrap(aGlobal, /* stopAtOuter = */ false));

    // Check the bits on the compartment private.
    xpc::Scriptability& scriptability = xpc::Scriptability::Get(aGlobal);
    if (!scriptability.Allowed()) {
        return false;
    }

    // If the compartment is immune to script policy, we're done.
    if (scriptability.IsImmuneToScriptPolicy()) {
        return true;
    }

    // Check for a per-site policy.
    static const char jsPrefGroupName[] = "javascript";
    ClassInfoData nameData(nullptr, jsPrefGroupName);
    SecurityLevel secLevel;
    nsresult rv = LookupPolicy(doGetObjectPrincipal(global), nameData,
                               EnabledID(),
                               nsIXPCSecurityManager::ACCESS_GET_PROPERTY,
                               nullptr, &secLevel);
    if (NS_FAILED(rv) || secLevel.level == SCRIPT_SECURITY_NO_ACCESS) {
        return false;
    }

    return true;
}

///////////////// Principals ///////////////////////
NS_IMETHODIMP
nsScriptSecurityManager::GetSubjectPrincipal(nsIPrincipal **aSubjectPrincipal)
{
    nsresult rv;
    *aSubjectPrincipal = doGetSubjectPrincipal(&rv);
    if (NS_SUCCEEDED(rv))
        NS_IF_ADDREF(*aSubjectPrincipal);
    return rv;
}

nsIPrincipal*
nsScriptSecurityManager::doGetSubjectPrincipal(nsresult* rv)
{
    NS_PRECONDITION(rv, "Null out param");
    JSContext *cx = GetCurrentJSContext();
    if (!cx)
    {
        *rv = NS_OK;
        return nullptr;
    }
    return GetSubjectPrincipal(cx, rv);
}

NS_IMETHODIMP
nsScriptSecurityManager::GetSystemPrincipal(nsIPrincipal **result)
{
    NS_ADDREF(*result = mSystemPrincipal);

    return NS_OK;
}

NS_IMETHODIMP
nsScriptSecurityManager::SubjectPrincipalIsSystem(bool* aIsSystem)
{
    NS_ENSURE_ARG_POINTER(aIsSystem);
    *aIsSystem = false;

    if (!mSystemPrincipal)
        return NS_OK;

    nsCOMPtr<nsIPrincipal> subject;
    nsresult rv = GetSubjectPrincipal(getter_AddRefs(subject));
    if (NS_FAILED(rv))
        return rv;

    if(!subject)
    {
        // No subject principal means no JS is running;
        // this is the equivalent of system principal code
        *aIsSystem = true;
        return NS_OK;
    }

    return mSystemPrincipal->Equals(subject, aIsSystem);
}

nsresult
nsScriptSecurityManager::CreateCodebasePrincipal(nsIURI* aURI, uint32_t aAppId,
                                                 bool aInMozBrowser,
                                                 nsIPrincipal **result)
{
    // I _think_ it's safe to not create null principals here based on aURI.
    // At least all the callers would do the right thing in those cases, as far
    // as I can tell.  --bz

    nsCOMPtr<nsIURIWithPrincipal> uriPrinc = do_QueryInterface(aURI);
    if (uriPrinc) {
        nsCOMPtr<nsIPrincipal> principal;
        uriPrinc->GetPrincipal(getter_AddRefs(principal));
        if (!principal || principal == mSystemPrincipal) {
            return CallCreateInstance(NS_NULLPRINCIPAL_CONTRACTID, result);
        }

        principal.forget(result);

        return NS_OK;
    }

    nsRefPtr<nsPrincipal> codebase = new nsPrincipal();
    if (!codebase)
        return NS_ERROR_OUT_OF_MEMORY;

    nsresult rv = codebase->Init(aURI, aAppId, aInMozBrowser);
    if (NS_FAILED(rv))
        return rv;

    NS_ADDREF(*result = codebase);

    return NS_OK;
}

NS_IMETHODIMP
nsScriptSecurityManager::GetSimpleCodebasePrincipal(nsIURI* aURI,
                                                    nsIPrincipal** aPrincipal)
{
  return GetCodebasePrincipalInternal(aURI,
                                      nsIScriptSecurityManager::UNKNOWN_APP_ID,
                                      false, aPrincipal);
}

NS_IMETHODIMP
nsScriptSecurityManager::GetNoAppCodebasePrincipal(nsIURI* aURI,
                                                   nsIPrincipal** aPrincipal)
{
  return GetCodebasePrincipalInternal(aURI,  nsIScriptSecurityManager::NO_APP_ID,
                                      false, aPrincipal);
}

NS_IMETHODIMP
nsScriptSecurityManager::GetCodebasePrincipal(nsIURI* aURI,
                                              nsIPrincipal** aPrincipal)
{
  return GetNoAppCodebasePrincipal(aURI, aPrincipal);
}

NS_IMETHODIMP
nsScriptSecurityManager::GetAppCodebasePrincipal(nsIURI* aURI,
                                                 uint32_t aAppId,
                                                 bool aInMozBrowser,
                                                 nsIPrincipal** aPrincipal)
{
  NS_ENSURE_TRUE(aAppId != nsIScriptSecurityManager::UNKNOWN_APP_ID,
                 NS_ERROR_INVALID_ARG);

  return GetCodebasePrincipalInternal(aURI, aAppId, aInMozBrowser, aPrincipal);
}

NS_IMETHODIMP
nsScriptSecurityManager::GetDocShellCodebasePrincipal(nsIURI* aURI,
                                                      nsIDocShell* aDocShell,
                                                      nsIPrincipal** aPrincipal)
{
  return GetCodebasePrincipalInternal(aURI,
                                      aDocShell->GetAppId(),
                                      aDocShell->GetIsInBrowserElement(),
                                      aPrincipal);
}

nsresult
nsScriptSecurityManager::GetCodebasePrincipalInternal(nsIURI *aURI,
                                                      uint32_t aAppId,
                                                      bool aInMozBrowser,
                                                      nsIPrincipal **result)
{
    NS_ENSURE_ARG(aURI);

    bool inheritsPrincipal;
    nsresult rv =
        NS_URIChainHasFlags(aURI,
                            nsIProtocolHandler::URI_INHERITS_SECURITY_CONTEXT,
                            &inheritsPrincipal);
    if (NS_FAILED(rv) || inheritsPrincipal) {
        return CallCreateInstance(NS_NULLPRINCIPAL_CONTRACTID, result);
    }

    nsCOMPtr<nsIPrincipal> principal;
    rv = CreateCodebasePrincipal(aURI, aAppId, aInMozBrowser,
                                 getter_AddRefs(principal));
    NS_ENSURE_SUCCESS(rv, rv);
    NS_IF_ADDREF(*result = principal);

    return NS_OK;
}

nsIPrincipal*
nsScriptSecurityManager::GetSubjectPrincipal(JSContext *cx,
                                             nsresult* rv)
{
    *rv = NS_OK;
    JSCompartment *compartment = js::GetContextCompartment(cx);

    // The context should always be in a compartment, either one it has entered
    // or the one associated with its global.
    MOZ_ASSERT(!!compartment);

    JSPrincipals *principals = JS_GetCompartmentPrincipals(compartment);
    return nsJSPrincipals::get(principals);
}

NS_IMETHODIMP
nsScriptSecurityManager::GetObjectPrincipal(JSContext *aCx, JSObject *aObj,
                                            nsIPrincipal **result)
{
    JS::Rooted<JSObject*> obj(aCx, aObj);
    *result = doGetObjectPrincipal(obj);
    if (!*result)
        return NS_ERROR_FAILURE;
    NS_ADDREF(*result);
    return NS_OK;
}

// static
nsIPrincipal*
nsScriptSecurityManager::doGetObjectPrincipal(JSObject *aObj)
{
    JSCompartment *compartment = js::GetObjectCompartment(aObj);
    JSPrincipals *principals = JS_GetCompartmentPrincipals(compartment);
    return nsJSPrincipals::get(principals);
}

////////////////////////////////////////////////
// Methods implementing nsIXPCSecurityManager //
////////////////////////////////////////////////

NS_IMETHODIMP
nsScriptSecurityManager::CanCreateWrapper(JSContext *cx,
                                          const nsIID &aIID,
                                          nsISupports *aObj,
                                          nsIClassInfo *aClassInfo,
                                          void **aPolicy)
{
// XXX Special case for nsIXPCException ?
    ClassInfoData objClassInfo = ClassInfoData(aClassInfo, nullptr);
    if (objClassInfo.IsDOMClass())
    {
        return NS_OK;
    }

    //--See if the object advertises a non-default level of access
    //  using nsISecurityCheckedComponent
    nsCOMPtr<nsISecurityCheckedComponent> checkedComponent =
        do_QueryInterface(aObj);

    nsXPIDLCString objectSecurityLevel;
    if (checkedComponent)
        checkedComponent->CanCreateWrapper((nsIID *)&aIID, getter_Copies(objectSecurityLevel));

    nsresult rv = CheckXPCPermissions(cx, aObj, nullptr, nullptr, objectSecurityLevel);
    if (NS_FAILED(rv))
    {
        //-- Access denied, report an error
        NS_ConvertUTF8toUTF16 strName("CreateWrapperDenied");
        nsAutoCString origin;
        nsresult rv2;
        nsIPrincipal* subjectPrincipal = doGetSubjectPrincipal(&rv2);
        if (NS_SUCCEEDED(rv2) && subjectPrincipal) {
            GetPrincipalDomainOrigin(subjectPrincipal, origin);
        }
        NS_ConvertUTF8toUTF16 originUnicode(origin);
        NS_ConvertUTF8toUTF16 className(objClassInfo.GetName());
        const PRUnichar* formatStrings[] = {
            className.get(),
            originUnicode.get()
        };
        uint32_t length = ArrayLength(formatStrings);
        if (originUnicode.IsEmpty()) {
            --length;
        } else {
            strName.AppendLiteral("ForOrigin");
        }
        nsXPIDLString errorMsg;
        // We need to keep our existing failure rv and not override it
        // with a likely success code from the following string bundle
        // call in order to throw the correct security exception later.
        rv2 = sStrBundle->FormatStringFromName(strName.get(),
                                               formatStrings,
                                               length,
                                               getter_Copies(errorMsg));
        NS_ENSURE_SUCCESS(rv2, rv2);

        SetPendingException(cx, errorMsg.get());
    }

    return rv;
}

NS_IMETHODIMP
nsScriptSecurityManager::CanCreateInstance(JSContext *cx,
                                           const nsCID &aCID)
{
    nsresult rv = CheckXPCPermissions(cx, nullptr, nullptr, nullptr, nullptr);
    if (NS_FAILED(rv))
    {
        //-- Access denied, report an error
        nsAutoCString errorMsg("Permission denied to create instance of class. CID=");
        char cidStr[NSID_LENGTH];
        aCID.ToProvidedString(cidStr);
        errorMsg.Append(cidStr);
        SetPendingException(cx, errorMsg.get());
    }
    return rv;
}

NS_IMETHODIMP
nsScriptSecurityManager::CanGetService(JSContext *cx,
                                       const nsCID &aCID)
{
    nsresult rv = CheckXPCPermissions(cx, nullptr, nullptr, nullptr, nullptr);
    if (NS_FAILED(rv))
    {
        //-- Access denied, report an error
        nsAutoCString errorMsg("Permission denied to get service. CID=");
        char cidStr[NSID_LENGTH];
        aCID.ToProvidedString(cidStr);
        errorMsg.Append(cidStr);
        SetPendingException(cx, errorMsg.get());
    }

    return rv;
}


NS_IMETHODIMP
nsScriptSecurityManager::CanAccess(uint32_t aAction,
                                   nsAXPCNativeCallContext* aCallContext,
                                   JSContext* cx,
                                   JSObject* aJSObject,
                                   nsISupports* aObj,
                                   nsIClassInfo* aClassInfo,
                                   jsid aPropertyName,
                                   void** aPolicy)
{
    return CheckPropertyAccessImpl(aAction, aCallContext, cx,
                                   aJSObject, aObj, aClassInfo,
                                   nullptr, aPropertyName, aPolicy);
}

nsresult
nsScriptSecurityManager::CheckXPCPermissions(JSContext* cx,
                                             nsISupports* aObj, JSObject* aJSObject,
                                             nsIPrincipal* aSubjectPrincipal,
                                             const char* aObjectSecurityLevel)
{
    MOZ_ASSERT(cx);
    JS::RootedObject jsObject(cx, aJSObject);
    // Check if the subject is privileged.
    if (SubjectIsPrivileged())
        return NS_OK;

    //-- If the object implements nsISecurityCheckedComponent, it has a non-default policy.
    if (aObjectSecurityLevel)
    {
        if (PL_strcasecmp(aObjectSecurityLevel, "allAccess") == 0)
            return NS_OK;
        if (cx && PL_strcasecmp(aObjectSecurityLevel, "sameOrigin") == 0)
        {
            nsresult rv;
            if (!jsObject)
            {
                nsCOMPtr<nsIXPConnectWrappedJS> xpcwrappedjs =
                    do_QueryInterface(aObj);
                if (xpcwrappedjs)
                {
                    jsObject = xpcwrappedjs->GetJSObject();
                    NS_ENSURE_STATE(jsObject);
                }
            }

            if (!aSubjectPrincipal)
            {
                // No subject principal passed in. Compute it.
                aSubjectPrincipal = GetSubjectPrincipal(cx, &rv);
                NS_ENSURE_SUCCESS(rv, rv);
            }
            if (aSubjectPrincipal && jsObject)
            {
                nsIPrincipal* objectPrincipal = doGetObjectPrincipal(jsObject);

                // Only do anything if we have both a subject and object
                // principal.
                if (objectPrincipal)
                {
                    bool subsumes;
                    rv = aSubjectPrincipal->Subsumes(objectPrincipal, &subsumes);
                    NS_ENSURE_SUCCESS(rv, rv);
                    if (subsumes)
                        return NS_OK;
                }
            }
        }
        else if (PL_strcasecmp(aObjectSecurityLevel, "noAccess") != 0)
        {
            if (SubjectIsPrivileged())
                return NS_OK;
        }
    }

    //-- Access tests failed
    return NS_ERROR_DOM_XPCONNECT_ACCESS_DENIED;
}

/////////////////////////////////////////////
// Method implementing nsIChannelEventSink //
/////////////////////////////////////////////
NS_IMETHODIMP
nsScriptSecurityManager::AsyncOnChannelRedirect(nsIChannel* oldChannel, 
                                                nsIChannel* newChannel,
                                                uint32_t redirFlags,
                                                nsIAsyncVerifyRedirectCallback *cb)
{
    nsCOMPtr<nsIPrincipal> oldPrincipal;
    GetChannelPrincipal(oldChannel, getter_AddRefs(oldPrincipal));

    nsCOMPtr<nsIURI> newURI;
    newChannel->GetURI(getter_AddRefs(newURI));
    nsCOMPtr<nsIURI> newOriginalURI;
    newChannel->GetOriginalURI(getter_AddRefs(newOriginalURI));

    NS_ENSURE_STATE(oldPrincipal && newURI && newOriginalURI);

    const uint32_t flags =
        nsIScriptSecurityManager::LOAD_IS_AUTOMATIC_DOCUMENT_REPLACEMENT |
        nsIScriptSecurityManager::DISALLOW_SCRIPT;
    nsresult rv = CheckLoadURIWithPrincipal(oldPrincipal, newURI, flags);
    if (NS_SUCCEEDED(rv) && newOriginalURI != newURI) {
        rv = CheckLoadURIWithPrincipal(oldPrincipal, newOriginalURI, flags);
    }

    if (NS_FAILED(rv))
        return rv;

    cb->OnRedirectVerifyCallback(NS_OK);
    return NS_OK;
}


/////////////////////////////////////
// Method implementing nsIObserver //
/////////////////////////////////////
const char sJSEnabledPrefName[] = "javascript.enabled";
const char sFileOriginPolicyPrefName[] =
    "security.fileuri.strict_origin_policy";
static const char sPolicyPrefix[] = "capability.policy.";

static const char* kObservedPrefs[] = {
  sJSEnabledPrefName,
  sFileOriginPolicyPrefName,
  sPolicyPrefix,
  nullptr
};


NS_IMETHODIMP
nsScriptSecurityManager::Observe(nsISupports* aObject, const char* aTopic,
                                 const PRUnichar* aMessage)
{
    nsresult rv = NS_OK;
    NS_ConvertUTF16toUTF8 messageStr(aMessage);
    const char *message = messageStr.get();

    static const char jsPrefix[] = "javascript.";
    static const char securityPrefix[] = "security.";
    if ((PL_strncmp(message, jsPrefix, sizeof(jsPrefix)-1) == 0) ||
        (PL_strncmp(message, securityPrefix, sizeof(securityPrefix)-1) == 0) )
    {
        ScriptSecurityPrefChanged();
    }
    else if (PL_strncmp(message, sPolicyPrefix, sizeof(sPolicyPrefix)-1) == 0)
    {
        // This will force re-initialization of the pref table
        mPolicyPrefsChanged = true;
    }
    return rv;
}

/////////////////////////////////////////////
// Constructor, Destructor, Initialization //
/////////////////////////////////////////////
nsScriptSecurityManager::nsScriptSecurityManager(void)
    : mOriginToPolicyMap(nullptr),
      mDefaultPolicy(nullptr),
      mCapabilities(nullptr),
      mPrefInitialized(false),
      mIsJavaScriptEnabled(false),
      mPolicyPrefsChanged(true)
{
    static_assert(sizeof(intptr_t) == sizeof(void*),
                  "intptr_t and void* have different lengths on this platform. "
                  "This may cause a security failure with the SecurityLevel union.");
}

nsresult nsScriptSecurityManager::Init()
{
    InitPrefs();

    nsresult rv = CallGetService(NS_IOSERVICE_CONTRACTID, &sIOService);
    NS_ENSURE_SUCCESS(rv, rv);

    nsCOMPtr<nsIStringBundleService> bundleService =
        mozilla::services::GetStringBundleService();
    if (!bundleService)
        return NS_ERROR_FAILURE;

    rv = bundleService->CreateBundle("chrome://global/locale/security/caps.properties", &sStrBundle);
    NS_ENSURE_SUCCESS(rv, rv);

    // Create our system principal singleton
    nsRefPtr<nsSystemPrincipal> system = new nsSystemPrincipal();
    NS_ENSURE_TRUE(system, NS_ERROR_OUT_OF_MEMORY);

    mSystemPrincipal = system;

    //-- Register security check callback in the JS engine
    //   Currently this is used to control access to function.caller
    rv = nsXPConnect::XPConnect()->GetRuntime(&sRuntime);
    NS_ENSURE_SUCCESS(rv, rv);

    static const JSSecurityCallbacks securityCallbacks = {
        CheckObjectAccess,
        ContentSecurityPolicyPermitsJSAction
    };

    MOZ_ASSERT(!JS_GetSecurityCallbacks(sRuntime));
    JS_SetSecurityCallbacks(sRuntime, &securityCallbacks);
    JS_InitDestroyPrincipalsCallback(sRuntime, nsJSPrincipals::Destroy);

    JS_SetTrustedPrincipals(sRuntime, system);

    return NS_OK;
}

static StaticRefPtr<nsScriptSecurityManager> gScriptSecMan;

nsScriptSecurityManager::~nsScriptSecurityManager(void)
{
    Preferences::RemoveObservers(this, kObservedPrefs);
    delete mOriginToPolicyMap;
    if(mDefaultPolicy)
        mDefaultPolicy->Drop();
    delete mCapabilities;
    if (mDomainPolicy)
        mDomainPolicy->Deactivate();
    MOZ_ASSERT(!mDomainPolicy);
}

void
nsScriptSecurityManager::Shutdown()
{
    if (sRuntime) {
        JS_SetSecurityCallbacks(sRuntime, nullptr);
        JS_SetTrustedPrincipals(sRuntime, nullptr);
        sRuntime = nullptr;
    }
    sEnabledID = JSID_VOID;

    NS_IF_RELEASE(sIOService);
    NS_IF_RELEASE(sStrBundle);
}

nsScriptSecurityManager *
nsScriptSecurityManager::GetScriptSecurityManager()
{
    if (!gScriptSecMan && nsXPConnect::XPConnect())
    {
        nsRefPtr<nsScriptSecurityManager> ssManager = new nsScriptSecurityManager();

        nsresult rv;
        rv = ssManager->Init();
        if (NS_FAILED(rv)) {
            return nullptr;
        }
 
        rv = nsXPConnect::XPConnect()->
            SetDefaultSecurityManager(ssManager);
        if (NS_FAILED(rv)) {
            NS_WARNING("Failed to install xpconnect security manager!");
            return nullptr;
        }

        ClearOnShutdown(&gScriptSecMan);
        gScriptSecMan = ssManager;
    }
    return gScriptSecMan;
}

// Currently this nsGenericFactory constructor is used only from FastLoad
// (XPCOM object deserialization) code, when "creating" the system principal
// singleton.
nsSystemPrincipal *
nsScriptSecurityManager::SystemPrincipalSingletonConstructor()
{
    nsIPrincipal *sysprin = nullptr;
    if (gScriptSecMan)
        NS_ADDREF(sysprin = gScriptSecMan->mSystemPrincipal);
    return static_cast<nsSystemPrincipal*>(sysprin);
}

nsresult
nsScriptSecurityManager::InitPolicies()
{
    // Clear any policies cached on XPConnect wrappers
    nsresult rv =
        nsXPConnect::XPConnect()->ClearAllWrappedNativeSecurityPolicies();
    if (NS_FAILED(rv)) return rv;

    //-- Clear mOriginToPolicyMap: delete mapped DomainEntry items,
    //-- whose dtor decrements refcount of stored DomainPolicy object
    delete mOriginToPolicyMap;
    
    //-- Marks all the survivor DomainPolicy objects (those cached
    //-- by nsPrincipal objects) as invalid: they will be released
    //-- on first nsPrincipal::GetSecurityPolicy() attempt.
    DomainPolicy::InvalidateAll();
    
    //-- Release old default policy
    if(mDefaultPolicy) {
        mDefaultPolicy->Drop();
        mDefaultPolicy = nullptr;
    }
    
    //-- Initialize a new mOriginToPolicyMap
    mOriginToPolicyMap =
      new nsObjectHashtable(nullptr, nullptr, DeleteDomainEntry, nullptr);
    if (!mOriginToPolicyMap)
        return NS_ERROR_OUT_OF_MEMORY;

    //-- Create, refcount and initialize a new default policy 
    mDefaultPolicy = new DomainPolicy();
    if (!mDefaultPolicy)
        return NS_ERROR_OUT_OF_MEMORY;

    mDefaultPolicy->Hold();
    if (!mDefaultPolicy->Init())
        return NS_ERROR_UNEXPECTED;

    //-- Initialize the table of security levels
    if (!mCapabilities)
    {
        mCapabilities = 
          new nsObjectHashtable(nullptr, nullptr, DeleteCapability, nullptr);
        if (!mCapabilities)
            return NS_ERROR_OUT_OF_MEMORY;
    }

    // Get a JS context - we need it to create internalized strings later.
    AutoSafeJSContext cx;
    rv = InitDomainPolicy(cx, "default", mDefaultPolicy);
    NS_ENSURE_SUCCESS(rv, rv);

    nsAdoptingCString policyNames =
        Preferences::GetCString("capability.policy.policynames");

    nsAdoptingCString defaultPolicyNames =
        Preferences::GetCString("capability.policy.default_policynames");
    policyNames += NS_LITERAL_CSTRING(" ") + defaultPolicyNames;

    //-- Initialize domain policies
    char* policyCurrent = policyNames.BeginWriting();
    bool morePolicies = true;
    while (morePolicies)
    {
        while(*policyCurrent == ' ' || *policyCurrent == ',')
            policyCurrent++;
        if (*policyCurrent == '\0')
            break;
        char* nameBegin = policyCurrent;

        while(*policyCurrent != '\0' && *policyCurrent != ' ' && *policyCurrent != ',')
            policyCurrent++;

        morePolicies = (*policyCurrent != '\0');
        *policyCurrent = '\0';
        policyCurrent++;

        nsAutoCString sitesPrefName(
            NS_LITERAL_CSTRING(sPolicyPrefix) +
            nsDependentCString(nameBegin) +
            NS_LITERAL_CSTRING(".sites"));
        nsAdoptingCString domainList =
            Preferences::GetCString(sitesPrefName.get());
        if (!domainList) {
            continue;
        }

        DomainPolicy* domainPolicy = new DomainPolicy();
        if (!domainPolicy)
            return NS_ERROR_OUT_OF_MEMORY;

        if (!domainPolicy->Init())
        {
            delete domainPolicy;
            return NS_ERROR_UNEXPECTED;
        }
        domainPolicy->Hold();
        //-- Parse list of sites and create an entry in mOriginToPolicyMap for each
        char* domainStart = domainList.BeginWriting();
        char* domainCurrent = domainStart;
        char* lastDot = nullptr;
        char* nextToLastDot = nullptr;
        bool moreDomains = true;
        while (moreDomains)
        {
            if (*domainCurrent == ' ' || *domainCurrent == '\0')
            {
                moreDomains = (*domainCurrent != '\0');
                *domainCurrent = '\0';
                nsCStringKey key(nextToLastDot ? nextToLastDot+1 : domainStart);
                DomainEntry *newEntry = new DomainEntry(domainStart, domainPolicy);
                if (!newEntry)
                {
                    domainPolicy->Drop();
                    return NS_ERROR_OUT_OF_MEMORY;
                }
                DomainEntry *existingEntry = (DomainEntry *)
                    mOriginToPolicyMap->Get(&key);
                if (!existingEntry)
                    mOriginToPolicyMap->Put(&key, newEntry);
                else
                {
                    if (existingEntry->Matches(domainStart))
                    {
                        newEntry->mNext = existingEntry;
                        mOriginToPolicyMap->Put(&key, newEntry);
                    }
                    else
                    {
                        while (existingEntry->mNext)
                        {
                            if (existingEntry->mNext->Matches(domainStart))
                            {
                                newEntry->mNext = existingEntry->mNext;
                                existingEntry->mNext = newEntry;
                                break;
                            }
                            existingEntry = existingEntry->mNext;
                        }
                        if (!existingEntry->mNext)
                            existingEntry->mNext = newEntry;
                    }
                }
                domainStart = domainCurrent + 1;
                lastDot = nextToLastDot = nullptr;
            }
            else if (*domainCurrent == '.')
            {
                nextToLastDot = lastDot;
                lastDot = domainCurrent;
            }
            domainCurrent++;
        }

        rv = InitDomainPolicy(cx, nameBegin, domainPolicy);
        domainPolicy->Drop();
        if (NS_FAILED(rv))
            return rv;
    }

    // Reset the "dirty" flag
    mPolicyPrefsChanged = false;

    return NS_OK;
}


nsresult
nsScriptSecurityManager::InitDomainPolicy(JSContext* cx,
                                          const char* aPolicyName,
                                          DomainPolicy* aDomainPolicy)
{
    nsresult rv;
    nsAutoCString policyPrefix(NS_LITERAL_CSTRING(sPolicyPrefix) +
                               nsDependentCString(aPolicyName) +
                               NS_LITERAL_CSTRING("."));
    uint32_t prefixLength = policyPrefix.Length() - 1; // subtract the '.'

    uint32_t prefCount;
    char** prefNames;
    nsIPrefBranch* branch = Preferences::GetRootBranch();
    NS_ASSERTION(branch, "failed to get the root pref branch");
    rv = branch->GetChildList(policyPrefix.get(), &prefCount, &prefNames);
    if (NS_FAILED(rv)) return rv;
    if (prefCount == 0)
        return NS_OK;

    //-- Populate the policy
    uint32_t currentPref = 0;
    for (; currentPref < prefCount; currentPref++)
    {
        // Get the class name
        const char* start = prefNames[currentPref] + prefixLength + 1;
        char* end = PL_strchr(start, '.');
        if (!end) // malformed pref, bail on this one
            continue;
        static const char sitesStr[] = "sites";

        // We dealt with "sites" in InitPolicies(), so no need to do
        // that again...
        if (PL_strncmp(start, sitesStr, sizeof(sitesStr)-1) == 0)
            continue;

        // Get the pref value
        nsAdoptingCString prefValue =
            Preferences::GetCString(prefNames[currentPref]);
        if (!prefValue) {
            continue;
        }

        SecurityLevel secLevel;
        if (PL_strcasecmp(prefValue, "noAccess") == 0)
            secLevel.level = SCRIPT_SECURITY_NO_ACCESS;
        else if (PL_strcasecmp(prefValue, "allAccess") == 0)
            secLevel.level = SCRIPT_SECURITY_ALL_ACCESS;
        else if (PL_strcasecmp(prefValue, "sameOrigin") == 0)
            secLevel.level = SCRIPT_SECURITY_SAME_ORIGIN_ACCESS;
        else 
        {  //-- pref value is the name of a capability
            nsCStringKey secLevelKey(prefValue);
            secLevel.capability =
                reinterpret_cast<char*>(mCapabilities->Get(&secLevelKey));
            if (!secLevel.capability)
            {
                secLevel.capability = NS_strdup(prefValue);
                if (!secLevel.capability)
                    break;
                mCapabilities->Put(&secLevelKey, 
                                   secLevel.capability);
            }
        }

        *end = '\0';
        // Find or store this class in the classes table
        ClassPolicy* cpolicy = 
          static_cast<ClassPolicy*>
                     (PL_DHashTableOperate(aDomainPolicy, start,
                                              PL_DHASH_ADD));
        if (!cpolicy)
            break;

        // If this is the wildcard class (class '*'), save it in mWildcardPolicy
        // (we leave it stored in the hashtable too to take care of the cleanup)
        if ((*start == '*') && (end == start + 1)) {
            aDomainPolicy->mWildcardPolicy = cpolicy;

            // Make sure that cpolicy knows about aDomainPolicy so it can reset
            // the mWildcardPolicy pointer as needed if it gets moved in the
            // hashtable.
            cpolicy->mDomainWeAreWildcardFor = aDomainPolicy;
        }

        // Get the property name
        start = end + 1;
        end = PL_strchr(start, '.');
        if (end)
            *end = '\0';

        JSString* propertyKey = ::JS_InternString(cx, start);
        if (!propertyKey)
            return NS_ERROR_OUT_OF_MEMORY;

        // Store this property in the class policy
        PropertyPolicy* ppolicy = 
          static_cast<PropertyPolicy*>
                     (PL_DHashTableOperate(cpolicy->mPolicy, propertyKey,
                                              PL_DHASH_ADD));
        if (!ppolicy)
            break;

        if (end) // The pref specifies an access mode
        {
            start = end + 1;
            if (PL_strcasecmp(start, "set") == 0)
                ppolicy->mSet = secLevel;
            else
                ppolicy->mGet = secLevel;
        }
        else
        {
            if (ppolicy->mGet.level == SCRIPT_SECURITY_UNDEFINED_ACCESS)
                ppolicy->mGet = secLevel;
            if (ppolicy->mSet.level == SCRIPT_SECURITY_UNDEFINED_ACCESS)
                ppolicy->mSet = secLevel;
        }
    }

    NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(prefCount, prefNames);
    if (currentPref < prefCount) // Loop exited early because of out-of-memory error
        return NS_ERROR_OUT_OF_MEMORY;
    return NS_OK;
}

inline void
nsScriptSecurityManager::ScriptSecurityPrefChanged()
{
    // JavaScript defaults to enabled in failure cases.
    mIsJavaScriptEnabled = true;

    sStrictFileOriginPolicy = true;

    nsresult rv;
    if (!mPrefInitialized) {
        rv = InitPrefs();
        if (NS_FAILED(rv))
            return;
    }

    mIsJavaScriptEnabled =
        Preferences::GetBool(sJSEnabledPrefName, mIsJavaScriptEnabled);

    sStrictFileOriginPolicy =
        Preferences::GetBool(sFileOriginPolicyPrefName, false);
}

nsresult
nsScriptSecurityManager::InitPrefs()
{
    nsIPrefBranch* branch = Preferences::GetRootBranch();
    NS_ENSURE_TRUE(branch, NS_ERROR_FAILURE);

    mPrefInitialized = true;

    // Set the initial value of the "javascript.enabled" prefs
    ScriptSecurityPrefChanged();

    // set observer callbacks in case the value of the prefs change
    Preferences::AddStrongObservers(this, kObservedPrefs);

    return NS_OK;
}

namespace mozilla {

void
GetJarPrefix(uint32_t aAppId, bool aInMozBrowser, nsACString& aJarPrefix)
{
  MOZ_ASSERT(aAppId != nsIScriptSecurityManager::UNKNOWN_APP_ID);

  if (aAppId == nsIScriptSecurityManager::UNKNOWN_APP_ID) {
    aAppId = nsIScriptSecurityManager::NO_APP_ID;
  }

  aJarPrefix.Truncate();

  // Fallback.
  if (aAppId == nsIScriptSecurityManager::NO_APP_ID && !aInMozBrowser) {
    return;
  }

  // aJarPrefix = appId + "+" + { 't', 'f' } + "+";
  aJarPrefix.AppendInt(aAppId);
  aJarPrefix.Append('+');
  aJarPrefix.Append(aInMozBrowser ? 't' : 'f');
  aJarPrefix.Append('+');

  return;
}

} // namespace mozilla

NS_IMETHODIMP
nsScriptSecurityManager::GetJarPrefix(uint32_t aAppId,
                                      bool aInMozBrowser,
                                      nsACString& aJarPrefix)
{
  MOZ_ASSERT(aAppId != nsIScriptSecurityManager::UNKNOWN_APP_ID);

  mozilla::GetJarPrefix(aAppId, aInMozBrowser, aJarPrefix);
  return NS_OK;
}

NS_IMETHODIMP
nsScriptSecurityManager::GetDomainPolicyActive(bool *aRv)
{
    *aRv = !!mDomainPolicy;
    return NS_OK;
}

NS_IMETHODIMP
nsScriptSecurityManager::ActivateDomainPolicy(nsIDomainPolicy** aRv)
{
    // We only allow one domain policy at a time. The holder of the previous
    // policy must explicitly deactivate it first.
    if (mDomainPolicy) {
        return NS_ERROR_SERVICE_NOT_AVAILABLE;
    }

    mDomainPolicy = new mozilla::hotness::DomainPolicy();
    nsCOMPtr<nsIDomainPolicy> ptr = mDomainPolicy;
    ptr.forget(aRv);
    return NS_OK;
}

// Intentionally non-scriptable. Script must have a reference to the
// nsIDomainPolicy to deactivate it.
void
nsScriptSecurityManager::DeactivateDomainPolicy()
{
    mDomainPolicy = nullptr;
}

NS_IMETHODIMP
nsScriptSecurityManager::PolicyAllowsScript(nsIURI* aURI, bool *aRv)
{
    nsresult rv;

    // Compute our rule. If we don't have any domain policy set up that might
    // provide exceptions to this rule, we're done.
    *aRv = mIsJavaScriptEnabled;
    if (!mDomainPolicy) {
        return NS_OK;
    }

    // We have a domain policy. Grab the appropriate set of exceptions to the
    // rule (either the blacklist or the whitelist, depending on whether script
    // is enabled or disabled by default).
    nsCOMPtr<nsIDomainSet> exceptions;
    nsCOMPtr<nsIDomainSet> superExceptions;
    if (*aRv) {
        mDomainPolicy->GetBlacklist(getter_AddRefs(exceptions));
        mDomainPolicy->GetSuperBlacklist(getter_AddRefs(superExceptions));
    } else {
        mDomainPolicy->GetWhitelist(getter_AddRefs(exceptions));
        mDomainPolicy->GetSuperWhitelist(getter_AddRefs(superExceptions));
    }

    bool contains;
    rv = exceptions->Contains(aURI, &contains);
    NS_ENSURE_SUCCESS(rv, rv);
    if (contains) {
        *aRv = !*aRv;
        return NS_OK;
    }
    rv = superExceptions->ContainsSuperDomain(aURI, &contains);
    NS_ENSURE_SUCCESS(rv, rv);
    if (contains) {
        *aRv = !*aRv;
    }

    return NS_OK;
}

/****************************************************************************
Copyright (c) 2010-2012 cocos2d-x.org
Copyright (c) 2008-2010 Ricardo Quesada
Copyright (c) 2009      Valentin Milea
Copyright (c) 2011      Zynga Inc.
Copyright (c) 2011-2012 openxlive.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
****************************************************************************/

using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.GamerServices;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using Microsoft.Xna.Framework.Media;
using System.Diagnostics;

namespace cocos2d
{
    public abstract class CCDirector : CCObject
    {
        readonly double kDefaultFPS = 60;

        #region singleton stuff

        /** There are 4 types of Director.
        - kCCDirectorTypeNSTimer (default)
        - kCCDirectorTypeMainLoop
        - kCCDirectorTypeThreadMainLoop
        - kCCDirectorTypeDisplayLink

        Each Director has it's own benefits, limitations.
        Now we only support DisplayLink director, so it has not effect. 
       */

        ///<summary>
        /// This method should be called before any other call to the director.
        ///@since v0.8.2
        /// </summary>
        public static bool setDirectorType(ccDirectorType obDirectorType)
        {
            // we only support CCDisplayLinkDirector
            CCDirector.sharedDirector();

            return true;
        }

        static CCDirector s_sharedDirector = new CCDisplayLinkDirector();
        static bool s_bFirstRun = true;

        /// <summary>
        /// returns a shared instance of the director
        /// </summary>
        /// <returns></returns>
        public static CCDirector sharedDirector()
        {
            if (s_bFirstRun)
            {
                s_sharedDirector.init();
                s_bFirstRun = false;
            }

            return s_sharedDirector;
        }

        #endregion

        public virtual bool init()
        {
            //scene
            m_dOldAnimationInterval = m_dAnimationInterval = 1.0 / kDefaultFPS;

            // Set default projection (3D)
            m_eProjection = ccDirectorProjection.kCCDirectorProjectionDefault;

            // projection delegate if "Custom" projection is used
            //m_pProjectionDelegate = NULL;

            //FPS
            m_bDisplayFPS = false;
            m_uTotalFrames = m_uFrames = 0;
            m_pszFPS = "";

            m_bPaused = false;

            //paused?
            m_bPaused = false;

            //purge?
            m_bPurgeDirecotorInNextLoop = false;

            m_obWinSizeInPixels = m_obWinSizeInPoints = new CCSize(0, 0);

            // portrait mode default
            m_eDeviceOrientation = ccDeviceOrientation.CCDeviceOrientationPortrait;

            m_bRetinaDisplay = false;
            m_fContentScaleFactor = 1;
            m_bIsContentScaleSupported = false;

            return true;
        }

        public abstract void mainLoop(GameTime gameTime);

        #region sceneManagement

        /// <summary>
        /// Draw the scene.
        /// This method is called every frame. Don't call it manually.
        /// </summary>
        protected void drawScene(GameTime gameTime)
        {
            //tick before glClear: issue #533
            if (!m_bPaused)
            {
                //CCScheduler.sharedScheduler().tick((float)gameTime.ElapsedGameTime.TotalSeconds);
                m_fDeltaTime = (float)gameTime.ElapsedGameTime.TotalSeconds;
            }

            //glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

            /* to avoid flickr, nextScene MUST be here: after tick and before draw.
             XXX: Which bug is this one. It seems that it can't be reproduced with v0.9 */
            if (m_pNextScene != null)
            {
                setNextScene();
            }

            //glPushMatrix();

            applyOrientation();

            // By default enable VertexArray, ColorArray, TextureCoordArray and Texture2D
            // CC_ENABLE_DEFAULT_GL_STATES();

            // draw the scene
            if (m_pRunningScene != null)
            {
                m_pRunningScene.visit();
            }

            // draw the notifications node
            if (m_pNotificationNode != null)
            {
                m_pNotificationNode.visit();
            }

            if (m_bDisplayFPS)
            {
                showFPS();
            }

#if CC_ENABLE_PROFILERS
	showProfilers();
#endif

            //CC_DISABLE_DEFAULT_GL_STATES();

            //glPopMatrix();

            m_uTotalFrames++;
        }

        protected void setNextScene()
        {
            // If it is not a transition, call onExit/cleanup
            /*if (! newIsTransition)*/
            if (!(m_pNextScene is CCTransitionScene))
            {
                if (m_pRunningScene != null)
                {
                    m_pRunningScene.onExit();

                    //CLEAR TOUCHES BEFORE LEAVING
                    CCApplication.sharedApplication().ClearTouches();
                }

                // issue #709. the root node (scene) should receive the cleanup message too
                // otherwise it might be leaked.
                if (m_bSendCleanupToScene && m_pRunningScene != null)
                {
                    m_pRunningScene.cleanup();
                }
            }

            m_pRunningScene = m_pNextScene;
            // m_pNextScene.retain();
            m_pNextScene = null;

            if (m_pRunningScene != null)
            {
                m_pRunningScene.onEnter();
                if (m_pRunningScene is CCTransitionScene)
                {
                m_pRunningScene.onEnterTransitionDidFinish();
            }
        }
        }

        /// <summary>
        /// Enters the Director's main loop with the given Scene. 
        /// Call it to run only your FIRST scene.
        /// Don't call it if there is already a running scene.
        /// </summary>
        /// <param name="pScene"></param>
        public void runWithScene(CCScene pScene)
        {
            Debug.Assert(pScene != null, "pScene cannot be null");
            Debug.Assert(m_pRunningScene == null, "m_pRunningScene cannot be null");

            pushScene(pScene);
            startAnimation();
        }

        /// <summary>
        /// Suspends the execution of the running scene, pushing it on the stack of suspended scenes.
        /// The new scene will be executed.
        /// Try to avoid big stacks of pushed scenes to reduce memory allocation. 
        /// ONLY call it if there is a running scene.
        /// </summary>
        /// <param name="pScene"></param>
        public void pushScene(CCScene pScene)
        {
            Debug.Assert(pScene != null, "pScene cannot be null");

            m_bSendCleanupToScene = false;

            m_pobScenesStack.Add(pScene);
            m_pNextScene = pScene;
        }

        /// <summary>
        /// Pops out a scene from the queue.
        /// This scene will replace the running one.
        /// The running scene will be deleted. If there are no more scenes in the stack the execution is terminated.
        /// ONLY call it if there is a running scene.
        /// </summary>
        public void popScene()
        {
            Debug.Assert(m_pRunningScene != null, "m_pRunningScene cannot be null");

            if (m_pobScenesStack.Count > 0)
            {
                m_pobScenesStack.RemoveAt(m_pobScenesStack.Count - 1);
            }
            int c = m_pobScenesStack.Count;

            if (c == 0)
            {
                CCApplication.sharedApplication().Game.Exit();
                end();
            }
            else
            {
                m_bSendCleanupToScene = true;
                m_pNextScene = m_pobScenesStack[c - 1];
            }
        }

        public CCScene getLastScene()
        {
            if (m_pobScenesStack.Count > 1)
                return m_pobScenesStack[m_pobScenesStack.Count - 2];
            else
                return null;
        
        }

        /// <summary>
        /// Replaces the running scene with a new one. The running scene is terminated.
        /// ONLY call it if there is a running scene.
        /// </summary>
        /// <param name="pScene"></param>
        public void replaceScene(CCScene pScene)
        {
            Debug.Assert(pScene != null, "pScene cannot be null");

            int index = m_pobScenesStack.Count;

            m_bSendCleanupToScene = true;
            m_pobScenesStack[index - 1] = pScene;

            m_pNextScene = pScene;
        }

        ///<summary>
        /// Whether or not the replaced scene will receive the cleanup message.
        /// If the new scene is pushed, then the old scene won't receive the "cleanup" message.
        /// If the new scene replaces the old one, the it will receive the "cleanup" message.
        /// @since v0.99.0
        /// </summary>
        public bool isSendCleanupToScene()
        {
            return m_bSendCleanupToScene;
        }

        #endregion

        #region Protected

        protected void purgeDirector()
        {
            // don't release the event handlers
            // They are needed in case the director is run again
            //CCTouchDispatcher::sharedDispatcher()->removeAllDelegates();

            if (m_pRunningScene != null)
            {
                //m_pRunningScene->onExit();
                //m_pRunningScene->cleanup();
                //m_pRunningScene->release();
            }

            m_pRunningScene = null;
            m_pNextScene = null;

            // remove all objects, but don't release it.
            // runWithScene might be executed after 'end'.
            m_pobScenesStack.Clear();

            stopAnimation();

#if CC_DIRECTOR_FAST_FPS
            //CC_SAFE_RELEASE_NULL(m_pFPSLabel);
#endif

            //CC_SAFE_RELEASE_NULL(m_pProjectionDelegate);

            // purge bitmap cache
            //CCLabelBMFont::purgeCachedData();

            // purge all managers
            //CCAnimationCache::purgeSharedAnimationCache();
            //CCSpriteFrameCache::purgeSharedSpriteFrameCache();
            //CCActionManager::sharedManager()->purgeSharedManager();
            //CCScheduler::purgeSharedScheduler();
            //CCTextureCache::purgeSharedTextureCache();

#if (CC_TARGET_PLATFORM != CC_PLATFORM_AIRPLAY)	
	CCUserDefault::purgeSharedUserDefault();
#endif
            // OpenGL view
            //m_pobOpenGLView->release();
            //m_pobOpenGLView = NULL;
        }
        protected bool m_bPurgeDirecotorInNextLoop; // this flag will be set to true in end()

        protected void updateContentScaleFactor()
        {
            // [openGLView responseToSelector:@selector(setContentScaleFactor)]
            if (CCApplication.sharedApplication().canSetContentScaleFactor)
            {
                CCApplication.sharedApplication().setContentScaleFactor(m_fContentScaleFactor);
                m_bIsContentScaleSupported = true;
            }
            else
            {
                //CCLOG("cocos2d: setContentScaleFactor:'is not supported on this device");
            }
        }

#if CC_DIRECTOR_FAST_FPS
        /** shows the FPS in the screen */
        protected void showFPS()
        {
            m_uFrames++;
            m_fAccumDt += m_fDeltaTime;

            if (m_fAccumDt > ccMacros.CC_DIRECTOR_FPS_INTERVAL)
            {
                m_fFrameRate = m_uFrames / m_fAccumDt;
                m_uFrames = 0;
                m_fAccumDt = 0;

                m_pszFPS = string.Format("{0}", m_fFrameRate);
            }

            SpriteFont font = CCApplication.sharedApplication().content.Load<SpriteFont>(@"fonts/Arial");
            CCApplication.sharedApplication().spriteBatch.Begin();
            CCApplication.sharedApplication().spriteBatch.DrawString(font, 
                m_pszFPS, 
                new Vector2(0, CCApplication.sharedApplication().getSize().height - 50), 
                new Color(0, 255, 255));
            CCApplication.sharedApplication().spriteBatch.End();
        }
#else
        protected void showFPS()
        {
            throw new NotImplementedException();
        }
#endif // CC_DIRECTOR_FAST_FPS

        protected double m_dAnimationInterval;
        protected double m_dOldAnimationInterval;

        /* landscape mode ? */
        bool m_bLandscape;

        bool m_bDisplayFPS;
        float m_fAccumDt;
        float m_fFrameRate;

        /* is the running scene paused */
        bool m_bPaused;

        /* How many frames were called since the director started */
        uint m_uTotalFrames;
        uint m_uFrames;

        float m_fDeltaTime;

        /* The running scene */
        CCScene m_pRunningScene;

        /* will be the next 'runningScene' in the next frame
         nextScene is a weak reference. */
        CCScene m_pNextScene;

        /// <summary>
        /// If YES, then "old" scene will receive the cleanup message
        /// </summary>
        bool m_bSendCleanupToScene;

        /// <summary>
        /// scheduled scenes
        /// </summary>
        List<CCScene> m_pobScenesStack = new List<CCScene>();

        /* projection used */
        ccDirectorProjection m_eProjection;

        /* window size in points */
        CCSize m_obWinSizeInPoints;

        /* window size in pixels */
        CCSize m_obWinSizeInPixels;

        /* content scale factor */
        float m_fContentScaleFactor = 1;

        /* store the fps string */
        string m_pszFPS;

        /* This object will be visited after the scene. Useful to hook a notification node */
        CCNode m_pNotificationNode;

        /* Projection protocol delegate */
        //CCProjectionProtocol *m_pProjectionDelegate;

        /* The device orientation */
        ccDeviceOrientation m_eDeviceOrientation;
        /* contentScaleFactor could be simulated */
        bool m_bIsContentScaleSupported;

        bool m_bRetinaDisplay;

        #endregion

        #region attribute

        /// <summary>
        ///  Get current running Scene. Director can only run one Scene at the time 
        /// </summary>
        public CCScene runningScene
        {
            get
            {
                return m_pRunningScene;
            }
        }

        /// <summary>
        /// the FPS value
        /// </summary>
        public virtual double animationInterval
        {
            get { return m_dAnimationInterval; }
            set { }
        }

        /// <summary>
        /// Whether or not to display the FPS on the bottom-left corner 
        /// </summary>
        /// <returns></returns>
        public bool DisplayFPS
        {
            get { return m_bDisplayFPS; }
            set { m_bDisplayFPS = value; }
        }

        /// <summary>
        /// Whether or not the Director is paused
        /// </summary>
        public bool isPaused
        {
            get { return m_bPaused; }
        }

        /// <summary>
        /// How many frames were called since the director started
        /// </summary>
        public uint getFrames()
        {
            return m_uFrames;
        }

        /// <summary>
        /// Sets an OpenGL projection
        ///@since v0.8.2
        /// </summary>
        /// <returns></returns>
        public ccDirectorProjection Projection
        {
            set
            {
                CCApplication app = CCApplication.sharedApplication();

                CCSize size = CCApplication.sharedApplication().getSize();
                float zeye = this.zEye;
                switch (value)
                {
                    case ccDirectorProjection.kCCDirectorProjection2D:
                        app.viewMatrix = Matrix.CreateLookAt(new Vector3(size.width / 2.0f, size.height / 2.0f, 5.0f),
                            new Vector3(size.width / 2.0f, size.height / 2.0f, 0), 
                            Vector3.Up);
                        app.projectionMatrix = Matrix.CreateOrthographicOffCenter(-size.width / 2.0f, 
                            size.width / 2.0f, -size.height / 2.0f, size.height / 2.0f, -1024.0f, 1024.0f);
                        app.worldMatrix = Matrix.Identity;

                        break;

                    case ccDirectorProjection.kCCDirectorProjection3D:
                        app.viewMatrix = Matrix.CreateLookAt(new Vector3(size.width / 2.0f, size.height / 2.0f, size.height / 1.1566f),
                            new Vector3(size.width / 2.0f, size.height / 2.0f, 0), Vector3.Up);

                        app.projectionMatrix = Matrix.CreatePerspectiveFieldOfView(MathHelper.Pi / 3.0f, size.width / size.height, 0.5f, 1500.0f);

                        app.worldMatrix = Matrix.Identity;// * Matrix.CreateTranslation(new Vector3(-size.width / 2, -size.height / 2, 0));

                        break;

                    case ccDirectorProjection.kCCDirectorProjectionCustom:
                        //if (m_pProjectionDelegate)
                        //{
                        //    m_pProjectionDelegate->updateProjection();
                        //}
                        break;

                    default:
                        Debug.Assert(true, "cocos2d: Director: unrecognized projecgtion");
                        break;
                }

                m_eProjection = value;
            }
        }

        #endregion

        #region  window size

        /// <summary>
        /// returns the size of the OpenGL view in points.
        /// It takes into account any possible rotation (device orientation) of the window
        /// </summary>
        /// <returns></returns>
        public CCSize getWinSize()
        {
            CCSize s = new CCSize(m_obWinSizeInPoints.width, m_obWinSizeInPoints.height);

            //it's different from cocos2d-win32. 

            //if (m_eDeviceOrientation == ccDeviceOrientation.CCDeviceOrientationLandscapeLeft
            //    || m_eDeviceOrientation == ccDeviceOrientation.CCDeviceOrientationLandscapeRight)
            //{
            //    // swap x,y in landspace mode
            //    CCSize tmp = s;
            //    s.width = tmp.width;
            //    s.height = tmp.height;
            //}

            return s;
        }

        /// <summary>
        /// returns the size of the OpenGL view in pixels.
        /// It takes into account any possible rotation (device orientation) of the window.
        /// On Mac winSize and winSizeInPixels return the same value.
        /// </summary>
        public CCSize winSizeInPixels
        {
            get
            {
                CCSize s = getWinSize();

                s.width *= CCDirector.sharedDirector().ContentScaleFactor;
                s.height *= CCDirector.sharedDirector().ContentScaleFactor;

                return s;
            }
        }

        /// <summary>
        /// returns the display size of the OpenGL view in pixels.
        /// It doesn't take into account any possible rotation of the window.
        /// </summary>
        /// <returns></returns>
        public CCSize displaySizeInPixels
        {
            get
            {
                return new CCSize(m_obWinSizeInPixels.width, m_obWinSizeInPixels.height);
            }
        }

        #endregion

        /// <summary>
        /// changes the projection size
        /// </summary>
        /// <param name="newWindowSize"></param>
        public void reshapeProjection(CCSize newWindowSize)
        {
            // CC_UNUSED_PARAM(newWindowSize);
            m_obWinSizeInPoints = CCApplication.sharedApplication().getSize();
            m_obWinSizeInPixels = new CCSize(m_obWinSizeInPoints.width * m_fContentScaleFactor,
                                             m_obWinSizeInPoints.height * m_fContentScaleFactor);

            Projection = m_eProjection;
        }

        /// <summary>
        /// converts a UIKit coordinate to an OpenGL coordinate
        /// Useful to convert (multi) touches coordinates to the current layout (portrait or landscape)
        /// </summary>
        public CCPoint convertToGL(CCPoint obPoint)
        {
            CCSize s = m_obWinSizeInPoints;

            //this is different from cocos2d-win32
            return new CCPoint(obPoint.x, s.height - obPoint.y);

            //CCSize s = m_obWinSizeInPoints;
            //float newY = s.height - obPoint.y;
            //float newX = s.width - obPoint.x;

            //CCPoint ret = new CCPoint(0, 0);
            //switch (m_eDeviceOrientation)
            //{
            //    case ccDeviceOrientation.CCDeviceOrientationPortrait:
            //        ret = new CCPoint(obPoint.x, newY);
            //        break;
            //    case ccDeviceOrientation.CCDeviceOrientationPortraitUpsideDown:
            //        ret = new CCPoint(newX, obPoint.y);
            //        break;
            //    case ccDeviceOrientation.CCDeviceOrientationLandscapeLeft:
            //        ret.x = obPoint.y;
            //        ret.y = obPoint.x;
            //        break;
            //    case ccDeviceOrientation.CCDeviceOrientationLandscapeRight:
            //        ret.x = newY;
            //        ret.y = newX;
            //        break;
            //}

            //return ret;
        }

        /// <summary>
        /// converts an OpenGL coordinate to a UIKit coordinate
        /// Useful to convert node points to window points for calls such as glScissor
        /// </summary>
        /// <param name="obPoint"></param>
        /// <returns></returns>
        public CCPoint convertToUI(CCPoint obPoint)
        {
            CCSize winSize = m_obWinSizeInPoints;

            //this is different from cocos2d-win32
            return new CCPoint(obPoint.x, winSize.height - obPoint.y);

            //float oppositeX = winSize.width - obPoint.x;
            //float oppositeY = winSize.height - obPoint.y;
            //CCPoint uiPoint = new CCPoint();

            //switch (m_eDeviceOrientation)
            //{
            //    case ccDeviceOrientation.CCDeviceOrientationPortrait:
            //        uiPoint = new CCPoint(obPoint.x, oppositeY);
            //        break;
            //    case ccDeviceOrientation.CCDeviceOrientationPortraitUpsideDown:
            //        uiPoint = new CCPoint(oppositeX, obPoint.y);
            //        break;
            //    case ccDeviceOrientation.CCDeviceOrientationLandscapeLeft:
            //        uiPoint = new CCPoint(obPoint.y, obPoint.x);
            //        break;
            //    case ccDeviceOrientation.CCDeviceOrientationLandscapeRight:
            //        // Can't use oppositeX/Y because x/y are flipped
            //        uiPoint = new CCPoint(winSize.width - obPoint.y, winSize.height - obPoint.x);
            //        break;
            //}

            //return uiPoint;
        }

        /// XXX: missing description 
        public float zEye
        {
            get
            {
                return (m_obWinSizeInPixels.height / 1.1566f);
            }
        }

        /** Ends the execution, releases the running scene.
         It doesn't remove the OpenGL view from its parent. You have to do it manually.
         */

        /* end is key word of lua, use other name to export to lua. */
        public void endToLua()
        {
            end();
        }

        public void end()
        {
            m_bPurgeDirecotorInNextLoop = true;
        }

        /// <summary>
        /// Pauses the running scene.
        /// The running scene will be _drawed_ but all scheduled timers will be paused
        /// While paused, the draw rate will be 4 FPS to reduce CPU consumption
        /// </summary>
        public void pause()
        {
            if (m_bPaused)
            {
                return;
            }

            m_dOldAnimationInterval = m_dAnimationInterval;

            // when paused, don't consume CPU
            animationInterval = 1 / 4.0;
            m_bPaused = true;
        }

        /// <summary>
        /// Resumes the paused scene
        /// The scheduled timers will be activated again.
        /// The "delta time" will be 0 (as if the game wasn't paused)
        /// </summary>
        public void resume()
        {
            if (!m_bPaused)
            {
                return;
            }

            animationInterval = m_dOldAnimationInterval;

            //if (CCTime.gettimeofdayCocos2d(m_pLastUpdate, NULL) != 0)
            //{
            //    //CCLOG("cocos2d: Director: Error in gettimeofday");
            //}

            m_bPaused = false;
        }

        /// <summary>
        ///  Stops the animation. Nothing will be drawn. The main loop won't be triggered anymore.
        ///  If you don't want to pause your animation call [pause] instead.
        /// </summary>
        public abstract void stopAnimation();

        /// <summary>
        /// The main loop is triggered again.
        /// Call this function only if [stopAnimation] was called earlier
        /// warning Don't call this function to start the main loop. To run the main loop call runWithScene
        /// </summary>
        public abstract void startAnimation();

        // Memory Helper

        /// <summary>
        /// Removes cached all cocos2d cached data.
        /// It will purge the CCTextureCache, CCSpriteFrameCache, CCLabelBMFont cache
        /// @since v0.99.3
        /// </summary>
        public void purgeCachedData()
        {
            //CCLabelBMFont::purgeCachedData();
            //CCTextureCache::sharedTextureCache()->removeUnusedTextures();
        }

        #region OpenGL Helper

        /// <summary>
        /// sets the OpenGL default values
        /// </summary>
        public void setGLDefaultValues()
        {
            Projection = m_eProjection;
        }
        /// <summary>
        /// enables/disables OpenGL alpha blending 
        /// </summary>
        /// <param name="bOn"></param>
        public void setAlphaBlending(bool bOn)
        {
            //if (bOn)
            //{
            //    glEnable(GL_BLEND);
            //    glBlendFunc(CC_BLEND_SRC, CC_BLEND_DST);
            //}
            //else
            //{
            //    glDisable(GL_BLEND);
            //}
        }

        /// <summary>
        /// enables/disables OpenGL depth test
        /// </summary>
        /// <param name="bOn"></param>
        public void setDepthTest(bool bOn)
        {
            //if (bOn)
            //{
            //    ccglClearDepth(1.0f);
            //    glEnable(GL_DEPTH_TEST);
            //    glDepthFunc(GL_LEQUAL);
            //    //		glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);
            //}
            //else
            //{
            //    glDisable(GL_DEPTH_TEST);
            //}
        }

        public void setOpenGLView()
        {
            // set size
            m_obWinSizeInPoints = CCApplication.sharedApplication().getSize();
            m_obWinSizeInPixels = new CCSize(m_obWinSizeInPoints.width * m_fContentScaleFactor, m_obWinSizeInPoints.height * m_fContentScaleFactor);
            setGLDefaultValues();

            if (m_fContentScaleFactor != 1)
            {
                updateContentScaleFactor();
            }

            CCTouchDispatcher pTouchDispatcher = CCTouchDispatcher.sharedDispatcher();
            CCApplication.sharedApplication().TouchDelegate = pTouchDispatcher;
            pTouchDispatcher.IsDispatchEvents = true;
        }

        #endregion

        // Profiler
        public void showProfilers()
        {

        }

        /// <summary>
        /// rotates the screen if an orientation different than Portrait is used 
        /// </summary>
        public void applyOrientation()
        {
            //CCSize s = m_obWinSizeInPixels;
            //float w = s.width / 2;
            //float h = s.height / 2;

            // XXX it's using hardcoded values.
            // What if the the screen size changes in the future?
            switch (m_eDeviceOrientation)
            {
                case ccDeviceOrientation.CCDeviceOrientationPortrait:
                    // nothing
                    break;
                case ccDeviceOrientation.CCDeviceOrientationPortraitUpsideDown:
                    // upside down
                    //glTranslatef(w, h, 0);
                    //glRotatef(180, 0, 0, 1);
                    //glTranslatef(-w, -h, 0);
                    break;
                case ccDeviceOrientation.CCDeviceOrientationLandscapeRight:
                    //glTranslatef(w, h, 0);
                    //glRotatef(90, 0, 0, 1);
                    //glTranslatef(-h, -w, 0);
                    break;
                case ccDeviceOrientation.CCDeviceOrientationLandscapeLeft:
                    //glTranslatef(w, h, 0);
                    //glRotatef(-90, 0, 0, 1);
                    //glTranslatef(-h, -w, 0);
                    break;
            }
        }

        /// <summary>
        /// rotate the objects by engine.
        /// </summary>
        public ccDeviceOrientation deviceOrientation
        {
            get { return m_eDeviceOrientation; }
            set
            {
                Orientation eNewOrientation = CCApplication.sharedApplication().setOrientation((Orientation)((int)value));
                ccDeviceOrientation eNewDeviceOrientation = (ccDeviceOrientation)((int)eNewOrientation);

                if (m_eDeviceOrientation != eNewDeviceOrientation)
                {
                    m_eDeviceOrientation = eNewDeviceOrientation;

                    //added in cocos2d-xna
                    m_obWinSizeInPoints = CCApplication.sharedApplication().getSize();
                    m_obWinSizeInPixels = new CCSize(m_obWinSizeInPoints.width * m_fContentScaleFactor, m_obWinSizeInPoints.height * m_fContentScaleFactor);
                    Projection = m_eProjection;
                }
                else
                {
                    // this logic is only run on win32 now
                    // On win32,the return value of CCApplication::setDeviceOrientation is always kCCDeviceOrientationPortrait
                    // So,we should calculate the Projection and window size again.
                    m_obWinSizeInPoints = CCApplication.sharedApplication().getSize();
                    m_obWinSizeInPixels = new CCSize(m_obWinSizeInPoints.width * m_fContentScaleFactor, m_obWinSizeInPoints.height * m_fContentScaleFactor);
                    Projection = m_eProjection;
                }
            }
        }

        /// <summary>
        /// The size in pixels of the surface. It could be different than the screen size.
        /// High-res devices might have a higher surface size than the screen size.
        /// Only available when compiled using SDK >= 4.0.
        /// @since v0.99.4
        /// </summary>
        public float ContentScaleFactor
        {
            get { return m_fContentScaleFactor; }
            set
            {
                if (value != m_fContentScaleFactor)
                {
                    m_fContentScaleFactor = value;
                    m_obWinSizeInPixels = new CCSize(m_obWinSizeInPoints.width * value, m_obWinSizeInPoints.height * value);

                    updateContentScaleFactor();

                    // update projection
                    Projection = m_eProjection;
                }
            }
        }

        /// <summary>
        /// Will enable Retina Display on devices that supports it.
        /// It will enable Retina Display on iPhone4 and iPod Touch 4.
        /// It will return YES, if it could enabled it, otherwise it will return NO.
        /// This is the recommened way to enable Retina Display.
        /// @since v0.99.5
        /// </summary>
        public bool enableRetinaDisplay(bool enabled)
        {
            // Already enabled?
            if (enabled && m_fContentScaleFactor == 2)
            {
                return true;
            }

            // Already diabled?
            if (!enabled && m_fContentScaleFactor == 1)
            {
                return false;
            }

            // setContentScaleFactor is not supported
            if (!CCApplication.sharedApplication().canSetContentScaleFactor)
            {
                return false;
            }

            float newScale = (float)(enabled ? 2 : 1);
            CCApplication.sharedApplication().setContentScaleFactor(newScale);

            // release cached texture
            //CCTextureCache::purgeSharedTextureCache();

#if CC_DIRECTOR_FAST_FPS
            //if (m_pFPSLabel)
            //{
            //    CC_SAFE_RELEASE_NULL(m_pFPSLabel);
            //    m_pFPSLabel = CCLabelTTF::labelWithString("00.0", "Arial", 24);
            //    m_pFPSLabel->retain();
            //}
#endif

            if (m_fContentScaleFactor == 2)
            {
                m_bRetinaDisplay = true;
            }
            else
            {
                m_bRetinaDisplay = false;
            }

            return true;
        }
        public bool isRetinaDisplay()
        {
            return m_bRetinaDisplay;
        }
    }

    /// <summary>
    ///  Possible OpenGL projections used by director
    /// </summary>
    public enum ccDirectorProjection
    {
        /// sets a 2D projection (orthogonal projection)
        kCCDirectorProjection2D,

        /// sets a 3D projection with a fovy=60, znear=0.5f and zfar=1500.
        kCCDirectorProjection3D,

        /// it calls "updateProjection" on the projection delegate.
        kCCDirectorProjectionCustom,

        /// Detault projection is 3D projection
        kCCDirectorProjectionDefault = kCCDirectorProjection3D,

        // backward compatibility stuff
        CCDirectorProjection2D = kCCDirectorProjection2D,
        CCDirectorProjection3D = kCCDirectorProjection3D,
        CCDirectorProjectionCustom = kCCDirectorProjectionCustom
    }

    /// <summary>
    /// Possible Director Types.
    /// since v0.8.2
    /// </summary>
    public enum ccDirectorType
    {
        /** Will use a Director that triggers the main loop from an NSTimer object
         *
         * Features and Limitations:
         * - Integrates OK with UIKit objects
         * - It the slowest director
         * - The interval update is customizable from 1 to 60
         */
        kCCDirectorTypeNSTimer,

        /** will use a Director that triggers the main loop from a custom main loop.
         *
         * Features and Limitations:
         * - Faster than NSTimer Director
         * - It doesn't integrate well with UIKit objects
         * - The interval update can't be customizable
         */
        kCCDirectorTypeMainLoop,

        /** Will use a Director that triggers the main loop from a thread, but the main loop will be executed on the main thread.
         *
         * Features and Limitations:
         * - Faster than NSTimer Director
         * - It doesn't integrate well with UIKit objects
         * - The interval update can't be customizable
         */
        kCCDirectorTypeThreadMainLoop,

        /** Will use a Director that synchronizes timers with the refresh rate of the display.
         *
         * Features and Limitations:
         * - Faster than NSTimer Director
         * - Only available on 3.1+
         * - Scheduled timers & drawing are synchronizes with the refresh rate of the display
         * - Integrates OK with UIKit objects
         * - The interval update can be 1/60, 1/30, 1/15
         */
        kCCDirectorTypeDisplayLink,

        /** Default director is the NSTimer directory */
        kCCDirectorTypeDefault = kCCDirectorTypeNSTimer,

        // backward compatibility stuff
        CCDirectorTypeNSTimer = kCCDirectorTypeNSTimer,
        CCDirectorTypeMainLoop = kCCDirectorTypeMainLoop,
        CCDirectorTypeThreadMainLoop = kCCDirectorTypeThreadMainLoop,
        CCDirectorTypeDisplayLink = kCCDirectorTypeDisplayLink,
        CCDirectorTypeDefault = kCCDirectorTypeDefault
    }

    /// <summary>
    /// Possible device orientations
    /// </summary>
    public enum ccDeviceOrientation
    {
        /// Device oriented vertically, home button on the bottom
        kCCDeviceOrientationPortrait = 0, // UIDeviceOrientationPortrait,	
        /// Device oriented vertically, home button on the top
        kCCDeviceOrientationPortraitUpsideDown = 1, // UIDeviceOrientationPortraitUpsideDown,
        /// Device oriented horizontally, home button on the right
        kCCDeviceOrientationLandscapeLeft = 2, // UIDeviceOrientationLandscapeLeft,
        /// Device oriented horizontally, home button on the left
        kCCDeviceOrientationLandscapeRight = 3, // UIDeviceOrientationLandscapeRight,

        // Backward compatibility stuff
        CCDeviceOrientationPortrait = kCCDeviceOrientationPortrait,
        CCDeviceOrientationPortraitUpsideDown = kCCDeviceOrientationPortraitUpsideDown,
        CCDeviceOrientationLandscapeLeft = kCCDeviceOrientationLandscapeLeft,
        CCDeviceOrientationLandscapeRight = kCCDeviceOrientationLandscapeRight
    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace cocos2d
{
    public class CCFileData
    {
        protected byte[] m_pBuffer;
        public byte[] Buffer
        {
            get { return m_pBuffer; }
        }

        protected UInt64 m_uSize;
        public UInt64 Size
        {
            get { return m_uSize; }
        }

        public CCFileData(string pszFileName, string pszMode)
        {
            //m_pBuffer = CCFileUtils.getFileData(pszFileName, pszMode, m_uSize);
        }

        public bool reset(string pszFileName, string pszMode)
        {
            m_pBuffer = null;
            m_uSize = 0;
            //m_pBuffer = CCFileUtils.getFileData(pszFileName, pszMode, m_uSize);
            return (m_pBuffer != null) ? true : false;
        }
    }
}

/****************************************************************************
Copyright (c) 2010-2012 cocos2d-x.org
Copyright (c) 2008-2011 Ricardo Quesada
Copyright (c) 2011      Zynga Inc.
Copyright (c) 2011-2012 openxlive.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
****************************************************************************/
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using Microsoft.Xna.Framework.Graphics;

namespace cocos2d
{
    /// <summary>
    /// CCProgresstimer is a subclass of CCNode.
    /// It renders the inner sprite according to the percentage.
    /// The progress can be Radial, Horizontal or vertical.
    /// @since v0.99.1
    /// </summary>
    public class CCProgressTimer : CCNode
    {
        private const int kProgressTextureCoordsCount = 4;
        const int kProgressTextureCoords = 0x1e;

        #region properties

        /// <summary>
        /// Change the percentage to change progress.
        /// </summary>
        public CCProgressTimerType Type
        {
            get { return m_eType; }
            set
            {
                if (value != m_eType)
                {
                    //	release all previous information
                    if (m_pVertexData == null)
                    {
                        // delete[] m_pVertexData;
                        m_pVertexData = null;
                        m_nVertexDataCount = 0;
                    }

                    m_eType = value;
                }
            }
        }

        /// <summary>
        /// Percentages are from 0 to 100
        /// </summary>
        public float Percentage
        {
            get { return m_fPercentage; }
            set
            {
                if (m_fPercentage != value)
                {
                    m_fPercentage = CCPointExtension.clampf(value, 0, 100);
                    updateProgress();
                }
            }
        }

        /// <summary>
        /// The image to show the progress percentage, retain
        /// </summary>
        public CCSprite Sprite
        {
            get { return m_pSprite; }
            set
            {
                if (m_pSprite != value)
                {
                    m_pSprite = value;
                    contentSize = m_pSprite.contentSize;

                    //	Everytime we set a new sprite, we free the current vertex data
                    if (m_pVertexData != null)
                    {
                        m_pVertexData = null;
                        m_nVertexDataCount = 0;
                    }
                }
            }
        }

        #endregion

        #region init

        public static CCProgressTimer progressWithFile(string pszFileName)
        {
            CCProgressTimer pProgressTimer = new CCProgressTimer();
            if (pProgressTimer.initWithFile(pszFileName))
            {
                return pProgressTimer;
            }

            return null;
        }

        public static CCProgressTimer progressWithTexture(CCTexture2D pTexture)
        {
            CCProgressTimer pProgressTimer = new CCProgressTimer();
            if (pProgressTimer.initWithTexture(pTexture))
            {
                return pProgressTimer;
            }

            return null;
        }

        public bool initWithFile(string pszFileName)
        {
            return this.initWithTexture(CCTextureCache.sharedTextureCache().addImage(pszFileName));
        }

        public bool initWithTexture(CCTexture2D pTexture)
        {
            m_pSprite = CCSprite.spriteWithTexture(pTexture);
            m_fPercentage = 0;
            m_pVertexData = null;
            m_nVertexDataCount = 0;
            anchorPoint = new CCPoint(0.5f, 0.5f);
            contentSize = m_pSprite.contentSize;
            m_eType = CCProgressTimerType.kCCProgressTimerTypeRadialCCW;

            return true;
        }

        #endregion

        private void getIndexes()
        {
            if (indexes == null)
            {
                switch (m_eType)
                {
                    case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:
                        indexes = new short[15];

                        indexes[0] = 1;
                        indexes[1] = 0;
                        indexes[2] = 2;

                        indexes[3] = 2;
                        indexes[4] = 0;
                        indexes[5] = 3;

                        indexes[6] = 3;
                        indexes[7] = 0;
                        indexes[8] = 4;

                        indexes[9] = 4;
                        indexes[10] = 0;
                        indexes[11] = 5;

                        indexes[12] = 5;
                        indexes[13] = 0;
                        indexes[14] = 6;

                        break;
                    case CCProgressTimerType.kCCProgressTimerTypeRadialCW:
                        indexes = new short[15];
                        indexes[0] = 0;
                        indexes[1] = 1;
                        indexes[2] = 2;

                        indexes[3] = 0;
                        indexes[4] = 2;
                        indexes[5] = 3;

                        indexes[6] = 0;
                        indexes[7] = 3;
                        indexes[8] = 4;

                        indexes[9] = 0;
                        indexes[10] = 4;
                        indexes[11] = 5;

                        indexes[12] = 0;
                        indexes[13] = 5;
                        indexes[14] = 6;

                        break;
                    case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:
                        indexes = new short[6];
                        indexes[0] = 0;
                        indexes[1] = 1;
                        indexes[2] = 2;
                        indexes[3] = 2;
                        indexes[4] = 1;
                        indexes[5] = 3;
                        break;

                    case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:
                        indexes = new short[6];
                        indexes[0] = 1;
                        indexes[1] = 0;
                        indexes[2] = 2;
                        indexes[3] = 1;
                        indexes[4] = 2;
                        indexes[5] = 3;

                        break;

                    case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:
                        indexes = new short[6];
                        indexes[0] = 1;
                        indexes[1] = 0;
                        indexes[2] = 2;
                        indexes[3] = 1;
                        indexes[4] = 2;
                        indexes[5] = 3;

                        break;

                    case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:
                        indexes = new short[6];
                        indexes[0] = 1;
                        indexes[1] = 0;
                        indexes[2] = 2;
                        indexes[3] = 1;
                        indexes[4] = 2;
                        indexes[5] = 3;
                        break;
                }
            }
        }

        public override void draw()
        {
            base.draw();

            if (m_pVertexData == null)
            {
                return;
            }

            if (m_pSprite == null)
            {
                return;
            }

            vertices = new VertexPositionColorTexture[m_pVertexData.Length];
            getIndexes();

            for (int i = 0; i < m_pVertexData.Length; i++)
            {
                ccV2F_C4B_T2F temp = m_pVertexData[i];

                vertices[i] = new VertexPositionColorTexture(
                    new Microsoft.Xna.Framework.Vector3(temp.vertices.x, temp.vertices.y, 0),
                    new Microsoft.Xna.Framework.Color(temp.colors.r, temp.colors.g, temp.colors.b, temp.colors.a),
                    new Microsoft.Xna.Framework.Vector2(temp.texCoords.u, temp.texCoords.v));
            }

            CCApplication app = CCApplication.sharedApplication();

            app.basicEffect.Texture = m_pSprite.Texture.getTexture2D();
            app.basicEffect.TextureEnabled = true;

            VertexDeclaration vertexDeclaration = new VertexDeclaration(new VertexElement[]
                {
                    new VertexElement(0, VertexElementFormat.Vector3, VertexElementUsage.Position, 0),
                    new VertexElement(12, VertexElementFormat.Vector3, VertexElementUsage.Color, 0),
                    new VertexElement(24, VertexElementFormat.Vector2, VertexElementUsage.TextureCoordinate, 0)
                });

            foreach (var pass in app.basicEffect.CurrentTechnique.Passes)
            {
                pass.Apply();

                app.GraphicsDevice.DrawUserIndexedPrimitives<VertexPositionColorTexture>(
                    PrimitiveType.TriangleList,
                    vertices, 0, m_nVertexDataCount,
                    indexes, 0, m_nVertexDataCount - 2);
            }
        }

        /// <summary>
        /// the vertex position from the texture coordinate
        /// </summary>
        protected ccVertex2F vertexFromTexCoord(CCPoint texCoord)
        {
            CCPoint tmp;
            ccVertex2F ret = new ccVertex2F();

            CCTexture2D pTexture = m_pSprite.Texture;
            if (pTexture != null)
            {
                float fXMax = Math.Max(m_pSprite.quad.br.texCoords.u, m_pSprite.quad.bl.texCoords.u);
                float fXMin = Math.Min(m_pSprite.quad.br.texCoords.u, m_pSprite.quad.bl.texCoords.u);
                float fYMax = Math.Max(m_pSprite.quad.tl.texCoords.v, m_pSprite.quad.bl.texCoords.v);
                float fYMin = Math.Min(m_pSprite.quad.tl.texCoords.v, m_pSprite.quad.bl.texCoords.v);
                CCPoint tMax = new CCPoint(fXMax, fYMax);
                CCPoint tMin = new CCPoint(fXMin, fYMin);

                CCSize texSize = new CCSize(m_pSprite.quad.br.vertices.x - m_pSprite.quad.bl.vertices.x,
                                            m_pSprite.quad.tl.vertices.y - m_pSprite.quad.bl.vertices.y);
                tmp = new CCPoint(texSize.width * (texCoord.x - tMin.x) / (tMax.x - tMin.x),
                            texSize.height * (1 - (texCoord.y - tMin.y) / (tMax.y - tMin.y)));
            }
            else
            {
                tmp = new CCPoint(0, 0);
            }

            ret.x = tmp.x;
            ret.y = tmp.y;
            return ret;
        }

        protected void updateProgress()
        {
            switch (m_eType)
            {
                case CCProgressTimerType.kCCProgressTimerTypeRadialCW:
                case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:
                    updateRadial();
                    break;
                case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:
                case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:
                case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:
                case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:
                    updateBar();
                    break;
                default:
                    break;
            }
        }

        /// <summary>
        /// Update does the work of mapping the texture onto the triangles for the bar
        //	It now doesn't occur the cost of free/alloc data every update cycle.
        //	It also only changes the percentage point but no other points if they have not
        //	been modified.
        //	
        //	It now deals with flipped texture. If you run into this problem, just use the
        //	sprite property and enable the methods flipX, flipY.
        /// </summary>
        protected void updateBar()
        {
            float alpha = m_fPercentage / 100.0f;

            float fXMax = Math.Max(m_pSprite.quad.br.texCoords.u, m_pSprite.quad.bl.texCoords.u);
            float fXMin = Math.Min(m_pSprite.quad.br.texCoords.u, m_pSprite.quad.bl.texCoords.u);
            float fYMax = Math.Max(m_pSprite.quad.tl.texCoords.v, m_pSprite.quad.bl.texCoords.v);
            float fYMin = Math.Min(m_pSprite.quad.tl.texCoords.v, m_pSprite.quad.bl.texCoords.v);
            CCPoint tMax = new CCPoint(fXMax, fYMax);
            CCPoint tMin = new CCPoint(fXMin, fYMin);

            int[] vIndexes = new int[2] { 0, 0 };
            int index = 0;

            //	We know vertex data is always equal to the 4 corners
            //	If we don't have vertex data then we create it here and populate
            //	the side of the bar vertices that won't ever change.
            if (m_pVertexData == null)
            {
                m_nVertexDataCount = kProgressTextureCoordsCount;
                m_pVertexData = new ccV2F_C4B_T2F[m_nVertexDataCount];
                for (int i = 0; i < m_nVertexDataCount; i++)
                {
                    m_pVertexData[i] = new ccV2F_C4B_T2F();
                }


                Debug.Assert(m_pVertexData != null);

                if (m_eType == CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR)
                {
                    m_pVertexData[vIndexes[0] = 0].texCoords = new ccTex2F(tMin.x, tMin.y);
                    m_pVertexData[vIndexes[1] = 1].texCoords = new ccTex2F(tMin.x, tMax.y);
                }
                else
                    if (m_eType == CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL)
                    {
                        m_pVertexData[vIndexes[0] = 2].texCoords = new ccTex2F(tMax.x, tMax.y);
                        m_pVertexData[vIndexes[1] = 3].texCoords = new ccTex2F(tMax.x, tMin.y);
                    }
                    else
                        if (m_eType == CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT)
                        {
                            m_pVertexData[vIndexes[0] = 1].texCoords = new ccTex2F(tMin.x, tMax.y);
                            m_pVertexData[vIndexes[1] = 3].texCoords = new ccTex2F(tMax.x, tMax.y);
                        }
                        else
                            if (m_eType == CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB)
                            {
                                m_pVertexData[vIndexes[0] = 0].texCoords = new ccTex2F(tMin.x, tMin.y);
                                m_pVertexData[vIndexes[1] = 2].texCoords = new ccTex2F(tMax.x, tMin.y);
                            }

                index = vIndexes[0];
                m_pVertexData[index].vertices = vertexFromTexCoord(new CCPoint(m_pVertexData[index].texCoords.u,
                                                                       m_pVertexData[index].texCoords.v));

                index = vIndexes[1];
                m_pVertexData[index].vertices = vertexFromTexCoord(new CCPoint(m_pVertexData[index].texCoords.u,
                                                                       m_pVertexData[index].texCoords.v));

                if (m_pSprite.IsFlipY || m_pSprite.IsFlipX)
                {
                    if (m_pSprite.IsFlipX)
                    {
                        index = vIndexes[0];
                        m_pVertexData[index].texCoords.u = tMin.x + tMax.x - m_pVertexData[index].texCoords.u;
                        index = vIndexes[1];
                        m_pVertexData[index].texCoords.u = tMin.x + tMax.x - m_pVertexData[index].texCoords.u;
                    }

                    if (m_pSprite.IsFlipY)
                    {
                        index = vIndexes[0];
                        m_pVertexData[index].texCoords.v = tMin.y + tMax.y - m_pVertexData[index].texCoords.v;
                        index = vIndexes[1];
                        m_pVertexData[index].texCoords.v = tMin.y + tMax.y - m_pVertexData[index].texCoords.v;
                    }
                }

                updateColor();
            }

            if (m_eType == CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR)
            {
                m_pVertexData[vIndexes[0] = 3].texCoords = new ccTex2F(tMin.x + (tMax.x - tMin.x) * alpha, tMax.y);
                m_pVertexData[vIndexes[1] = 2].texCoords = new ccTex2F(tMin.x + (tMax.x - tMin.x) * alpha, tMin.y);
            }
            else
                if (m_eType == CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL)
                {
                    m_pVertexData[vIndexes[0] = 1].texCoords = new ccTex2F(tMin.x + (tMax.x - tMin.x) * (1.0f - alpha), tMin.y);
                    m_pVertexData[vIndexes[1] = 0].texCoords = new ccTex2F(tMin.x + (tMax.x - tMin.x) * (1.0f - alpha), tMax.y);
                }
                else
                    if (m_eType == CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT)
                    {
                        m_pVertexData[vIndexes[0] = 0].texCoords = new ccTex2F(tMin.x, tMin.y + (tMax.y - tMin.y) * (1.0f - alpha));
                        m_pVertexData[vIndexes[1] = 2].texCoords = new ccTex2F(tMax.x, tMin.y + (tMax.y - tMin.y) * (1.0f - alpha));
                    }
                    else
                        if (m_eType == CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB)
                        {
                            m_pVertexData[vIndexes[0] = 1].texCoords = new ccTex2F(tMin.x, tMin.y + (tMax.y - tMin.y) * alpha);
                            m_pVertexData[vIndexes[1] = 3].texCoords = new ccTex2F(tMax.x, tMin.y + (tMax.y - tMin.y) * alpha);
                        }

            index = vIndexes[0];
            m_pVertexData[index].vertices = vertexFromTexCoord(new CCPoint(m_pVertexData[index].texCoords.u,
                                                                   m_pVertexData[index].texCoords.v));
            index = vIndexes[1];
            m_pVertexData[index].vertices = vertexFromTexCoord(new CCPoint(m_pVertexData[index].texCoords.u,
                                                                   m_pVertexData[index].texCoords.v));

            if (m_pSprite.IsFlipY || m_pSprite.IsFlipX)
            {
                if (m_pSprite.IsFlipX)
                {
                    index = vIndexes[0];
                    m_pVertexData[index].texCoords.u = tMin.x + tMax.x - m_pVertexData[index].texCoords.u;
                    index = vIndexes[1];
                    m_pVertexData[index].texCoords.u = tMin.x + tMax.x - m_pVertexData[index].texCoords.u;
                }

                if (m_pSprite.IsFlipY)
                {
                    index = vIndexes[0];
                    m_pVertexData[index].texCoords.v = tMin.y + tMax.y - m_pVertexData[index].texCoords.v;
                    index = vIndexes[1];
                    m_pVertexData[index].texCoords.v = tMin.y + tMax.y - m_pVertexData[index].texCoords.v;
                }
            }
        }

        /// <summary>
        /// Update does the work of mapping the texture onto the triangles
        //	It now doesn't occur the cost of free/alloc data every update cycle.
        //	It also only changes the percentage point but no other points if they have not
        //	been modified.
        //	
        //	It now deals with flipped texture. If you run into this problem, just use the
        //	sprite property and enable the methods flipX, flipY.
        /// </summary>
        protected void updateRadial()
        {
            //	Texture Max is the actual max coordinates to deal with non-power of 2 textures
            float fXMax = Math.Max(m_pSprite.quad.br.texCoords.u, m_pSprite.quad.bl.texCoords.u);
            float fXMin = Math.Min(m_pSprite.quad.br.texCoords.u, m_pSprite.quad.bl.texCoords.u);
            float fYMax = Math.Max(m_pSprite.quad.tl.texCoords.v, m_pSprite.quad.bl.texCoords.v);
            float fYMin = Math.Min(m_pSprite.quad.tl.texCoords.v, m_pSprite.quad.bl.texCoords.v);
            CCPoint tMax = new CCPoint(fXMax, fYMax);
            CCPoint tMin = new CCPoint(fXMin, fYMin);

            //	Grab the midpoint
            CCPoint midpoint = CCPointExtension.ccpAdd(tMin, CCPointExtension.ccpCompMult(m_tAnchorPoint, CCPointExtension.ccpSub(tMax, tMin)));

            float alpha = m_fPercentage / 100.0f;

            //	Otherwise we can get the angle from the alpha
            float angle = 2.0f * ((float)Math.PI) * (m_eType == CCProgressTimerType.kCCProgressTimerTypeRadialCW ? alpha : 1.0f - alpha);

            //	We find the vector to do a hit detection based on the percentage
            //	We know the first vector is the one @ 12 o'clock (top,mid) so we rotate 
            //	from that by the progress angle around the midpoint pivot
            CCPoint topMid = new CCPoint(midpoint.x, tMin.y);
            CCPoint percentagePt = CCPointExtension.ccpRotateByAngle(topMid, midpoint, angle);

            int index = 0;
            CCPoint hit = new CCPoint();

            if (alpha == 0.0f)
            {
                //	More efficient since we don't always need to check intersection
                //	If the alpha is zero then the hit point is top mid and the index is 0.
                hit = topMid;
                index = 0;
            }
            else
                if (alpha == 1.0f)
                {
                    //	More efficient since we don't always need to check intersection
                    //	If the alpha is one then the hit point is top mid and the index is 4.
                    hit = topMid;
                    index = 4;
                }
                else
                {
                    //	We run a for loop checking the edges of the texture to find the
                    //	intersection point
                    //	We loop through five points since the top is split in half

                    float min_t = float.MaxValue;

                    for (int i = 0; i <= kProgressTextureCoordsCount; ++i)
                    {
                        int pIndex = (i + (kProgressTextureCoordsCount - 1)) % kProgressTextureCoordsCount;

                        CCPoint edgePtA = CCPointExtension.ccpAdd(tMin, CCPointExtension.ccpCompMult(boundaryTexCoord(i % kProgressTextureCoordsCount), CCPointExtension.ccpSub(tMax, tMin)));
                        CCPoint edgePtB = CCPointExtension.ccpAdd(tMin, CCPointExtension.ccpCompMult(boundaryTexCoord(pIndex), CCPointExtension.ccpSub(tMax, tMin)));

                        //	Remember that the top edge is split in half for the 12 o'clock position
                        //	Let's deal with that here by finding the correct endpoints
                        if (i == 0)
                        {
                            edgePtB = CCPointExtension.ccpLerp(edgePtA, edgePtB, 0.5f);
                        }
                        else
                            if (i == 4)
                            {
                                edgePtA = CCPointExtension.ccpLerp(edgePtA, edgePtB, 0.5f);
                            }

                        //	s and t are returned by ccpLineIntersect
                        float s = 0;
                        float t = 0;
                        if (CCPointExtension.ccpLineIntersect(edgePtA, edgePtB, midpoint, percentagePt, ref s, ref t))
                        {
                            //	Since our hit test is on rays we have to deal with the top edge
                            //	being in split in half so we have to test as a segment
                            if (i == 0 || i == 4)
                            {
                                //	s represents the point between edgePtA--edgePtB
                                if (!(0.0f <= s && s <= 1.0f))
                                {
                                    continue;
                                }
                            }

                            //	As long as our t isn't negative we are at least finding a 
                            //	correct hitpoint from midpoint to percentagePt.
                            if (t >= 0.0f)
                            {
                                //	Because the percentage line and all the texture edges are
                                //	rays we should only account for the shortest intersection
                                if (t < min_t)
                                {
                                    min_t = t;
                                    index = i;
                                }
                            }
                        }

                    }

                    //	Now that we have the minimum magnitude we can use that to find our intersection
                    hit = CCPointExtension.ccpAdd(midpoint, CCPointExtension.ccpMult(CCPointExtension.ccpSub(percentagePt, midpoint), min_t));
                }

            //	The size of the vertex data is the index from the hitpoint
            //	the 3 is for the midpoint, 12 o'clock point and hitpoint position.

            bool sameIndexCount = true;
            if (m_nVertexDataCount != index + 3)
            {
                sameIndexCount = false;
                if (m_pVertexData != null)
                {
                    m_pVertexData = null;
                    m_nVertexDataCount = 0;
                }
            }

            if (m_pVertexData == null)
            {
                m_nVertexDataCount = index + 3;
                m_pVertexData = new ccV2F_C4B_T2F[m_nVertexDataCount];
                for (int i = 0; i < m_nVertexDataCount; i++)
                {
                    m_pVertexData[i] = new ccV2F_C4B_T2F();
                }


                Debug.Assert(m_pVertexData != null);

                updateColor();
            }

            if (!sameIndexCount)
            {
                //	First we populate the array with the midpoint, then all 
                //	vertices/texcoords/colors of the 12 'o clock start and edges and the hitpoint
                m_pVertexData[0].texCoords = new ccTex2F(midpoint.x, midpoint.y);
                m_pVertexData[0].vertices = vertexFromTexCoord(midpoint);

                m_pVertexData[1].texCoords = new ccTex2F(midpoint.x, tMin.y);
                m_pVertexData[1].vertices = vertexFromTexCoord(new CCPoint(midpoint.x, tMin.y));

                for (int i = 0; i < index; ++i)
                {
                    CCPoint texCoords = CCPointExtension.ccpAdd(tMin, CCPointExtension.ccpCompMult(boundaryTexCoord(i), CCPointExtension.ccpSub(tMax, tMin)));

                    m_pVertexData[i + 2].texCoords = new ccTex2F(texCoords.x, texCoords.y);
                    m_pVertexData[i + 2].vertices = vertexFromTexCoord(texCoords);
                }

                //	Flip the texture coordinates if set
                if (m_pSprite.IsFlipX || m_pSprite.IsFlipY)
                {
                    for (int i = 0; i < m_nVertexDataCount - 1; ++i)
                    {
                        if (m_pSprite.IsFlipX)
                        {
                            m_pVertexData[i].texCoords.u = tMin.x + tMax.x - m_pVertexData[i].texCoords.u;
                        }

                        if (m_pSprite.IsFlipY)
                        {
                            m_pVertexData[i].texCoords.v = tMin.y + tMax.y - m_pVertexData[i].texCoords.v;
                        }
                    }
                }
            }

            //	hitpoint will go last
            m_pVertexData[m_nVertexDataCount - 1].texCoords = new ccTex2F(hit.x, hit.y);
            m_pVertexData[m_nVertexDataCount - 1].vertices = vertexFromTexCoord(hit);

            if (m_pSprite.IsFlipX || m_pSprite.IsFlipY)
            {
                if (m_pSprite.IsFlipX)
                {
                    m_pVertexData[m_nVertexDataCount - 1].texCoords.u = tMin.x + tMax.x - m_pVertexData[m_nVertexDataCount - 1].texCoords.u;
                }

                if (m_pSprite.IsFlipY)
                {
                    m_pVertexData[m_nVertexDataCount - 1].texCoords.v = tMin.y + tMax.y - m_pVertexData[m_nVertexDataCount - 1].texCoords.v;
                }
            }
        }

        protected void updateColor()
        {
            byte op = m_pSprite.Opacity;
            ccColor3B c3b = m_pSprite.Color;

            ccColor4B color = new ccColor4B { r = c3b.r, g = c3b.g, b = c3b.b, a = op };
            if (m_pSprite.Texture.HasPremultipliedAlpha)
            {
                color.r *= (byte)(op / 255);
                color.g *= (byte)(op / 255);
                color.b *= (byte)(op / 255);
            }

            if (m_pVertexData != null)
            {
                for (int i = 0; i < m_nVertexDataCount; ++i)
                {
                    m_pVertexData[i].colors = color;
                }
            }
        }

        protected CCPoint boundaryTexCoord(int index)
        {
            if (index < kProgressTextureCoordsCount)
            {
                switch (m_eType)
                {
                    case CCProgressTimerType.kCCProgressTimerTypeRadialCW:
                        return new CCPoint((float)((kProgressTextureCoords >> ((index << 1) + 1)) & 1), (float)((kProgressTextureCoords >> (index << 1)) & 1));
                    case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:
                        return new CCPoint((float)((kProgressTextureCoords >> (7 - (index << 1))) & 1), (float)((kProgressTextureCoords >> (7 - ((index << 1) + 1))) & 1));
                    default:
                        break;
                }
            }

            return new CCPoint(0, 0);
        }

        protected CCProgressTimerType m_eType;
        protected float m_fPercentage;
        protected CCSprite m_pSprite;
        protected int m_nVertexDataCount;
        protected ccV2F_C4B_T2F[] m_pVertexData;
        protected VertexPositionColorTexture[] vertices;
        protected short[] indexes;
    }

    /// <summary>
    /// Types of progress
    /// @since v0.99.1
    /// </summary>
    public enum CCProgressTimerType
    {
        /// Radial Counter-Clockwise 
        kCCProgressTimerTypeRadialCCW,
        /// Radial ClockWise
        kCCProgressTimerTypeRadialCW,
        /// Horizontal Left-Right
        kCCProgressTimerTypeHorizontalBarLR,
        /// Horizontal Right-Left
        kCCProgressTimerTypeHorizontalBarRL,
        /// Vertical Bottom-top
        kCCProgressTimerTypeVerticalBarBT,
        /// Vertical Top-Bottom
        kCCProgressTimerTypeVerticalBarTB,
    }
}

using System;
using System.Collections.Generic;
using System.Linq;

using UnityEngine;

namespace KMP
{
    internal class KMPChatDisplay
    {
        public struct ChatLine
        {
            public String message;
            public Color color;

            public ChatLine(String message)
            {
                this.message = message;
                color = Color.white;
            }
        }

        public const float WINDOW_WIDTH_NORMAL = 320;
        public const float WINDOW_WIDTH_WIDE = 440;
        public const float WINDOW_HEIGHT = 360;
        public const int MAX_CHAT_OUT_QUEUE = 4;
        public const int MAX_CHAT_LINES = 16;
        public const int MAX_CHAT_LINE_LENGTH = 128;
        public const float NAME_COLOR_SATURATION_FACTOR = 0.35f;
        //public static GUILayoutOption[] layoutOptions;

        public static bool displayCommands = false;
        public static Rect windowPos = new Rect(Screen.width - WINDOW_WIDTH_NORMAL - 8, Screen.height / 2 - WINDOW_HEIGHT / 2, WINDOW_WIDTH_NORMAL, WINDOW_HEIGHT);
        public static Vector2 scrollPos = Vector2.zero;

        public static float windowWidth
        {
            get
            {
                if (KMPGlobalSettings.instance.chatWindowWide)
                    return WINDOW_WIDTH_WIDE;
                else
                    return WINDOW_WIDTH_NORMAL;
            }
        }

        public static Queue<ChatLine> chatLineQueue = new Queue<ChatLine>();
        public static String chatEntryString = String.Empty;

        public static void enqueueChatLine(String line)
        {
            ChatLine chat_line = new ChatLine(line);

            //Check if the message has a name
            if (line.Length > 3 && line.First() == '[')
            {
                int name_length = line.IndexOf(']');
                if (name_length > 0)
                {
                    name_length = name_length - 1;
                    String name = line.Substring(1, name_length);
                    if (name == "Server")
                        chat_line.color = new Color(0.65f, 1.0f, 1.0f);
                    else chat_line.color = KMPVessel.generateActiveColor(name) * NAME_COLOR_SATURATION_FACTOR
                        + Color.white * (1.0f - NAME_COLOR_SATURATION_FACTOR);
                }
            }

            chatLineQueue.Enqueue(chat_line);
            while (chatLineQueue.Count > MAX_CHAT_LINES)
                chatLineQueue.Dequeue();
            scrollPos.y += 100;
        }
    }
}

#include <stdio.h>
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>


int main(int argc, char *argv[])
{
  int port, sockfd;
  struct hostent *server;
  struct sockaddr_in serv_addr;
  char buf[256];
  int size;
  char *ret;
  
  if (argc < 3)
  {
    fprintf(stderr, "usage is %s hostname port", argv[0]);
    return 1;
  }
  
  port = atoi(argv[2]);
  server = gethostbyname(argv[1]);
  if (server == NULL)
  {
    fprintf(stderr, "no such host", argv[0]);
    return 1;
  }
  
  sockfd = socket(AF_INET, SOCK_STREAM, 0);
  bzero((char *) &serv_addr, sizeof(serv_addr));
  serv_addr.sin_family = AF_INET;
  bcopy((char *)server->h_addr,
        (char *)&serv_addr.sin_addr.s_addr,
        server->h_length);
  serv_addr.sin_port = htons(port);
  
  if (connect(sockfd,&serv_addr,sizeof(serv_addr)) < 0)
  {
    fprintf(stderr, "error connecting", argv[0]);
    return 1;
  }
  
  while (!feof(stdin) && !ferror(stdin))
  {
    size = fread(buf, 1, sizeof(buf), stdin);
    send(sockfd, buf, size, 0);
    fwrite(buf, 1, size, stdout);
    if (size < sizeof(buf))
      break;
  }
  
  shutdown(sockfd, SHUT_RDWR);
  close(sockfd);
  
  return 0;
}

/* GoomwWM, Get out of my way, Window Manager!

MIT/X11 License
Copyright (c) 2012 Sean Pringle <sean.pringle@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

// manipulate client _NET_WM_STATE_*

void client_flush_state(client *c)
{
	window_set_atom_prop(c->window, netatoms[_NET_WM_STATE], c->state, c->states);
}

int client_has_state(client *c, Atom state)
{
	int i; for (i = 0; i < c->states; i++) if (c->state[i] == state) return 1;
	return 0;
}

void client_add_state(client *c, Atom state)
{
	if (c->states < CLIENTSTATE && !client_has_state(c, state))
	{
		c->state[c->states++] = state;
		client_flush_state(c);
	}
}

void client_remove_state(client *c, Atom state)
{
	if (!client_has_state(c, state)) return;
	Atom newstate[CLIENTSTATE]; int i, n;
	for (i = 0, n = 0; i < c->states; i++) if (c->state[i] != state) newstate[n++] = c->state[i];
	memmove(c->state, newstate, sizeof(Atom)*n); c->states = n;
	client_flush_state(c);
}

void client_remove_all_states(client *c)
{
	memset(&c->state, 0, sizeof(Atom)*CLIENTSTATE);
	c->states = 0; client_flush_state(c);
}

void client_set_state(client *c, Atom state, int on)
{
	if (on) client_add_state(c, state); else client_remove_state(c, state);
}

// extend client data
void client_descriptive_data(client *c)
{
	if (!c || c->is_described) return;

	char *name;
	if ((name = window_get_text_prop(c->window, netatoms[_NET_WM_NAME])) && name)
		c->title = name;
	else
	if (XFetchName(display, c->window, &name))
	{
		c->title = strdup(name);
		XFree(name);
	}
	XClassHint chint;
	if (XGetClassHint(display, c->window, &chint))
	{
		c->class = strdup(chint.res_class);
		c->name  = strdup(chint.res_name);
		XFree(chint.res_class); XFree(chint.res_name);
	}
	c->is_described = 1;
}

// extend client data
// necessary for anything that is going to move/resize/stack, but expensive to do
// every time in client_create()
void client_extended_data(client *c)
{
	if (!c || c->is_extended) return;

	long sr; XGetWMNormalHints(display, c->window, &c->xsize, &sr);
	monitor_dimensions_struts(c->x+c->w/2, c->y+c->h/2, &c->monitor);

	int screen_x = c->monitor.x, screen_y = c->monitor.y;
	int screen_width = c->monitor.w, screen_height = c->monitor.h;
	int vague = MAX(screen_width/100, screen_height/100);

	// window co-ords translated to 0-based on screen
	// co-ords are x,y upper left outsize border, w,h inside border
	int x = c->xattr.x - screen_x - c->border_width;
	int y = c->xattr.y - screen_y - c->border_width - c->titlebar_height;
	int w = c->xattr.width  + c->border_width*2;
	int h = c->xattr.height + c->border_width*2 + c->titlebar_height;

	c->x = screen_x + x;
	c->y = screen_y + y;
	c->w = w; c->h = h;

	// gather info on the current window position, so we can try and resize and move nicely
	c->is_full    = (x < 1 && y < 1 && w >= screen_width && h >= screen_height) ? 1:0;
	c->is_left    = c->is_full || NEAR(0, vague, x);
	c->is_top     = c->is_full || NEAR(0, vague, y);
	c->is_right   = c->is_full || NEAR(screen_width, vague, x+w);
	c->is_bottom  = c->is_full || NEAR(screen_height, vague, y+h);
	c->is_xcenter = c->is_full || NEAR((screen_width-w)/2,  vague, x) ? 1:0;
	c->is_ycenter = c->is_full || NEAR((screen_height-h)/2, vague, y) ? 1:0;
	c->is_maxh    = c->is_full || (c->is_left && w >= screen_width-2);
	c->is_maxv    = c->is_full || (c->is_top && h >= screen_height-2);

	c->is_extended = 1;
}

// true if a client window matches a rule pattern
int client_rule_match(client *c, winrule *r)
{
	if (c->trans
		|| c->type == netatoms[_NET_WM_WINDOW_TYPE_DESKTOP]
		|| c->type == netatoms[_NET_WM_WINDOW_TYPE_DOCK]
		// EWMH seems to often equate dialogs with transient_for, and we already ignore transients...
		|| c->type == netatoms[_NET_WM_WINDOW_TYPE_DIALOG]
		// following should never be children of the root window anyway? hence never managed or ruled. ignore anyway...
		|| c->type == netatoms[_NET_WM_WINDOW_TYPE_DROPDOWN_MENU]
		|| c->type == netatoms[_NET_WM_WINDOW_TYPE_POPUP_MENU]
		|| c->type == netatoms[_NET_WM_WINDOW_TYPE_TOOLTIP]
		|| c->type == netatoms[_NET_WM_WINDOW_TYPE_NOTIFICATION]
		|| c->type == netatoms[_NET_WM_WINDOW_TYPE_COMBO]
		) return 0;
		// _NET_WM_WINDOW_TYPE_SPLASH can be annoying, so we do let them be ruled
		// _NET_WM_WINDOW_TYPE_UTILITY and TOOLBAR are both persistent and may be managed and ruled
	client_descriptive_data(c);
	if (strchr(r->pattern, ':') && strchr("cnte", r->pattern[0]))
	{
		if (r->pattern[0] == 'c') return regexec(&r->re, c->class, 0, NULL, 0) ?0:1;
		if (r->pattern[0] == 'n') return regexec(&r->re, c->name,  0, NULL, 0) ?0:1;
		if (r->pattern[0] == 't') return regexec(&r->re, c->title, 0, NULL, 0) ?0:1;
		// check if window on edge:(top|left|bottom|right)
		if (r->pattern[0] == 'e')
		{
			client_extended_data(c);
			char *p = strchr(r->pattern, ':')+1;
			if (!strcasecmp(p, "top")    && c->is_top)    return 1;
			if (!strcasecmp(p, "bottom") && c->is_bottom) return 1;
			if (!strcasecmp(p, "left")   && c->is_left)   return 1;
			if (!strcasecmp(p, "right")  && c->is_right)  return 1;
		}
		return 0;
	}
	return (
		regexec(&r->re, c->class, 0, NULL, 0) == 0 ||
		regexec(&r->re, c->name,  0, NULL, 0) == 0 ||
		regexec(&r->re, c->title, 0, NULL, 0) == 0) ?1:0;
}

// find a client's rule, optionally filtered by flags
winrule* client_rule(client *c, bitmap flags)
{
	if (!c->is_ruled)
	{
		c->rule = config_rules; while (c->rule && !client_rule_match(c, c->rule)) c->rule = c->rule->next;
		c->is_ruled = 1;
	}
	return (!c->rule || (flags && !(flags & c->rule->flags))) ? NULL: c->rule;
}

// collect info on any window
// doesn't have to be a window we'll end up managing
client* client_create(Window win)
{
	if (win == None) return NULL;
	int idx = winlist_find(cache_client, win);
	if (idx >= 0) return cache_client->data[idx];

	// if this fails, we're up that creek
	XWindowAttributes *attr = window_get_attributes(win);
	if (!attr) return NULL;

	client *c = allocate_clear(sizeof(client));
	c->window = win; c->title = c->name = c->class = empty;
	// copy xattr so we don't have to care when stuff is freed
	memmove(&c->xattr, attr, sizeof(XWindowAttributes));
	XGetTransientForHint(display, win, &c->trans);

	// find last known state
	wincache *cache = NULL;
	idx = winlist_find(windows, c->window);
	if (idx < 0)
	{
		cache = allocate_clear(sizeof(wincache));
		winlist_append(windows, c->window, cache);
		idx = windows->len-1;
	}
	// the cache is not tightly linked to the window at all
	// if it's populated, it gets used to make behaviour appear logically
	// if it's empty, nothing cares that much, or it gets initialized
	c->cache = windows->data[idx];

	c->visible = c->xattr.map_state == IsViewable ?1:0;
	c->states  = window_get_atom_prop(win, netatoms[_NET_WM_STATE], c->state, CLIENTSTATE);
	window_get_atom_prop(win, netatoms[_NET_WM_WINDOW_TYPE], &c->type, 1);

	if (c->type == None) c->type = (c->trans != None)
		// trasients default to dialog
		? netatoms[_NET_WM_WINDOW_TYPE_DIALOG]
		// non-transients default to normal
		: netatoms[_NET_WM_WINDOW_TYPE_NORMAL];

	c->manage = c->xattr.override_redirect == False && !c->cache->is_ours
		&& c->type != netatoms[_NET_WM_WINDOW_TYPE_DESKTOP]
		&& c->type != netatoms[_NET_WM_WINDOW_TYPE_NOTIFICATION]
		&& c->type != netatoms[_NET_WM_WINDOW_TYPE_DOCK]
		&& c->type != netatoms[_NET_WM_WINDOW_TYPE_SPLASH]
		?1:0;

	c->active    = c->manage && c->visible && window_is_active(c->window) ?1:0;
	c->minimized = winlist_find(windows_minimized, c->window) >= 0 ? 1:0;
	c->shaded    = winlist_find(windows_shaded, c->window) >= 0 ? 1:0;
	c->urgent    = c->manage && client_has_state(c, netatoms[_NET_WM_STATE_DEMANDS_ATTENTION]) ? 1:0;

	// extra checks for managed windows
	if (c->manage && client_rule(c, RULE_IGNORE)) c->manage = 0;

	// focus seems a really dodgy way to determine the "active" window, but in some
	// cases checking both ->active and ->focus is necessary to bahave logically
	Window focus; int rev;
	XGetInputFocus(display, &focus, &rev);
	c->focus = focus == win ? 1:0;

	XWMHints *hints = XGetWMHints(display, win);
	if (hints)
	{
		c->input = hints->flags & InputHint && hints->input ? 1: 0;
		c->initial_state = hints->flags & StateHint ? hints->initial_state: NormalState;
		c->urgent = c->urgent || hints->flags & XUrgencyHint ? 1: 0;
		XFree(hints);
	}

	c->decorate = c->manage;
	// can't get away with ignoring old motif stuff, as some apps use it
	Atom motif_type; int motif_items; motif_hints mhints;
	if (window_get_prop(c->window, atoms[_MOTIF_WM_HINTS], &motif_type, &motif_items, &mhints, sizeof(mhints)) && motif_items)
		if (mhints.flags & 2 && mhints.decorations == 0) c->decorate = 0;

	// co-ords include borders
	c->x = c->xattr.x; c->y = c->xattr.y; c->w = c->xattr.width; c->h = c->xattr.height;
	c->border_width = c->decorate && !client_has_state(c, netatoms[_NET_WM_STATE_FULLSCREEN]) ? config_border_width: 0;
	c->titlebar_height = c->decorate && !client_has_state(c, netatoms[_NET_WM_STATE_FULLSCREEN]) ? config_titlebar_height: 0;
	// compenstate for borders on non-fullscreen windows
	if (c->decorate)
	{
		c->x -= c->border_width;
		c->y -= c->border_width + c->titlebar_height;
		c->w += c->border_width*2;
		c->h += c->border_width*2 + c->titlebar_height;
	}
	// check whether the frame should be created
	if (c->decorate && !c->cache->frame)
	{
		c->cache->frame = box_create(root, 0, c->x, c->y, c->w, c->h, config_border_blur);

		cache = allocate_clear(sizeof(wincache));
		winlist_append(windows, c->cache->frame->window, cache);
		cache->is_ours = 1;
		// associate with the window (see handle_buttonpress)
		cache->app = c->window;

		XSelectInput(display, c->cache->frame->window, ExposureMask);

		// stack frame under client window
		Window wins[2] = { c->window, c->cache->frame->window };
		XRestackWindows(display, wins, 2);

		// ...and same for titlebar
		if (config_titlebar_height)
		{
			client_extended_data(c);
			c->cache->title = textbox_create(c->cache->frame->window,
				TB_CENTER, 0, c->border_width, c->w, config_titlebar_height,
				config_titlebar_font, config_titlebar_focus, config_border_focus,
				c->title, NULL);
			XSelectInput(display, c->cache->title->window, ExposureMask);
			textbox_show(c->cache->title);
		}
	}

	winlist_append(cache_client, c->window, c);
	return c;
}

// refresh client_cache
client* client_recreate(Window w)
{
	int idx = winlist_find(cache_client, w);
	if (idx >= 0)
	{
		client_free(cache_client->data[idx]);
		cache_client->data[idx] = NULL;
		winlist_forget(cache_client, w);
	}
	return client_create(w);
}

// release client memory. this should only be called during the global cache resets
void client_free(client *c)
{
	if (!c) return;
	if (c->title != empty) free(c->title);
	if (c->class != empty) free(c->class);
	if (c->name  != empty) free(c->name);
	free(c);
}

// true if client windows overlap
int clients_intersect(client *a, client *b)
{
	client_extended_data(a); client_extended_data(b);
	return INTERSECT(a->x, a->y, a->w, a->h, b->x, b->y, b->w, b->h) ?1:0;
}

// if a client supports a WM_PROTOCOLS type atom, dispatch an event
int client_protocol_event(client *c, Atom protocol)
{
	Atom *protocols = NULL;
	int i, found = 0, num_pro = 0;
	if (XGetWMProtocols(display, c->window, &protocols, &num_pro))
		for (i = 0; i < num_pro && !found; i++)
			if (protocols[i] == protocol) found = 1;
	if (found)
		window_send_message(c->window, c->window, atoms[WM_PROTOCOLS], protocol, NoEventMask);
	if (protocols) XFree(protocols);
	return found;
}

// close a window politely if possible, else kill it
void client_close(client *c)
{
	// prevent frame flash
	c->active = 0;
	client_redecorate(c);
	if (c->cache->frame) box_hide(c->cache->frame);

	if (c->cache->have_closed || !client_protocol_event(c, atoms[WM_DELETE_WINDOW]))
		XKillClient(display, c->window);

	c->cache->have_closed = 1;
}

// true if x/y is over a visible portion of the client window
int client_warp_check(client *c, int x, int y)
{
	int i, ok = 1; Window w; client *o;
	managed_descend(i, w, o)
	{
		if (!ok || w == c->window) break;
		if (INTERSECT(o->x, o->y, o->w, o->h, x, y, 1, 1)) ok = 0;
	}
	return ok;
}

// ensure the pointer is over a specific client
void client_warp_pointer(client *c)
{
	// needs the updated stacking mode, so clear cache
	XSync(display, False);
	reset_cache_inplay();

	client_extended_data(c);
	int vague = MAX(c->monitor.w/100, c->monitor.h/100);
	int x, y; if (!pointer_get(&x, &y)) return;
	int mx = x, my = y;
	// if pointer is not already over the client...
	if (!INTERSECT(c->x, c->y, c->w, c->h, x, y, 1, 1) || !client_warp_check(c, x, y))
	{
		int overlap_x = OVERLAP(c->x, c->w, x, 1);
		int overlap_y = OVERLAP(c->y, c->h, y, 1);
		int xd = 0, yd = 0;
		if (overlap_y && x < c->x) { x = c->x; xd = vague; }
		if (overlap_y && x > c->x) { x = MIN(x, c->x+c->w-1); xd = 0-vague; }
		if (overlap_x && y < c->y) { y = c->y; yd = vague; }
		if (overlap_x && y > c->y) { y = MIN(y, c->y+c->h-1); yd = 0-vague; }
		// step toward client window
		while ((xd || yd ) && INTERSECT(c->x, c->y, c->w, c->h, x, y, 1, 1) && !client_warp_check(c, x, y))
			{ x += xd; y += yd; }
		// ensure pointer is slightly inside border
		x = MIN(c->x+c->w-vague, MAX(c->x+vague, x));
		y = MIN(c->y+c->h-vague, MAX(c->y+vague, y));
		XWarpPointer(display, None, None, 0, 0, 0, 0, x-mx, y-my);
	}
}

// adjust co-ordinates to take hints into account, ready for move/resize
void client_process_size_hints(client *c, int *x, int *y, int *w, int *h)
{
	// fw/fh still include borders here
	int fx = *x, fy = *y, fw = *w, fh = *h;
	int dec_w = c->border_width*2, dec_h = c->border_width*2+c->titlebar_height;
	int basew = 0, baseh = 0;

	if (c->xsize.flags & PBaseSize)
	{
		basew = c->xsize.base_width;
		baseh = c->xsize.base_height;
	}
	if (c->xsize.flags & PMinSize)
	{
		// fw/fh still include borders here
		fw = MAX(fw, c->xsize.min_width  + dec_w);
		fh = MAX(fh, c->xsize.min_height + dec_h);
	}
	if (c->xsize.flags & PMaxSize)
	{
		// fw/fh still include borders here
		fw = MIN(fw, c->xsize.max_width  + dec_w);
		fh = MIN(fh, c->xsize.max_height + dec_h);
	}
	if (config_resize_inc && c->xsize.flags & PResizeInc)
	{
		client_descriptive_data(c);
		if (config_resize_inc == RESIZEINC
			|| (config_resize_inc == SMARTRESIZEINC && !regquick(SMARTRESIZEINC_IGNORE, c->class)))
		{
			// fw/fh still include borders here
			fw -= basew + dec_w; fh -= baseh + dec_h;
			fw -= fw % c->xsize.width_inc;
			fh -= fh % c->xsize.height_inc;
			fw += basew + dec_w; fh += baseh + dec_h;
		}
	}
	if (c->xsize.flags & PAspect)
	{
		double ratio = (double) fw / fh;
		double minr  = (double) c->xsize.min_aspect.x / c->xsize.min_aspect.y;
		double maxr  = (double) c->xsize.max_aspect.x / c->xsize.max_aspect.y;
			if (ratio < minr) fh = (int)(fw / minr);
		else if (ratio > maxr) fw = (int)(fh * maxr);
	}
	*x = fx; *y = fy; *w = fw; *h = fh;
}

// move & resize a window nicely, respecting hints and EWMH states
void client_moveresize(client *c, unsigned int flags, int fx, int fy, int fw, int fh)
{
	client_extended_data(c);
	int vague = MAX(c->monitor.w/100, c->monitor.h/100);
	int i; Window win; client *o;
	int xsnap = 0, ysnap = 0;

	// this many be different to the client's current c->monitor...
	workarea monitor; monitor_dimensions_struts(MAX(fx, 0), MAX(fy, 0), &monitor);

	// horz/vert size locks
	if (c->cache->vlock) { fy = c->y; fh = c->h; }
	if (c->cache->hlock) { fx = c->x; fw = c->w; }

	// ensure we match fullscreen/maxv/maxh mode. these override above locks!
	if (client_has_state(c, netatoms[_NET_WM_STATE_FULLSCREEN]))
	{
		fx = monitor.x-monitor.l; fy = monitor.y-monitor.t;
		fw = monitor.w+monitor.l+monitor.r; fh = monitor.h+monitor.t+monitor.b;
	}
	else
	{
		if (client_has_state(c, netatoms[_NET_WM_STATE_MAXIMIZED_HORZ]))
			{ fx = monitor.x; fw = monitor.w; }
		if (client_has_state(c, netatoms[_NET_WM_STATE_MAXIMIZED_VERT]))
			{ fy = monitor.y; fh = monitor.h; }

		// shrink onto screen
		if (!(flags & MR_UNCONSTRAIN))
		{
			fw = MAX(MINWINDOW, MIN(fw, monitor.w));
			fh = MAX(MINWINDOW, MIN(fh, monitor.h));
		}

		client_process_size_hints(c, &fx, &fy, &fw, &fh);

		// bump onto screen
		if (!(flags & MR_UNCONSTRAIN))
		{
			fx = MAX(MIN(fx, monitor.x + monitor.w - fw), monitor.x);
			fy = MAX(MIN(fy, monitor.y + monitor.h - fh), monitor.y);
		}
	}

	// put the window in same general position it was before
	if (flags & MR_SMART)
	{
		// shrinking w. check if we were once in a corner previous-to-last
		// expanding w is already covered by bumping above
		if (c->cache && c->cache->last_corner && c->w > fw)
		{
			if (c->cache->last_corner == TOPLEFT || c->cache->last_corner == BOTTOMLEFT || c->cache->last_corner == CENTERLEFT)
				fx = monitor.x;
			if (c->cache->last_corner == TOPRIGHT || c->cache->last_corner == BOTTOMRIGHT || c->cache->last_corner == CENTERRIGHT)
				fx = monitor.x + monitor.w - fw;
			if (c->cache->last_corner == CENTERTOP || c->cache->last_corner == CENTERBOTTOM)
				fx = monitor.x + (monitor.w - fw)/2;
		}
		// screen center always wins
		else if (c->is_xcenter) fx = monitor.x + ((monitor.w - fw) / 2);
		else if (c->is_left) fx = monitor.x;
		else if (c->is_right) fx = monitor.x + monitor.w - fw;

		// shrinking h. check if we were once in a corner previous-to-last
		// expanding h is already covered by bumping above
		if (c->cache && c->cache->last_corner && c->h > fh)
		{
			if (c->cache->last_corner == TOPLEFT || c->cache->last_corner == TOPRIGHT || c->cache->last_corner == CENTERTOP)
				fy = monitor.y;
			if (c->cache->last_corner == BOTTOMLEFT || c->cache->last_corner == BOTTOMRIGHT || c->cache->last_corner == CENTERBOTTOM)
				fy = monitor.y + monitor.h - fh;
			if (c->cache->last_corner == CENTERLEFT || c->cache->last_corner == CENTERRIGHT)
				fy = monitor.y + (monitor.h - fh)/2;
		}
		// screen center always wins
		else if (c->is_ycenter) fy = monitor.y + ((monitor.h - fh) / 2);
		else if (c->is_top) fy = monitor.y;
		else if (c->is_bottom) fy = monitor.y + monitor.h - fh;
	}

	// snap all edges by moving window
	// built for MotionNotify Button1
	if (flags & MR_SNAP)
	{
		// snap to monitor edges
		if (NEAR(c->monitor.x, vague, fx)) { fx = c->monitor.x; xsnap = 1; }
		if (NEAR(c->monitor.y, vague, fy)) { fy = c->monitor.y; ysnap = 1; }
		if (!xsnap && NEAR(c->monitor.x+c->monitor.w, vague, fx+fw)) { fx = c->monitor.x+c->monitor.w-fw; xsnap = 1; }
		if (!ysnap && NEAR(c->monitor.y+c->monitor.h, vague, fy+fh)) { fy = c->monitor.y+c->monitor.h-fh; ysnap = 1; }
		// snap to window edges
		if (!xsnap || !ysnap)
		{
			winlist *visible = clients_partly_visible(&monitor, 0, c->window);
			clients_descend(visible, i, win, o)
			{
				if (!xsnap && NEAR(o->x, vague, fx)) { fx = o->x; xsnap = 1; }
				if (!ysnap && NEAR(o->y, vague, fy)) { fy = o->y; ysnap = 1; }
				if (!xsnap && NEAR(o->x+o->w, vague, fx)) { fx = o->x+o->w; xsnap = 1; }
				if (!ysnap && NEAR(o->y+o->h, vague, fy)) { fy = o->y+o->h; ysnap = 1; }
				if (!xsnap && NEAR(o->x, vague, fx+fw)) { fx = o->x+-fw; xsnap = 1; }
				if (!ysnap && NEAR(o->y, vague, fy+fh)) { fy = o->y+-fh; ysnap = 1; }
				if (!xsnap && NEAR(o->x+o->w, vague, fx+fw)) { fx = o->x+o->w-fw; xsnap = 1; }
				if (!ysnap && NEAR(o->y+o->h, vague, fy+fh)) { fy = o->y+o->h-fh; ysnap = 1; }
				if (xsnap && ysnap) break;
			}
			winlist_free(visible);
		}
	}
	else
	// snap right and bottom edges by resizing window
	// built for MotionNotify Button3
	if (flags & MR_SNAPWH)
	{
		// snap to monitor edges
		if (NEAR(c->monitor.x+c->monitor.w, vague, fx+fw)) { fw = c->monitor.x+c->monitor.w-fx; xsnap = 1; }
		if (NEAR(c->monitor.y+c->monitor.h, vague, fy+fh)) { fh = c->monitor.y+c->monitor.h-fy; ysnap = 1; }
		// snap to window edges
		if (!xsnap || !ysnap)
		{
			winlist *visible = clients_partly_visible(&monitor, 0, c->window);
			clients_descend(visible, i, win, o)
			{
				if (!xsnap && NEAR(o->x, vague, fx+fw)) { fw = o->x-fx; xsnap = 1; }
				if (!ysnap && NEAR(o->y, vague, fy+fh)) { fh = o->y-fy; ysnap = 1; }
				if (!xsnap && NEAR(o->x+o->w, vague, fx+fw)) { fw = o->x+o->w-fx; xsnap = 1; }
				if (!ysnap && NEAR(o->y+o->h, vague, fy+fh)) { fh = o->y+o->h-fy; ysnap = 1; }
				if (xsnap && ysnap) break;
			}
			winlist_free(visible);
		}
	}

	// this needs to occur despite MR_UNCONSTRAIN
	fw = MAX(MINWINDOW, fw);
	fh = MAX(MINWINDOW, fh);

	// update window co-ords for subsequent operations before caches are reset
	c->x = fx; c->y = fy; c->w = fw; c->h = fh;
	memmove(&c->monitor, &monitor, sizeof(workarea));

	// compensate for border on non-fullscreen windows
	if (c->decorate && !client_has_state(c, netatoms[_NET_WM_STATE_FULLSCREEN]))
	{
		fx += c->border_width;
		fy += c->border_width + c->titlebar_height;
		fw = MAX(1, fw - c->border_width*2);
		fh = MAX(1, fh - c->border_width*2 - c->titlebar_height);
	}
	if (c->decorate) box_moveresize(c->cache->frame, c->x, c->y, c->w, c->h);
	XMoveResizeWindow(display, c->window, fx, fy, fw, fh);
	client_redecorate(c);
}

// record a window's size and position in the undo log
void client_commit(client *c)
{
	client_extended_data(c);
	int levels = 0; winundo *undo = c->cache->undo;
	// count current undo chain length for this window
	while (undo) { levels++; undo = undo->next; }

	if (levels > 0)
	{
		// check if the most recent undo state matches current state. if so, no point recording
		undo = c->cache->undo;
		if (undo->x == c->x && undo->y == c->y && undo->w == c->w && undo->h == c->h) return;
	}
	// LIFO up to UNDO cells deep
	if (levels == UNDO)
	{
		undo = c->cache->undo;
		// find second last link
		while (undo->next && undo->next->next) undo = undo->next;
		// chop of the last link
		free(undo->next); undo->next = NULL;
	}
	undo = allocate_clear(sizeof(winundo));
	undo->next = c->cache->undo; c->cache->undo = undo;
	// do the actual snapshot
	undo->x = c->x; undo->y = c->y; undo->w = c->w; undo->h = c->h;
	for (undo->states = 0; undo->states < c->states; undo->states++)
		undo->state[undo->states] = c->state[undo->states];
}

// move/resize a window back to it's last known size and position
void client_rollback(client *c)
{
	if (c->cache->undo)
	{
		// remove most recent winundo from the undo chain
		winundo *undo = c->cache->undo; c->cache->undo = undo->next;
		// do the actual rollback
		for (c->states = 0; c->states < undo->states; c->states++)
			c->state[c->states] = undo->state[c->states];
		client_flush_state(c);
		client_moveresize(c, 0, undo->x, undo->y, undo->w, undo->h);
		free(undo);
	}
}

// save co-ords for later flip-back
// these may MAY BE dulicated in the undo log, but they must remain separate
// to allow proper toggle behaviour for maxv/maxh
void client_save_position(client *c)
{
	client_extended_data(c);
	if (!c->cache) return;

	if (!c->cache->ewmh)
		c->cache->ewmh = allocate_clear(sizeof(winundo));

	winundo *undo = c->cache->ewmh;

	undo->x = c->x; undo->y = c->y;
	undo->w = c->w; undo->h = c->h;
}

// save co-ords for later flip-back
void client_save_position_horz(client *c)
{
	client_extended_data(c); if (!c->cache) return;
	if (!c->cache->ewmh) client_save_position(c);

	winundo *undo = c->cache->ewmh;
	undo->x = c->x; undo->w = c->w;
}

// save co-ords for later flip-back
void client_save_position_vert(client *c)
{
	client_extended_data(c); if (!c->cache) return;
	if (!c->cache->ewmh) client_save_position(c);

	winundo *undo = c->cache->ewmh;
	undo->y = c->y; undo->h = c->h;
}

// revert to saved co-ords
void client_restore_position(client *c, unsigned int smart, int x, int y, int w, int h)
{
	client_extended_data(c);
	client_moveresize(c, smart,
		c->cache && c->cache->ewmh ? c->cache->ewmh->x: x,
		c->cache && c->cache->ewmh ? c->cache->ewmh->y: y,
		c->cache && c->cache->ewmh ? c->cache->ewmh->w: w,
		c->cache && c->cache->ewmh ? c->cache->ewmh->h: h);
}

// revert to saved co-ords
void client_restore_position_horz(client *c, unsigned int smart, int x, int w)
{
	client_extended_data(c);
	client_moveresize(c, smart,
		c->cache && c->cache->ewmh ? c->cache->ewmh->x: x, c->y,
		c->cache && c->cache->ewmh ? c->cache->ewmh->w: w, c->h);
}

// revert to saved co-ords
void client_restore_position_vert(client *c, unsigned int smart, int y, int h)
{
	client_extended_data(c);
	client_moveresize(c, smart,
		c->x,  c->cache && c->cache->ewmh ? c->cache->ewmh->y: y,
		c->w, c->cache && c->cache->ewmh ? c->cache->ewmh->h: h);
}

// build list of unobscured windows within a workarea
winlist* clients_fully_visible(workarea *zone, unsigned int tag, Window ignore)
{
	winlist *hits = winlist_new();
	winlist *inplay = windows_in_play();
	// list of coords/sizes for all windows on this desktop
	workarea *allregions = allocate_clear(sizeof(workarea) * inplay->len);

	int i; Window win; client *o;
	tag_descend(i, win, o, tag)
	{
		client_extended_data(o);
		// only concerned about windows in the zone
		if (ignore != o->window && INTERSECT(o->x, o->y, o->w, o->h, zone->x, zone->y, zone->w, zone->h))
		{
			int j, obscured = 0;
			for (j = inplay->len-1; j > i; j--)
			{
				// if the window intersects with any other window higher in the stack order, it must be at least partially obscured
				if (allregions[j].w && INTERSECT(o->x, o->y, o->w, o->h,
					allregions[j].x, allregions[j].y, allregions[j].w, allregions[j].h))
						{ obscured = 1; break; }
			}
			// record a full visible window
			if (!obscured && o->x >= zone->x && o->y >= zone->y && (o->x + o->w) <= (zone->x + zone->w) && (o->y + o->h) <= (zone->y + zone->h))
				winlist_append(hits, o->window, NULL);
			allregions[i].x = o->x; allregions[i].y = o->y;
			allregions[i].w = o->w; allregions[i].h = o->h;
		}
	}
	// return it in stacking order, bottom to top
	winlist_reverse(hits);
	free(allregions);
	return hits;
}

// build list of unobscured windows within a workarea
winlist* clients_partly_visible(workarea *zone, unsigned int tag, Window ignore)
{
	winlist *hits = winlist_new();
	winlist *inplay = windows_in_play();
	// list of coords/sizes for all windows on this desktop
	workarea *allregions = allocate_clear(sizeof(workarea) * inplay->len);

	int i; Window win; client *o;
	tag_descend(i, win, o, tag)
	{
		client_extended_data(o);
		// only concerned about windows in the zone
		if (ignore != o->window && INTERSECT(o->x, o->y, o->w, o->h, zone->x, zone->y, zone->w, zone->h))
		{
			int j, c1 = 0, c2 = 0, c3 = 0, c4 = 0;
			for (j = inplay->len-1; j > i; j--)
			{
				if (!allregions[j].w) continue;
				// if the window's corners intersects with any other window higher in the stack order, assume it is covered
				if (INTERSECT(o->x, o->y, 1, 1, allregions[j].x, allregions[j].y, allregions[j].w, allregions[j].h)) c1 = 1;
				if (INTERSECT(o->x, o->y+o->h-1, 1, 1, allregions[j].x, allregions[j].y, allregions[j].w, allregions[j].h)) c2 = 1;
				if (INTERSECT(o->x+o->w-1, o->y, 1, 1, allregions[j].x, allregions[j].y, allregions[j].w, allregions[j].h)) c3 = 1;
				if (INTERSECT(o->x+o->w-1, o->y+o->h-1, 1, 1, allregions[j].x, allregions[j].y, allregions[j].w, allregions[j].h)) c4 = 1;
				if (c1 && c2 && c3 && c4) break;
			}
			// record a full visible window
			if ((!c1 || !c2 || !c3 || !c4) && o->x >= zone->x && o->y >= zone->y && (o->x + o->w) <= (zone->x + zone->w) && (o->y + o->h) <= (zone->y + zone->h))
				winlist_append(hits, o->window, NULL);
			allregions[i].x = o->x; allregions[i].y = o->y;
			allregions[i].w = o->w; allregions[i].h = o->h;
		}
	}
	// return it in stacking order, bottom to top
	winlist_reverse(hits);
	free(allregions);
	return hits;
}

// expand a window to take up available space around it on the current monitor
// do not cover any window that is entirely visible (snap to surrounding edges)
void client_expand(client *c, int directions, int x1, int y1, int w1, int h1, int mx, int my, int mw, int mh)
{
	client_extended_data(c);

	// hlock/vlock reduce the area we should look at
	if (c->cache->hlock) { mx = c->x; mw = c->w; if (!mh) { my = c->monitor.y; mh = c->monitor.h; } }
	if (c->cache->vlock) { my = c->y; mh = c->h; if (!mw) { mx = c->monitor.x; mw = c->monitor.w; } }

	// expand only cares about fully visible windows. partially or full obscured windows == free space
	winlist *visible = clients_fully_visible(&c->monitor, c->cache->tags, c->window);

	// list of coords/sizes for fully visible windows on this desktop
	workarea *regions = allocate_clear(sizeof(workarea) * visible->len);

	int i, n = 0, relevant = visible->len; Window win; client *o;
	clients_descend(visible, i, win, o)
	{
		client_extended_data(o);
		if ((mw || mh) && !INTERSECT(o->x, o->y, o->w, o->h, mx, my, mw, mh)) continue;
		regions[n].x = o->x; regions[n].y = o->y;
		regions[n].w = o->w; regions[n].h = o->h;
		n++;
	}

	int x = c->x, y = c->y, w = c->w, h = c->h;
	if (w1 || h1) { x = x1; y = y1; w = w1; h = h1; }

	if (directions & VERTICAL)
	{
		// try to grow upward. locate the lower edge of the nearest fully visible window
		for (n = c->monitor.y, i = 0; i < relevant; i++)
			if (regions[i].y + regions[i].h <= y && OVERLAP(x, w, regions[i].x, regions[i].w))
				n = MAX(n, regions[i].y + regions[i].h);
		h += y-n; y = n;
		// try to grow downward. locate the upper edge of the nearest fully visible window
		for (n = c->monitor.y + c->monitor.h, i = 0; i < relevant; i++)
			if (regions[i].y >= y+h && OVERLAP(x, w, regions[i].x, regions[i].w))
				n = MIN(n, regions[i].y);
		h = n-y;
	}
	if (directions & HORIZONTAL)
	{
		// try to grow left. locate the right edge of the nearest fully visible window
		for (n = c->monitor.x, i = 0; i < relevant; i++)
			if (regions[i].x + regions[i].w <= x && OVERLAP(y, h, regions[i].y, regions[i].h))
				n = MAX(n, regions[i].x + regions[i].w);
		w += x-n; x = n;
		// try to grow right. locate the left edge of the nearest fully visible window
		for (n = c->monitor.x + c->monitor.w, i = 0; i < relevant; i++)
			if (regions[i].x >= x+w && OVERLAP(y, h, regions[i].y, regions[i].h))
				n = MIN(n, regions[i].x);
		w = n-x;
	}
	// optionally limit final size to a bounding box
	if (mw || mh)
	{
		if (x < mx) { w -= mx-x; x = mx; }
		if (y < my) { h -= my-y; y = my; }
		w = MIN(w, mw);
		h = MIN(h, mh);
	}
	client_commit(c);
	client_moveresize(c, 0, x, y, w, h);
	// if we looked like we could expand, but couldn't due to some condition in client_moveresize(),
	// act like a toggle and rollback instead
	winundo *undo = c->cache->undo;
	if (undo->x == c->x && undo->y == c->y && undo->w == c->w && undo->h == c->h)
	{
		// yes, twice!
		client_rollback(c);
		client_rollback(c);
	}
	free(regions);
	winlist_free(visible);
}

// shrink to fit into an empty gap underneath. opposite of client_expand()
void client_contract(client *c, int directions)
{
	client_extended_data(c);
	// cheat and shrink the window absurdly so it becomes just another expansion
	if (directions & VERTICAL && directions & HORIZONTAL)
		client_expand(c, directions, c->x+(c->w/2), c->y+(c->h/2), 5, 5, c->x, c->y, c->w, c->h);
	else
	if (directions & VERTICAL)
		client_expand(c, directions, c->x, c->y+(c->h/2), c->w, 5, c->x, c->y, c->w, c->h);
	else
	if (directions & HORIZONTAL)
		client_expand(c, directions, c->x+(c->w/2), c->y, 5, c->h, c->x, c->y, c->w, c->h);
}

// move or resize a client window to snap to someone else's leading or trailing edge
void client_snapto(client *c, int direction)
{
	client_extended_data(c);

	// hlock/vlock may block this
	if (c->cache->hlock && (direction == SNAPLEFT || direction == SNAPRIGHT)) return;
	if (c->cache->vlock && (direction == SNAPUP   || direction == SNAPDOWN )) return;

	// expand only cares about fully visible windows. partially or full obscured windows == free space
	winlist *visible = clients_partly_visible(&c->monitor, c->cache->tags, c->window);

	// list of coords/sizes for fully visible windows on this desktop
	workarea *regions = allocate_clear(sizeof(workarea) * visible->len);

	int i, n = 0, relevant = visible->len; Window win; client *o;
	clients_descend(visible, i, win, o)
	{
		client_extended_data(o);
		regions[n].x = o->x; regions[n].y = o->y;
		regions[n].w = o->w; regions[n].h = o->h;
		n++;
	}

	int x = c->x, y = c->y, w = c->w, h = c->h;

	if (direction == SNAPUP)
	{
		y--;
		for (n = c->monitor.y, i = 0; i < relevant; i++)
		{
			if (!OVERLAP(c->x-1, c->w+2, regions[i].x, regions[i].w)) continue;
			if (regions[i].y + regions[i].h <= y) n = MAX(n, regions[i].y + regions[i].h);
			if (regions[i].y <= y) n = MAX(n, regions[i].y);
			if (regions[i].y + regions[i].h <= y+h) n = MAX(n, regions[i].y + regions[i].h - h);
			if (regions[i].y <= y+h) n = MAX(n, regions[i].y - h);
		}
		y = n;
	}
	if (direction == SNAPDOWN)
	{
		y++;
		for (n = c->monitor.y + c->monitor.h, i = 0; i < relevant; i++)
		{
			if (!OVERLAP(c->x-1, c->w+2, regions[i].x, regions[i].w)) continue;
			if (regions[i].y + regions[i].h >= y+h) n = MIN(n, regions[i].y + regions[i].h);
			if (regions[i].y >= y+h) n = MIN(n, regions[i].y);
			if (regions[i].y + regions[i].h >= y) n = MIN(n, regions[i].y + regions[i].h + h);
			if (regions[i].y >= y) n = MIN(n, regions[i].y + h);
		}
		y = n-h;
	}
	if (direction == SNAPLEFT)
	{
		x--;
		for (n = c->monitor.x, i = 0; i < relevant; i++)
		{
			if (!OVERLAP(c->y-1, c->h+2, regions[i].y, regions[i].h)) continue;
			if (regions[i].x + regions[i].w <= x) n = MAX(n, regions[i].x + regions[i].w);
			if (regions[i].x <= x) n = MAX(n, regions[i].x);
			if (regions[i].x + regions[i].w <= x+w) n = MAX(n, regions[i].x + regions[i].w - w);
			if (regions[i].x <= x+w) n = MAX(n, regions[i].x - w);
		}
		x = n;
	}
	if (direction == SNAPRIGHT)
	{
		x++;
		for (n = c->monitor.x + c->monitor.w, i = 0; i < relevant; i++)
		{
			if (!OVERLAP(c->y-1, c->h+2, regions[i].y, regions[i].h)) continue;
			if (regions[i].x + regions[i].w >= x+w) n = MIN(n, regions[i].x + regions[i].w);
			if (regions[i].x >= x+w) n = MIN(n, regions[i].x);
			if (regions[i].x + regions[i].w >= x) n = MIN(n, regions[i].x + regions[i].w + w);
			if (regions[i].x >= x) n = MIN(n, regions[i].x + w);
		}
		x = n-w;
	}
	client_commit(c);
	client_moveresize(c, 0, x, y, w, h);
	free(regions);
	winlist_free(visible);
}

// make a window take up 2/3 of a monitor
void client_toggle_large(client *c, int side)
{
	int vague = MAX(c->monitor.w/100, c->monitor.h/100);
	int width3  = c->monitor.w - c->monitor.w/3;
	int height4 = c->monitor.h;

	int is_largeleft  = c->is_left  && c->is_maxv && NEAR(width3, vague, c->w) ?1:0;
	int is_largeright = c->is_right && c->is_maxv && NEAR(width3, vague, c->w) ?1:0;

	c->cache->hlock = 0; c->cache->vlock = 0;
	client_remove_state(c, netatoms[_NET_WM_STATE_MAXIMIZED_HORZ]);

	if (side == LARGELEFT)
	{
		// act like a toggle
		if (is_largeleft)
			client_rollback(c);
		else {
			client_commit(c);
			client_moveresize(c, 0, c->monitor.x, c->monitor.y, width3, height4);
		}
	}
	else
	if (side == LARGERIGHT)
	{
		// act like a toggle
		if (is_largeright)
			client_rollback(c);
		else {
			client_commit(c);
			client_moveresize(c, 0, c->monitor.x + c->monitor.w - width3, c->monitor.y, width3, height4);
		}
	}
	if (!is_largeleft && !is_largeright)
	{
		client_add_state(c, netatoms[_NET_WM_STATE_MAXIMIZED_VERT]);
		client_flash(c, config_flash_on, config_flash_ms, FLASHTITLEDEF);
	}
}

// visually highlight a client to attract attention
// for now, four coloured squares in the corners. could get fancier?
void client_flash(client *c, char *color, int delay, int title)
{
	XSync(display, False);
	if (!fork())
	{
		Window win = c->window;
		display = XOpenDisplay(0x0);
		reset_cache_xattr();
		reset_cache_client();
		reset_cache_inplay();

		c = client_create(win);
		if (!c) exit(EXIT_FAILURE);
		client_descriptive_data(c);
		client_extended_data(c);

		int x1 = c->x, x2 = c->x + c->w - config_flash_width;
		int y1 = c->y, y2 = c->y + c->h - config_flash_width;

		// use message_box for title
		if (title || config_flash_title)
			message_box(delay, c->x+c->w/2, c->y+c->h/2, config_title_fg, config_title_bg, config_title_bc, c->title);

		// four coloured squares in the window's corners
		box *tl = box_create(root, BOX_OVERRIDE, x1, y1, config_flash_width, config_flash_width, color);
		box *tr = box_create(root, BOX_OVERRIDE, x2, y1, config_flash_width, config_flash_width, color);
		box *bl = box_create(root, BOX_OVERRIDE, x1, y2, config_flash_width, config_flash_width, color);
		box *br = box_create(root, BOX_OVERRIDE, x2, y2, config_flash_width, config_flash_width, color);

		box_show(tl); box_show(tr); box_show(bl); box_show(br);

		XSync(display, False);
		usleep(delay*1000);

		box_free(tl); box_free(tr); box_free(bl); box_free(br);

		exit(EXIT_SUCCESS);
	}
}

// add a window and family to the stacking order
void client_stack_family(client *c, winlist *stack)
{
	int i; Window w; client *a = NULL;
	// if this is a transient window, find the main app
	if (c->trans && winlist_find(stack, c->trans) < 0)
	{
		a = client_create(c->trans);
		client_stack_family(a, stack);
		return;
	}
	// make sure this window does not trigger recursion
	winlist_append(stack, c->window, NULL);
	// locate all visible transient windows for this app
	managed_descend(i, w, a)
		if (winlist_find(stack, w) < 0 && a->trans == c->window)
			client_stack_family(a, stack);
	// move this window to end (bottom) of stack
	winlist_forget(stack, c->window);
	winlist_append(stack, c->window, NULL);
	if (c->decorate) winlist_append(stack, c->cache->frame->window, NULL);
}

// raise a window and its transients
void client_raise(client *c, int priority)
{
	int i; Window w; client *o;

	if (!priority && client_has_state(c, netatoms[_NET_WM_STATE_BELOW]))
		return;

	winlist *stack = winlist_new();

	// priority gets us raised without anyone above us, regardless. eg _NET_WM_STATE_FULLSCREEN+focus
	if (!priority)
	{
		// if we're above, ensure it
		// allows cycling between multiple _NET_WM_STATE_ABOVE windows, regardless of their original mapping order
		if (client_has_state(c, netatoms[_NET_WM_STATE_ABOVE]))
			client_stack_family(c, stack);

		// locate windows with both _NET_WM_STATE_STICKY and _NET_WM_STATE_ABOVE
		managed_descend(i, w, o)
			if (winlist_find(stack, w) < 0 && o->visible && o->trans == None
				&& client_has_state(o, netatoms[_NET_WM_STATE_ABOVE])
				&& client_has_state(o, netatoms[_NET_WM_STATE_STICKY]))
					client_stack_family(o, stack);
		// locate windows in the current_tag with _NET_WM_STATE_ABOVE
		tag_descend(i, w, o, current_tag)
			if (winlist_find(stack, w) < 0 && o->visible && o->trans == None
				&& client_has_state(o, netatoms[_NET_WM_STATE_ABOVE]))
					client_stack_family(o, stack);
		// locate _NET_WM_WINDOW_TYPE_DOCK windows
		clients_descend(windows_in_play(), i, w, o)
			if (winlist_find(stack, w) < 0 && o->visible && c->trans == None
				&& o->type == netatoms[_NET_WM_WINDOW_TYPE_DOCK])
					client_stack_family(o, stack);
	}
	// locate our family
	if (winlist_find(stack, c->window) < 0)
		client_stack_family(c, stack);

	// raise the top window in the stack
	XRaiseWindow(display, stack->array[0]);
	// stack everything else, in order, underneath top window
	if (stack->len > 1) XRestackWindows(display, stack->array, stack->len);

	winlist_free(stack);
}

// raise a window and its transients, under someone else
void client_raise_under(client *c, client *under)
{
	if (client_has_state(c, netatoms[_NET_WM_STATE_BELOW]))
		return;

	winlist *stack = winlist_new();
	client_stack_family(under, stack);
	client_stack_family(c, stack);

	// stack everything, in order, underneath top window
	XRestackWindows(display, stack->array, stack->len);

	winlist_free(stack);
}

// lower a window and its transients
void client_lower(client *c, int priority)
{
	int i; Window w; client *o;

	if (!priority && client_has_state(c, netatoms[_NET_WM_STATE_ABOVE]))
		return;

	// locate the lowest window in the tag
	client *under = NULL;
	tag_descend(i, w, o, current_tag)
		if (o->trans == None && o->window != c->window
			&& !client_has_state(o, netatoms[_NET_WM_STATE_BELOW]))
				under = o;

	if (under) client_raise_under(c, under);
}

// set border width approriate to position and size
void client_review_border(client *c)
{
	client_extended_data(c);
	XSetWindowBorderWidth(display, c->window, 0);
	unsigned long extents[4] = { c->border_width, c->border_width, c->border_width + c->titlebar_height, c->border_width };

	if (client_has_state(c, netatoms[_NET_WM_STATE_FULLSCREEN]))
	{
		if (c->cache->frame) box_hide(c->cache->frame);
		memset(extents, 0, sizeof(extents));
	}
	else
	if (c->decorate)
	{
		Window wins[2] = { c->window, c->cache->frame->window };
		XRestackWindows(display, wins, 2);
		if (c->visible) box_show(c->cache->frame);
	}
	window_set_cardinal_prop(c->window, netatoms[_NET_FRAME_EXTENTS], extents, 4);
}

// set allowed _NET_WM_STATE_* client messages
void client_review_nws_actions(client *c)
{
	Atom allowed[7] = {
		netatoms[_NET_WM_ACTION_MOVE],
		netatoms[_NET_WM_ACTION_RESIZE],
		netatoms[_NET_WM_ACTION_FULLSCREEN],
		netatoms[_NET_WM_ACTION_CLOSE],
		netatoms[_NET_WM_ACTION_STICK],
		netatoms[_NET_WM_ACTION_MAXIMIZE_HORZ],
		netatoms[_NET_WM_ACTION_MAXIMIZE_VERT],
	};
	window_set_atom_prop(c->window, netatoms[_NET_WM_ALLOWED_ACTIONS], allowed, 7);
}

// if client is in a screen corner, track it...
// if we shrink the window form maxv/maxh/fullscreen later, we can
// have it stick to the original corner rather then re-centering
void client_review_position(client *c)
{
	if (c->cache && !c->is_full)
	{
		// don't change last_corner if it still matches
		if (!c->cache->last_corner && c->is_xcenter && c->is_ycenter) return;
		if (c->cache->last_corner == CENTERLEFT   && c->is_left   && c->is_ycenter) return;
		if (c->cache->last_corner == CENTERRIGHT  && c->is_right  && c->is_ycenter) return;
		if (c->cache->last_corner == CENTERTOP    && c->is_top    && c->is_xcenter) return;
		if (c->cache->last_corner == CENTERBOTTOM && c->is_bottom && c->is_xcenter) return;
		if (c->cache->last_corner == TOPLEFT      && c->is_left   && c->is_top)     return;
		if (c->cache->last_corner == BOTTOMLEFT   && c->is_left   && c->is_bottom)  return;
		if (c->cache->last_corner == TOPRIGHT     && c->is_right  && c->is_top)     return;
		if (c->cache->last_corner == BOTTOMRIGHT  && c->is_right  && c->is_bottom)  return;
		// nope, we've moved too much. decide on a new corner, preferring left and top
		     if (c->is_left   && c->is_ycenter) c->cache->last_corner = CENTERLEFT;
		else if (c->is_right  && c->is_ycenter) c->cache->last_corner = CENTERRIGHT;
		else if (c->is_top    && c->is_xcenter) c->cache->last_corner = CENTERTOP;
		else if (c->is_bottom && c->is_xcenter) c->cache->last_corner = CENTERBOTTOM;
		else if (c->is_left   && c->is_top)     c->cache->last_corner = TOPLEFT;
		else if (c->is_left   && c->is_bottom)  c->cache->last_corner = BOTTOMLEFT;
		else if (c->is_right  && c->is_top)     c->cache->last_corner = TOPRIGHT;
		else if (c->is_right  && c->is_bottom)  c->cache->last_corner = BOTTOMRIGHT;
		else c->cache->last_corner = 0;
	}
}

// check a window's _NET_WM_DESKTOP. if found, tag it appropriately
void client_review_desktop(client *c)
{
	unsigned long d;
	// no desktop set. give it one
	if (!window_get_cardinal_prop(c->window, netatoms[_NET_WM_DESKTOP], &d, 1))
	{
		d = tag_to_desktop(c->cache->tags);
		window_set_cardinal_prop(c->window, netatoms[_NET_WM_DESKTOP], &d, 1);
	}
	else
	// window has a desktop set. convert it to tag
	if (d < TAGS)
		c->cache->tags |= desktop_to_tag(d);
	else
	if (d == 0xffffffff)
		c->cache->tags = 0;
}

// if client is new or has changed state since we last looked, tweak stuff
void client_full_review(client *c)
{
	client_review_border(c);
	client_review_nws_actions(c);
	client_review_position(c);
	client_review_desktop(c);
}

// configure a client's frame color
void client_redecorate(client *c)
{
	if (!c->decorate) return;

	char *border = config_border_blur;
	if (c->urgent) border = config_border_attention;
	if (c->active) border = config_border_focus;

	box_color(c->cache->frame, border);
	box_draw(c->cache->frame);

	if (!c->titlebar_height) return;
	client_descriptive_data(c);

	textbox_text(c->cache->title, c->title);
	textbox_moveresize(c->cache->title, 0, c->border_width, c->w, c->titlebar_height);

	textbox_font(c->cache->title, config_titlebar_font,
		c->active ? config_titlebar_focus: config_titlebar_blur,
		c->active ? config_border_focus  : config_border_blur);

	textbox_draw(c->cache->title);
}

// update client border to blurred
void client_deactivate(client *c, client *a)
{
	int was_active = c->active;

	c->active = 0;
	client_redecorate(c);

	if (was_active && c->visible && client_rule(c, (RULE_AUTOMINI|RULE_AUTOLOWER)))
	{
		bool trans = 0;
		// check whether the active window is one of our family
		while (a && !trans && a->trans != None)
		{
			if (a->trans == c->window) trans = 1;
			a = client_create(a->trans);
		}
		if (!trans)
		{
			client_lower(c, 0);
			winlist_forget(windows_activated, c->window);
			winlist_prepend(windows_activated, c->window, NULL);
			if (client_rule(c, RULE_AUTOMINI)) client_minimize(c);
		}
	}
}

// raise and focus a client
void client_activate(client *c, int raise, int warp)
{
	int i; Window w; client *o;

	// deactivate everyone else
	clients_ascend(windows_in_play(), i, w, o) if (w != c->window) client_deactivate(o, c);

	if (c->minimized) client_restore(c);
	if (c->shaded) client_reveal(c);

	// setup ourself
	if (config_raise_mode == RAISEFOCUS || raise)
		client_raise(c, client_has_state(c, netatoms[_NET_WM_STATE_FULLSCREEN]));

	// focus a window politely if possible
	client_protocol_event(c, atoms[WM_TAKE_FOCUS]);
	if (c->input) XSetInputFocus(display, c->window, RevertToPointerRoot, CurrentTime);
	else XSetInputFocus(display, PointerRoot, RevertToPointerRoot, CurrentTime);

	// we have recieved attention
	client_remove_state(c, netatoms[_NET_WM_STATE_DEMANDS_ATTENTION]);
	c->urgent = 0;

	// tell the user something happened
	if (!c->active && !c->trans)
		client_flash(c, config_border_focus, config_flash_ms, FLASHTITLEDEF);

	// update focus history order
	winlist_forget(windows_activated, c->window);
	winlist_append(windows_activated, c->window, NULL);
	ewmh_active_window(c->window);
	c->active = 1;

	// must happen last, after all move/resize/focus/raise stuff is sent
	if (config_warp_mode == WARPFOCUS || warp)
		client_warp_pointer(c);

	// set focus border color
	client_redecorate(c);
}

// set WM_STATE
void client_set_wm_state(client *c, unsigned long state)
{
	unsigned long payload[] = { state, None };
	XChangeProperty(display, c->window, atoms[WM_STATE], atoms[WM_STATE], 32, PropModeReplace, (unsigned char*)payload, 2);
}

unsigned long client_get_wm_state(client *c)
{
	unsigned long payload[2]; int items; Atom type;
	return window_get_prop(c->window, atoms[WM_STATE], &type, &items, payload, 2*sizeof(unsigned long)) && type == atoms[WM_STATE] && items > 0 ? payload[0]: 0;
}

// locate the currently focused window and build a client for it
client* client_active(unsigned int tag)
{
	int i; Window w; client *c = NULL, *o;
	// look for a visible, previously activated window in the current tag
	if (tag) clients_descend(windows_activated, i, w, o)
		if (o->manage && o->visible && o->cache->tags & tag) { c = o; break; }
	// look for a visible, previously activated window anywhere
	if (!c) clients_descend(windows_activated, i, w, o)
		if (o->manage && o->visible) { c = o; break; }
	// otherwise look for any visible, manageable window
	if (!c) managed_descend(i, w, o) { c = o; break; }
	// if we found one, activate it
	if (c && (!c->focus || !c->active))
		client_activate(c, RAISEDEF, WARPDEF);
	return c;
}

// horizontal and vertical window size locking
void client_toggle_vlock(client *c)
{
	c->cache->vlock = c->cache->vlock ? 0:1;
	client_flash(c, c->cache->vlock ? config_flash_on: config_flash_off, config_flash_ms, FLASHTITLEDEF);
}
void client_toggle_hlock(client *c)
{
	c->cache->hlock = c->cache->hlock ? 0:1;
	client_flash(c, c->cache->hlock ? config_flash_on: config_flash_off, config_flash_ms, FLASHTITLEDEF);
}

// go fullscreen on current monitor
void client_nws_fullscreen(client *c, int action)
{
	int state = client_has_state(c, netatoms[_NET_WM_STATE_FULLSCREEN]);

	if (action == ADD || (action == TOGGLE && !state))
	{
		c->cache->hlock = 0;
		c->cache->vlock = 0;
		client_commit(c);
		client_save_position(c);
		client_add_state(c, netatoms[_NET_WM_STATE_FULLSCREEN]);
		c->border_width = 0;
		// _NET_WM_STATE_FULLSCREEN will override size
		client_moveresize(c, 0, c->x, c->y, c->w, c->h);
	}
	else
	if (action == REMOVE || (action == TOGGLE && state))
	{
		client_commit(c);
		client_remove_state(c, netatoms[_NET_WM_STATE_FULLSCREEN]);
		c = client_recreate(c->window);
		client_restore_position(c, 0, c->monitor.x + (c->monitor.w/4), c->monitor.y + (c->monitor.h/4), c->monitor.w/2, c->monitor.h/2);
	}
	// fullscreen may need to hide above windows
	if (c->active) client_activate(c, RAISE, WARPDEF);
}

// raise above other windows
void client_nws_above(client *c, int action)
{
	int state = client_has_state(c, netatoms[_NET_WM_STATE_ABOVE]);
	client_remove_state(c, netatoms[_NET_WM_STATE_BELOW]);

	if (action == ADD || (action == TOGGLE && !state))
	{
		client_add_state(c, netatoms[_NET_WM_STATE_ABOVE]);
		client_raise(c, 0);
		client_flash(c, config_flash_on, config_flash_ms, FLASHTITLEDEF);
	}
	else
	if (action == REMOVE || (action == TOGGLE && state))
	{
		client_remove_state(c, netatoms[_NET_WM_STATE_ABOVE]);
		client_flash(c, config_flash_off, config_flash_ms, FLASHTITLEDEF);
	}
}

// lower below other windows
void client_nws_below(client *c, int action)
{
	int state = client_has_state(c, netatoms[_NET_WM_STATE_BELOW]);
	client_remove_state(c, netatoms[_NET_WM_STATE_ABOVE]);

	if (action == ADD || (action == TOGGLE && !state))
	{
		client_add_state(c, netatoms[_NET_WM_STATE_BELOW]);
		client_lower(c, 0);
		client_flash(c, config_flash_on, config_flash_ms, FLASHTITLEDEF);
	}
	else
	if (action == REMOVE || (action == TOGGLE && state))
	{
		client_remove_state(c, netatoms[_NET_WM_STATE_BELOW]);
		client_flash(c, config_flash_off, config_flash_ms, FLASHTITLEDEF);
	}
}

// stick to screen
void client_nws_sticky(client *c, int action)
{
	int state = client_has_state(c, netatoms[_NET_WM_STATE_STICKY]);

	if (action == ADD || (action == TOGGLE && !state))
	{
		client_add_state(c, netatoms[_NET_WM_STATE_STICKY]);
		client_raise(c, 0);
		client_flash(c, config_flash_on, config_flash_ms, FLASHTITLEDEF);
	}
	else
	if (action == REMOVE || (action == TOGGLE && state))
	{
		client_remove_state(c, netatoms[_NET_WM_STATE_STICKY]);
		client_flash(c, config_flash_off, config_flash_ms, FLASHTITLEDEF);
	}
}

// maximize vertically
void client_nws_maxvert(client *c, int action)
{
	client_extended_data(c);
	int state = client_has_state(c, netatoms[_NET_WM_STATE_MAXIMIZED_VERT]);

	if (action == ADD || (action == TOGGLE && !state))
	{
		c->cache->vlock = 0;
		client_commit(c);
		client_save_position_vert(c);
		client_add_state(c, netatoms[_NET_WM_STATE_MAXIMIZED_VERT]);
		client_moveresize(c, MR_SMART, c->x, c->y, c->w, c->monitor.h);
		client_flash(c, config_flash_on, config_flash_ms, FLASHTITLEDEF);
	}
	else
	if (action == REMOVE || (action == TOGGLE && state))
	{
		client_commit(c);
		client_remove_state(c, netatoms[_NET_WM_STATE_MAXIMIZED_VERT]);
		client_restore_position_vert(c, 0, c->monitor.y + (c->monitor.h/4), c->monitor.h/2);
		client_flash(c, config_flash_off, config_flash_ms, FLASHTITLEDEF);
	}
}

// maximize horizontally
void client_nws_maxhorz(client *c, int action)
{
	client_extended_data(c);
	int state = client_has_state(c, netatoms[_NET_WM_STATE_MAXIMIZED_HORZ]);

	if (action == ADD || (action == TOGGLE && !state))
	{
		c->cache->hlock = 0;
		client_commit(c);
		client_save_position_horz(c);
		client_add_state(c, netatoms[_NET_WM_STATE_MAXIMIZED_HORZ]);
		client_moveresize(c, MR_SMART, c->x, c->y, c->monitor.w, c->h);
		client_flash(c, config_flash_on, config_flash_ms, FLASHTITLEDEF);
	}
	else
	if (action == REMOVE || (action == TOGGLE && state))
	{
		client_commit(c);
		client_remove_state(c, netatoms[_NET_WM_STATE_MAXIMIZED_HORZ]);
		client_restore_position_horz(c, 0, c->monitor.x + (c->monitor.w/4), c->monitor.w/2);
		client_flash(c, config_flash_off, config_flash_ms, FLASHTITLEDEF);
	}
}

// look for windows tiled horizontally with *c
winlist* clients_tiled_horz_with(client *c)
{
	client_extended_data(c);
	int i; Window w; client *o;
	winlist *tiles = winlist_new();
	winlist_append(tiles, c->window, NULL);
	int vague = MAX(c->monitor.w/100, c->monitor.h/100);
	int min_x = c->x, max_x = c->x + c->w, tlen = 0;
	while (tlen != tiles->len)
	{
		tlen = tiles->len;
		tag_descend(i, w, o, c->cache->tags)
		{
			// window is not already found, and is on the same horizontal alignment
			if (c->window != w && winlist_find(tiles, w) < 0 && NEAR(c->y, vague, o->y)
				// window has roughly the same width and height, and aligned with a known left/right edge
				&& NEAR(c->w, vague, o->w) && NEAR(c->h, vague, o->h) && (NEAR(min_x, vague, o->x+o->w) || NEAR(max_x, vague, o->x)))
					{ winlist_append(tiles, w, NULL); min_x = MIN(o->x, min_x); max_x = MAX(o->x+o->w, max_x); }
		}
	}
	return tiles;
}

// look for windows tiled vertically with *c
winlist* clients_tiled_vert_with(client *c)
{
	client_extended_data(c);
	int i; Window w; client *o;
	winlist *tiles = winlist_new();
	winlist_append(tiles, c->window, NULL);
	int vague = MAX(c->monitor.w/100, c->monitor.h/100);
	int min_y = c->y, max_y = c->y + c->h, tlen = 0;
	// locate adjacent windows with the same tag, size, and vertical position
	while (tlen != tiles->len)
	{
		tlen = tiles->len;
		tag_descend(i, w, o, c->cache->tags)
			// window is not already found, and is on the same vertical alignment
			if (c->window != w && winlist_find(tiles, w) < 0 && NEAR(c->x, vague, o->x)
				// window has roughly the same width and height, and aligned with a known top/bottom edge
				&& NEAR(c->w, vague, o->w) && NEAR(c->h, vague, o->h) && (NEAR(min_y, vague, o->y+o->h) || NEAR(max_y, vague, o->y)))
					{ winlist_append(tiles, w, NULL); min_y = MIN(o->y, min_y); max_y = MAX(o->y+o->h, max_y); }
	}
	return tiles;
}

// look for windows tiled with *c
winlist* clients_tiled_with(client *c)
{
	int i, j; Window w, ww; client *o;
	winlist *tiles = clients_tiled_horz_with(c);
	clients_ascend(tiles, i, w, o)
	{
		winlist *vtiles = clients_tiled_vert_with(o);
		winlist_ascend(vtiles, j, ww) if (winlist_find(tiles, ww) < 0)
			winlist_append(tiles, ww, NULL);
		winlist_free(vtiles);
	}
	return tiles;
}

// extend client_acivate() behavior to work with groups of tiled windows
void client_switch_to(client *c)
{
	int i; Window w; client *o;

	// smart tile mode detects windows tiled with the client and treats the whole group as one
	if (config_tile_mode == TILESMART)
	{
		winlist *tiles = clients_tiled_with(c);
		clients_ascend(tiles, i, w, o) if (o->window != c->window)
			client_activate(o, RAISE, WARPDEF);
		winlist_free(tiles);
	}

	client_activate(c, RAISE, WARPDEF);
}

// cycle through tag windows in roughly the same screen position and tag
void client_cycle(client *c)
{
	int i; Window w; client *o;

	// find an intersecting client near the bottom of the stack to raise
	tag_ascend(i, w, o, current_tag)
		if (w != c->window && clients_intersect(c, o))
			{ client_switch_to(o); return; }

	tag_ascend(i, w, o, c->cache->tags)
		if (w != c->window && clients_intersect(c, o))
			{ client_switch_to(o); return; }

	// nothing to cycle. do something visual to acknowledge key press
	client_flash(c, config_border_focus, config_flash_ms, FLASHTITLEDEF);
}

// horizontally tile two windows in the same screen position and tag
void client_htile(client *c)
{
	client_extended_data(c);
	winlist *tiles = winlist_new();
	winlist_append(tiles, c->window, NULL);
	int i, vague = MAX(c->monitor.w/100, c->monitor.h/100); Window w; client *o;
	// locate windows with same tag, size, and position
	tag_descend(i, w, o, current_tag|c->cache->tags) if (c->window != w)
		if (NEAR(c->x, vague, o->x) && NEAR(c->y, vague, o->y) && NEAR(c->w, vague, o->w) && NEAR(c->h, vague, o->h))
			winlist_append(tiles, w, NULL);
	if (tiles->len > 1)
	{
		int width = c->w / tiles->len;
		clients_ascend(tiles, i, w, o)
		{
			client_commit(o);
			client_remove_state(o, netatoms[_NET_WM_STATE_MAXIMIZED_HORZ]);
			client_moveresize(o, 0, c->x+(width*i), c->y, width, c->h);
		}
	}
	winlist_free(tiles);
}

// find windows tiled horizontally and restack them
void client_huntile(client *c)
{
	int i; Window w; client *o;
	client_extended_data(c);
	winlist *tiles = clients_tiled_horz_with(c);
	if (tiles->len > 1)
	{
		int min_x = c->x, max_x = c->x+c->h;
		clients_ascend(tiles, i, w, o)
		{
			client_extended_data(o);
			min_x = MIN(min_x, o->x);
			max_x = MAX(max_x, o->x+o->w);
		}
		clients_ascend(tiles, i, w, o)
		{
			client_commit(o);
			client_remove_state(o, netatoms[_NET_WM_STATE_MAXIMIZED_HORZ]);
			client_moveresize(o, 0, min_x, c->y, max_x-min_x, c->h);
		}
	}
	winlist_free(tiles);
}

// vertically tile two windows in the same screen position and tag
void client_vtile(client *c)
{
	client_extended_data(c);
	winlist *tiles = winlist_new();
	winlist_append(tiles, c->window, NULL);
	int i, vague = MAX(c->monitor.w/100, c->monitor.h/100); Window w; client *o;
	// locate windows with same tag, size, and position
	tag_descend(i, w, o, current_tag|c->cache->tags) if (c->window != w)
		if (NEAR(c->x, vague, o->x) && NEAR(c->y, vague, o->y) && NEAR(c->w, vague, o->w) && NEAR(c->h, vague, o->h))
			winlist_append(tiles, w, NULL);
	if (tiles->len > 1)
	{
		int height = c->h / tiles->len;
		clients_ascend(tiles, i, w, o)
		{
			client_commit(o);
			client_remove_state(o, netatoms[_NET_WM_STATE_MAXIMIZED_VERT]);
			client_moveresize(o, 0, c->x, c->y+(height*i), c->w, height);
		}
	}
	winlist_free(tiles);
}

// find windows tiled vertically and restack them
void client_vuntile(client *c)
{
	int i; Window w; client *o;
	client_extended_data(c);
	winlist *tiles = clients_tiled_vert_with(c);
	if (tiles->len > 1)
	{
		int min_y = c->y, max_y = c->y+c->h;
		clients_ascend(tiles, i, w, o)
		{
			client_extended_data(o);
			min_y = MIN(min_y, o->y);
			max_y = MAX(max_y, o->y+o->h);
		}
		clients_ascend(tiles, i, w, o)
		{
			client_commit(o);
			client_remove_state(o, netatoms[_NET_WM_STATE_MAXIMIZED_HORZ]);
			client_moveresize(o, 0, c->x, min_y, c->w, max_y-min_y);
		}
	}
	winlist_free(tiles);
}

// find client by direction. this is a visual thing
client* client_over_there_ish(client *c, int direction)
{
	client_extended_data(c);
	int i, large = 10000; Window w; client *o;

	workarea zone; memset(&zone, 0, sizeof(workarea));
	if (direction == FOCUSLEFT)
		{ zone.x = 0-large; zone.y = 0-large; zone.w = large + c->x + c->w/2; zone.h = large*2; }
	if (direction == FOCUSRIGHT)
		{ zone.x = c->x+c->w/2; zone.y = 0-large; zone.w = c->w/2 + large; zone.h = large*2; }
	if (direction == FOCUSUP)
		{ zone.x = 0-large; zone.y = 0-large; zone.w = large*2; zone.h = large + c->y + c->h/2; }
	if (direction == FOCUSDOWN)
		{ zone.x = 0-large; zone.y = c->y+c->h/2; zone.w = large*2; zone.h = c->h/2 + large; }

	winlist *consider = clients_partly_visible(&zone, current_tag|c->cache->tags, None);

	client *m = NULL;
	// client that overlaps preferred
	clients_descend(consider, i, w, o) if (w != c->window && o->manage)
	{
		client_extended_data(o);
		int overlap_x = OVERLAP(c->y, c->h, o->y, o->h);
		int overlap_y = OVERLAP(c->x, c->w, o->x, o->w);
		if (direction == FOCUSLEFT  && overlap_x && (!m || o->x+o->w/2 > m->x+m->w/2)) m = o;
		if (direction == FOCUSRIGHT && overlap_x && (!m || o->x+o->w/2 < m->x+m->w/2)) m = o;
		if (direction == FOCUSUP    && overlap_y && (!m || o->y+o->h/2 > m->y+m->h/2)) m = o;
		if (direction == FOCUSDOWN  && overlap_y && (!m || o->y+o->h/2 < m->y+m->h/2)) m = o;
	}
	// otherwise, the closest one
	if (!m) clients_descend(consider, i, w, o) if (w != c->window && o->manage)
	{
		client_extended_data(o);
		if (!m) m = o;
		if (direction == FOCUSLEFT  && o->x+o->w/2 > m->x+m->w/2) m = o;
		if (direction == FOCUSRIGHT && o->x+o->w/2 < m->x+m->w/2) m = o;
		if (direction == FOCUSUP    && o->y+o->h/2 > m->y+m->h/2) m = o;
		if (direction == FOCUSDOWN  && o->y+o->h/2 < m->y+m->h/2) m = o;
	}
	winlist_free(consider);
	return m;
}

// switch focus by direction
void client_focusto(client *c, int direction)
{
	client *match = client_over_there_ish(c, direction);
	if (match) client_activate(match, RAISEDEF, WARPDEF);
}

// swap client position with another by direction
void client_swapto(client *c, int direction)
{
	client_extended_data(c);
	client *m = client_over_there_ish(c, direction);
	// limit to the same monitor. gets weird otherwise...
	if (m && c->monitor.x == m->monitor.x && c->monitor.y == m->monitor.y)
	{
		client_extended_data(m);
		int cx = c->x, cy = c->y, cw = c->w, ch = c->h, mx = m->x, my = m->y, mw = m->w, mh = m->h;
		int overlap_x = OVERLAP(c->y, c->h, m->y, m->h);
		int overlap_y = OVERLAP(c->x, c->w, m->x, m->w);

		if (((direction == FOCUSLEFT || direction == FOCUSRIGHT) && overlap_x) ||
			((direction == FOCUSUP  || direction == FOCUSDOWN ) && overlap_y))
		{
			client_commit(c); client_commit(m);

			// swap EWMH states
			Atom state[CLIENTSTATE]; int states = c->states;
			memmove(&state, c->state,     sizeof(state));
			memmove(&c->state, &m->state, sizeof(state));
			memmove(&m->state, &state,    sizeof(state));
			c->states = m->states; m->states = states;
			client_flush_state(c); client_flush_state(m);

			// swap positions
			client_moveresize(c, 0, mx, my, mw, mh);
			client_moveresize(m, 0, cx, cy, cw, ch);

			// ensure we can be seen
			client_raise(c, 0);
			client_raise_under(m, c);
		}
	}
}

// place a window over the active window
void client_replace(client *c)
{
	client *a = client_active(0);
	if (a)
	{
		client_commit(c);
		client_moveresize(c, 0, a->x, a->y, a->w, a->h);
	}
}

// resize window to match the one underneath
void client_duplicate(client *c)
{
	int i; Window w; client *o; client_commit(c);
	tag_descend(i, w, o, 0)
		if (c->window != w && clients_intersect(c, o))
			{ client_moveresize(c, 0, o->x, o->y, o->w, o->h); return; }
}

void client_minimize(client *c)
{
	XUnmapWindow(display, c->window);
	if (c->decorate) box_show(c->cache->frame);
	// no update fo windows_activated yet. see handle_unmapnotify()
	winlist_forget(windows_minimized, c->window);
	winlist_append(windows_minimized, c->window, NULL);
	client_add_state(c, netatoms[_NET_WM_STATE_HIDDEN]);
	c->minimized = 1; c->visible = 0;

	// also minimize any transients
	int i; Window w; client *o;
	managed_descend(i, w, o)
		if (o->trans == c->window && o->visible && !o->minimized && !o->shaded)
			client_minimize(o);
}

void client_restore(client *c)
{
	XMapWindow(display, c->window);
	if (c->decorate) box_show(c->cache->frame);
	// no update fo windows_minimized yet. see handle_mapnotify()
	winlist_forget(windows_activated, c->window);
	winlist_prepend(windows_activated, c->window, NULL);
	c->minimized = 0; c->shaded = 0; c->visible = 1;

	// also restore any transients
	int i; Window w; client *o;
	clients_descend(windows_minimized, i, w, o)
		if (o->trans == c->window) client_restore(o);
}

void client_shade(client *c)
{
	XUnmapWindow(display, c->window);
	if (c->decorate) box_hide(c->cache->frame);
	// no update fo windows_activated yet. see handle_unmapnotify()
	winlist_forget(windows_shaded, c->window);
	winlist_append(windows_shaded, c->window, NULL);
	client_add_state(c, netatoms[_NET_WM_STATE_SHADED]);
	c->shaded = 1; c->visible = 0;

	// also shade any transients
	int i; Window w; client *o;
	managed_descend(i, w, o)
		if (o->trans == c->window && o->visible && !o->minimized && !o->shaded)
			client_shade(o);
}

void client_reveal(client *c)
{
	client_restore(c);

	// also restore any transients
	int i; Window w; client *o;
	clients_descend(windows_shaded, i, w, o)
		if (o->trans == c->window) client_restore(o);
}

// built-in window switcher
void client_switcher(unsigned int tag)
{
	// TODO: this whole function is messy. build a nicer solution
	char pattern[50], **list = NULL;
	int i, type, classfield = 0, maxtags = 0, lines = 0, above = 0, sticky = 0, minimized = 0, plen = 0;
	Window w; client *c; winlist *ids = winlist_new();

	// type=0 normal windows
	// type=1 shaded windows
	// type=2 minimized windows
	for (type = 0; type < 3; type++)
	{
		winlist *l = windows_activated;
		if (type == 1) l = windows_shaded;
		if (type == 2) l = windows_minimized;
		// calc widths of wm_class and tag csv fields
		clients_descend(l, i, w, c)
		{
			if (c->manage && (c->visible || c->minimized || c->shaded) && !client_has_state(c, netatoms[_NET_WM_STATE_SKIP_TASKBAR]))
			{
				client_descriptive_data(c);
				if (!tag || (c->cache && c->cache->tags & tag))
				{
					if (c->minimized) minimized = 1;
					if (client_has_state(c, netatoms[_NET_WM_STATE_ABOVE])) above = 1;
					if (client_has_state(c, netatoms[_NET_WM_STATE_STICKY])) sticky = 1;
					int j, t; for (j = 0, t = 0; j < TAGS; j++)
						if (c->cache->tags & (1<<j)) t++;
					maxtags = MAX(maxtags, t);
					classfield = MAX(classfield, strlen(c->class));
					winlist_append(ids, c->window, NULL);
					lines++;
				}
			}
		}
	}
	// truncate silly java WM_CLASS strings
	classfield = MAX(5, MIN(classfield, 14));
	maxtags = MAX(0, (maxtags*2)-1);
	if (above || sticky || minimized) plen = sprintf(pattern, "%%-%ds  ", above+sticky+minimized);
	if (maxtags) plen += sprintf(pattern+plen, "%%-%ds  ", maxtags);
	plen += sprintf(pattern+plen, "%%-%ds   %%s", classfield);
	list = allocate_clear(sizeof(char*) * (lines+1)); lines = 0;
	// build the actual list
	clients_ascend(ids, i, w, c)
	{
		client_descriptive_data(c);
		if (!tag || (c->cache && c->cache->tags & tag))
		{
			char tags[32]; memset(tags, 0, 32);
			int j, l; for (l = 0, j = 0; j < TAGS; j++)
				if (c->cache->tags & (1<<j)) l += sprintf(tags+l, "%d,", j+1);
			if (l > 0) tags[l-1] = '\0';

			char aos[6]; memset(aos, 0, 6);
			if (client_has_state(c, netatoms[_NET_WM_STATE_ABOVE])) strcat(aos, "a");
			if (client_has_state(c, netatoms[_NET_WM_STATE_STICKY])) strcat(aos, "s");
			if (c->minimized) strcat(aos, "m");

			char class[15]; memset(class, 0, 15); int clen = strlen(c->class);
			strncpy(class, c->class, MIN(14, clen)); if (clen > 14) strcpy(class+11, "...");

			char *line = allocate(strlen(c->title) + strlen(tags) + strlen(c->class) + classfield + 50);
			if ((above || sticky || minimized) && maxtags) sprintf(line, pattern, aos, tags, class, c->title);
			else if (maxtags) sprintf(line, pattern, tags, class, c->title);
			else sprintf(line, pattern, class, c->title);
			list[lines++] = line;
		}
	}
	if (!fork())
	{
		display = XOpenDisplay(0);
		XSync(display, True);
		char *input = NULL;
		int n = menu(list, &input, "> ", 1);
		if (n >= 0 && list[n])
			window_send_message(root, ids->array[n], netatoms[_NET_ACTIVE_WINDOW], 2, // 2 = pager
				SubstructureNotifyMask | SubstructureRedirectMask);
		else
		if (input) exec_cmd(input);
		exit(EXIT_SUCCESS);
	}
	for (i = 0; i < lines; i++) free(list[i]);
	free(list); winlist_free(ids);
}

// toggle client in current tag
void client_toggle_tag(client *c, unsigned int tag, int flash)
{
	if (c->cache->tags & tag)
	{
		c->cache->tags &= ~tag;
		if (flash) client_flash(c, config_flash_off, config_flash_ms, FLASHTITLEDEF);
	} else
	{
		c->cache->tags |= tag;
		if (flash) client_flash(c, config_flash_on, config_flash_ms, FLASHTITLEDEF);
	}
	// update _NET_WM_DESKTOP using lowest tag number.
	// this is a bit of a fudge as we can have windows on multiple
	// tags/desktops, without being specifically sticky... oh well.
	unsigned long d = tag_to_desktop(c->cache->tags);
	window_set_cardinal_prop(c->window, netatoms[_NET_WM_DESKTOP], &d, 1);
}

// search for first open window matching class/name/title
client* client_find(char *pattern)
{
	if (!pattern) return None;
	int i; Window w; client *c = NULL, *found = NULL;

	// use a tempoarary rule for searching
	rule_parse(pattern);
	winrule *rule = config_rules;
	config_rules = rule->next;

	// first, try in current_tag only
	tag_descend(i, w, c, current_tag)
		if (client_rule_match(c, rule)) { found = c; break; }
	// look for something minimized or shaded
	if (!found) clients_descend(windows_minimized, i, w, c)
		if (c->cache->tags & current_tag && client_rule_match(c, rule))
			{ found = c; client_restore(c); break; }
	if (!found) clients_descend(windows_shaded, i, w, c)
		if (c->cache->tags & current_tag && client_rule_match(c, rule))
			{ found = c; client_restore(c); break; }
	// failing that, search regardless of tag
	if (!found) managed_descend(i, w, c)
		if (client_rule_match(c, rule)) { found = c; break; }
	if (!found) clients_descend(windows_minimized, i, w, c)
		if (client_rule_match(c, rule)) { found = c; client_restore(c); break; }
	if (!found) clients_descend(windows_shaded, i, w, c)
		if (client_rule_match(c, rule)) { found = c; client_restore(c); break; }

	rule_free(rule);
	return found;
}

// execute a pattern as a shell command
void client_start(char *pattern)
{
	if (regquick("^(class|name|title):", pattern))
		pattern = strchr(pattern, ':')+1;
	exec_cmd(pattern);
}

// search for and activate first open window matching class/name/title
void client_find_or_start(char *pattern)
{
	if (!pattern) return;
	client *c = client_find(pattern);
	if (c) client_switch_to(c);
	else client_start(pattern);
}

void client_rules_ewmh(client *c)
{
	// process EWMH rules
	// above below are mutally exclusize
		if (client_rule(c, RULE_ABOVE)) client_add_state(c, netatoms[_NET_WM_STATE_ABOVE]);
	else if (client_rule(c, RULE_BELOW)) client_add_state(c, netatoms[_NET_WM_STATE_BELOW]);

	// sticky,skip_taskbar,skip_pager can be on anything
	if (client_rule(c, RULE_STICKY))   client_add_state(c, netatoms[_NET_WM_STATE_STICKY]);
	if (client_rule(c, RULE_SKIPTBAR)) client_add_state(c, netatoms[_NET_WM_STATE_SKIP_TASKBAR]);
	if (client_rule(c, RULE_SKIPPAGE)) client_add_state(c, netatoms[_NET_WM_STATE_SKIP_PAGER]);

	// fullscreen overrides max h/v
	if (client_rule(c, RULE_FULLSCREEN))
		client_add_state(c, netatoms[_NET_WM_STATE_FULLSCREEN]);
	else
	// max h/v overrides lock h/v
	if (client_rule(c, RULE_MAXHORZ|RULE_MAXVERT))
	{
		if (client_rule(c, RULE_MAXHORZ)) client_add_state(c, netatoms[_NET_WM_STATE_MAXIMIZED_HORZ]);
		if (client_rule(c, RULE_MAXVERT)) client_add_state(c, netatoms[_NET_WM_STATE_MAXIMIZED_VERT]);
	}
}

void client_rules_monitor(client *c)
{
	if (client_rule(c, RULE_MONITOR1|RULE_MONITOR2|RULE_MONITOR3))
	{
		client_extended_data(c);
		XineramaScreenInfo *info; int monitors;
		workarea mon; memset(&mon, 0, sizeof(workarea));
		if ((info = XineramaQueryScreens(display, &monitors)))
		{
			if (client_rule(c, RULE_MONITOR1) && monitors > 0)
				monitor_dimensions_struts(info[0].x_org+1, info[0].y_org+1, &mon);
			if (client_rule(c, RULE_MONITOR2) && monitors > 1)
				monitor_dimensions_struts(info[1].x_org+1, info[1].y_org+1, &mon);
			if (client_rule(c, RULE_MONITOR3) && monitors > 2)
				monitor_dimensions_struts(info[2].x_org+1, info[2].y_org+1, &mon);
			XFree(info);
		}
		// only move the window if the monitor has changed. this preserves PLACEPOINTER if
		// the target monitor == the active monitor
		if (mon.w && (mon.x != c->monitor.x || mon.y != c->monitor.y))
		{
			memmove(&c->monitor, &mon, sizeof(workarea));
			client_moveresize(c, 0, MAX(mon.x, mon.x + ((mon.w - c->w) / 2)),
				MAX(mon.y, mon.y + ((mon.h - c->h) / 2)), c->w, c->h);
		}
	}
}

void client_rules_moveresize(client *c)
{
	client_extended_data(c);
	int mr = 0;

	// if a size rule exists, apply it
	if (client_rule(c, RULE_SMALL|RULE_MEDIUM|RULE_LARGE|RULE_COVER|RULE_SIZE))
	{
		int w_small = c->monitor.w/3, h_small = c->monitor.h/3;
		if (client_rule(c, RULE_SMALL))  { c->w = w_small; c->h = h_small; }
		if (client_rule(c, RULE_MEDIUM)) { c->w = c->monitor.w/2; c->h = c->monitor.h/2; }
		if (client_rule(c, RULE_LARGE))  { c->w = c->monitor.w-w_small; c->h = c->monitor.h-h_small; }
		if (client_rule(c, RULE_COVER))  { c->w = c->monitor.w; c->h = c->monitor.h; }
		if (client_rule(c, RULE_SIZE))
		{
			c->w = c->rule->w_is_pct ? c->monitor.w/100*c->rule->w: c->rule->w;
			c->h = c->rule->h_is_pct ? c->monitor.h/100*c->rule->h: c->rule->h;
		}
		mr = 1;
	}
	//  if a placement rule exists, it trumps everything
	if (client_rule(c, RULE_TOP|RULE_LEFT|RULE_RIGHT|RULE_BOTTOM|RULE_CENTER|RULE_POINTER))
	{
		c->x = MAX(c->monitor.x, c->monitor.x + ((c->monitor.w - c->w) / 2));
		c->y = MAX(c->monitor.y, c->monitor.y + ((c->monitor.h - c->h) / 2));
		// center first, so others can combine with it
		if (client_rule(c, RULE_CENTER))
		{
			c->x = c->monitor.x + (c->monitor.w - c->w)/2;
			c->y = c->monitor.y + (c->monitor.h - c->h)/2;
		}
		if (client_rule(c, RULE_POINTER))
		{
			int x, y; pointer_get(&x, &y);
			workarea a; monitor_dimensions_struts(x, y, &a);
			c->x = MAX(a.x, x-(c->w/2));
			c->y = MAX(a.y, y-(c->h/2));
		}
		if (client_rule(c, RULE_BOTTOM)) c->y = c->monitor.y + c->monitor.h - c->h;
		if (client_rule(c, RULE_RIGHT))  c->x = c->monitor.x + c->monitor.w - c->w;
		if (client_rule(c, RULE_TOP))    c->y = c->monitor.y;
		if (client_rule(c, RULE_LEFT))   c->x = c->monitor.x;
		mr = 1;
	}
	if (mr) client_moveresize(c, 0, c->x, c->y, c->w, c->h);
}

// h/v lock must occur after the first client_moveresize
void client_rules_locks(client *c)
{
	if (client_rule(c, RULE_HLOCK|RULE_VLOCK))
	{
		if (!client_rule(c, RULE_MAXHORZ) && client_rule(c, RULE_HLOCK)) c->cache->hlock = 1;
		if (!client_rule(c, RULE_MAXVERT) && client_rule(c, RULE_VLOCK)) c->cache->vlock = 1;
	}
}

// apply tags
void client_rules_tags(client *c)
{
	if (client_rule(c, (TAG1|TAG2|TAG3|TAG4|TAG5|TAG6|TAG7|TAG8|TAG9)))
	{
		c->cache->tags = 0;
		client_toggle_tag(c, c->rule->flags & (TAG1|TAG2|TAG3|TAG4|TAG5|TAG6|TAG7|TAG8|TAG9), NOFLASH);
	}
}

// post-placement rules
void client_rules_moveresize_post(client *c)
{
	unsigned int tag = current_tag; current_tag = desktop_to_tag(tag_to_desktop(c->cache->tags));
	if (client_rule(c, RULE_SNAPRIGHT)) client_snapto(c, SNAPRIGHT);
	if (client_rule(c, RULE_SNAPLEFT))  client_snapto(c, SNAPLEFT);
	if (client_rule(c, RULE_SNAPDOWN))  client_snapto(c, SNAPDOWN);
	if (client_rule(c, RULE_SNAPUP))    client_snapto(c, SNAPUP);
	// yes, can do both contract and expand in one rule. it makes sense...
	if (client_rule(c, RULE_CONTRACT))  client_contract(c, HORIZONTAL|VERTICAL);
	if (client_rule(c, RULE_EXPAND))    client_expand(c, HORIZONTAL|VERTICAL, 0, 0, 0, 0, 0, 0, 0, 0);
	if (client_rule(c, RULE_REPLACE))   client_replace(c);
	if (client_rule(c, RULE_DUPLICATE)) client_duplicate(c);
	// tiling
	if (client_rule(c, RULE_HUNTILE)) client_huntile(c);
	if (client_rule(c, RULE_HTILE))   client_htile(c);
	if (client_rule(c, RULE_VUNTILE)) client_vuntile(c);
	if (client_rule(c, RULE_VTILE))   client_vtile(c);
	current_tag = tag;
}

// check and apply all possible rules to a client
void client_rules_apply(client *c, bool reset)
{
	if (client_rule(c, RULE_RESET) || reset)
	{
		client_remove_all_states(c);
		c->cache->vlock = 0;
		c->cache->hlock = 0;
	}

	client_rules_ewmh(c);
	client_rules_monitor(c);
	client_rules_moveresize(c);
	client_rules_locks(c);
	client_rules_tags(c);
	client_rules_moveresize_post(c);

	if (client_rule(c, RULE_LOWER)) client_lower(c, 0);
	if (client_rule(c, RULE_RAISE)) client_raise(c, 0);
	if (client_rule(c, RULE_RESTORE))  client_restore(c);
	if (client_rule(c, RULE_MINIMIZE)) client_minimize(c);
}

#ifdef DEBUG
// debug
void event_client_dump(client *c)
{
	if (!c) return;
	client_descriptive_data(c);
	client_extended_data(c);
	event_note("title: %s", c->title);
	event_note("class: %s name: %s", c->class, c->name);
	event_note("manage:%d input:%d focus:%d initial_state:%d decorate:%d urgent:%d", c->manage, c->input, c->focus, c->initial_state, c->decorate, c->urgent);
	event_note("x:%d y:%d w:%d h:%d b:%d override:%d transient:%x", c->xattr.x, c->xattr.y, c->xattr.width, c->xattr.height,
		c->xattr.border_width, c->xattr.override_redirect ?1:0, (unsigned int)c->trans);
	event_note("is_full:%d is_left:%d is_top:%d is_right:%d is_bottom:%d\n\tis_xcenter:%d is_ycenter:%d is_maxh:%d is_maxv:%d last_corner:%d",
		c->is_full, c->is_left, c->is_top, c->is_right, c->is_bottom, c->is_xcenter, c->is_ycenter, c->is_maxh, c->is_maxv, c->cache->last_corner);
	event_note("PMinSize:%d,%d,%d PMaxSize:%d,%d,%d PBaseSize:%d,%d,%d PResizeInc:%d,%d,%d PAspect:%d,%d/%d,%d/%d",
		(c->xsize.flags & PMinSize ? 1: 0),
			(c->xsize.flags & PMinSize ? c->xsize.min_width: 0),
			(c->xsize.flags & PMinSize ? c->xsize.min_height: 0),
		(c->xsize.flags & PMaxSize ? 1: 0),
			(c->xsize.flags & PMaxSize ? c->xsize.max_width: 0),
			(c->xsize.flags & PMaxSize ? c->xsize.max_height: 0),
		(c->xsize.flags & PBaseSize ? 1: 0),
			(c->xsize.flags & PBaseSize ? c->xsize.base_width: 0),
			(c->xsize.flags & PBaseSize ? c->xsize.base_height: 0),
		(c->xsize.flags & PResizeInc ? 1: 0),
			(c->xsize.flags & PResizeInc ? c->xsize.width_inc: 0),
			(c->xsize.flags & PResizeInc ? c->xsize.height_inc: 0),
		(c->xsize.flags & PAspect ? 1: 0),
			(c->xsize.flags & PAspect ? c->xsize.min_aspect.x: 0),
			(c->xsize.flags & PAspect ? c->xsize.min_aspect.y: 0),
			(c->xsize.flags & PAspect ? c->xsize.max_aspect.x: 0),
			(c->xsize.flags & PAspect ? c->xsize.max_aspect.y: 0));
	event_note("monitor: %d %d %d %d %d %d %d %d",
		c->monitor.x, c->monitor.y, c->monitor.w, c->monitor.h, c->monitor.l, c->monitor.r, c->monitor.t, c->monitor.b);
	int i, j;
	for (i = 0; i < NETATOMS; i++) if (c->type == netatoms[i]) event_note("type:%s", netatom_names[i]);
	for (i = 0; i < NETATOMS; i++) for (j = 0; j < c->states; j++) if (c->state[j] == netatoms[i]) event_note("state:%s", netatom_names[i]);
	unsigned long struts[12];
	if (window_get_cardinal_prop(c->window, netatoms[_NET_WM_STRUT_PARTIAL], struts, 12))
		event_note("strut partial: %d %d %d %d %d %d %d %d %d %d %d %d",
			struts[0],struts[1],struts[2],struts[3],struts[4],struts[5],struts[6],struts[7],struts[8],struts[9],struts[10],struts[11]);
	if (window_get_cardinal_prop(c->window, netatoms[_NET_WM_STRUT], struts, 4))
		event_note("strut: %d %d %d %d",
			struts[0],struts[1],struts[2],struts[3]);
	if (c->rule)
		event_note("rule: %lx", c->rule->flags);
	fflush(stdout);
}
#else
#define event_client_dump(...)
#endif