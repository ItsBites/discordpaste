#define _GNU_SOURCE

#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <monome.h>
#include "internal.h"
#include "platform.h"
#include "rotation.h"
#include "devices.h"

#ifndef LIBSUFFIX
#define LIBSUFFIX ".so"
#endif

#ifndef LIBDIR
#define LIBDIR "/usr/lib"
#endif

/**
 * private
 */

static monome_devmap_t *map_serial_to_device(const char *serial) {
	monome_devmap_t *m;
	int serialnum;

	for( m = mapping; m->sermatch; m++ )
		if( sscanf(serial, m->sermatch, &serialnum) )
			return m;

	return NULL;
}

/**
 * public
 */

monome_t *monome_open(const char *dev, ...) {
	monome_t *monome;
	monome_devmap_t *m;

	va_list arguments;
	char *serial, *proto;
	int error;

	if( !dev )
		return NULL;

	serial = NULL;
	m = NULL;

	/* first let's figure out which protocol to use */
	if( !strstr(dev, "://") ) {
		/* assume that the device is a tty...let's probe and see what device
		   we're dealing with */

		if( !(serial = monome_platform_get_dev_serial(dev)) )
			return NULL;

		if( (m = map_serial_to_device(serial)) )
			proto = m->proto;
		else
			return NULL;
	} else
		/* otherwise, we'll assume that what we have is an OSC URL.
		   in the future, maybe we'll have more protocol modules...something
		   to think about. */
		proto = "osc";

	if( !(monome = monome_platform_load_protocol(proto)) )
		goto err_init;

	va_start(arguments, dev);
	error = monome->open(monome, dev, serial, m, arguments);
	va_end(arguments);

	if( error )
		goto err_init;

	monome->proto = proto;

	if( !(monome->device = m_strdup(dev)) )
		goto err_nomem;

	monome->rotation = MONOME_ROTATE_0;
	return monome;

err_nomem:
	monome->free(monome);

err_init:
	if( serial ) m_free(serial);
	return NULL;
}

void monome_close(monome_t *monome) {
	assert(monome);

	if( monome->serial )
		m_free((char *) monome->serial);

	if( monome->device )
		m_free((char *) monome->device);

	monome->close(monome);
	monome_platform_free(monome);
}

const char *monome_get_serial(monome_t *monome) {
	return monome->serial;
}

const char *monome_get_devpath(monome_t *monome) {
	return monome->device;
}

const char *monome_get_friendly_name(monome_t *monome) {
	return monome->friendly;
}

const char *monome_get_proto(monome_t *monome) {
	return monome->proto;
}

int monome_get_rows(monome_t *monome) {
	if( ROTSPEC(monome).flags & ROW_COL_SWAP )
		return monome->cols;
	else
		return monome->rows;
}

int monome_get_cols(monome_t *monome) {
	if( ROTSPEC(monome).flags & ROW_COL_SWAP )
		return monome->rows;
	else
		return monome->cols;
}

monome_rotate_t monome_get_rotation(monome_t *monome) {
	return monome->rotation;
}

void monome_set_rotation(monome_t *monome, monome_rotate_t rotation) {
	monome->rotation = rotation & 3;
}

int monome_register_handler(monome_t *monome, monome_event_type_t event_type,
                            monome_event_callback_t cb, void *data) {
	monome_callback_t *handler;

	if( event_type >= MONOME_EVENT_MAX )
		return EINVAL;

	handler       = &monome->handlers[event_type];
	handler->cb   = cb;
	handler->data = data;

	return 0;
}

int monome_unregister_handler(monome_t *monome,
                              monome_event_type_t event_type) {
	return monome_register_handler(monome, event_type, NULL, NULL);
}

int monome_event_next(monome_t *monome, monome_event_t *e) {
	e->monome = monome;

	return monome->next_event(monome, e);
}

int monome_event_handle_next(monome_t *monome) {
	monome_callback_t *handler;
	monome_event_t e;
	int status;

	status = monome_event_next(monome, &e);
	if (status <= 0)
		return status;

	handler = &monome->handlers[e.event_type];

	if( !handler->cb )
		return 0;

	handler->cb(&e, handler->data);
	return 1;
}

int monome_get_fd(monome_t *monome) {
	return monome->fd;
}

#define REQUIRE(capability) if (!monome->capability) return -1

int monome_led_set(monome_t *monome, uint_t x, uint_t y, uint_t on) {
	REQUIRE(led);
	return monome->led->set(monome, x, y, on);
}

int monome_led_on(monome_t *monome, uint_t x, uint_t y) {
	REQUIRE(led);
	return monome_led_set(monome, x, y, 1);
}

int monome_led_off(monome_t *monome, uint_t x, uint_t y) {
	REQUIRE(led);
	return monome_led_set(monome, x, y, 0);
}

int monome_led_all(monome_t *monome, uint_t status) {
	REQUIRE(led);
	return monome->led->all(monome, status);
}

int monome_led_map(monome_t *monome, uint_t x_off, uint_t y_off,
                   const uint8_t *data) {
	REQUIRE(led);
	return monome->led->map(monome, x_off, y_off, data);
}

int monome_led_row(monome_t *monome, uint_t x_off, uint_t y,
				   size_t count, const uint8_t *data) {
	REQUIRE(led);
	return monome->led->row(monome, x_off, y, count, data);
}

int monome_led_col(monome_t *monome, uint_t x, uint_t y_off,
				   size_t count, const uint8_t *data) {
	REQUIRE(led);
	return monome->led->col(monome, x, y_off, count, data);
}

int monome_led_intensity(monome_t *monome, uint_t brightness) {
	REQUIRE(led);
	return monome->led->intensity(monome, brightness);
}

int monome_led_level_set(monome_t *monome, uint_t x, uint_t y, uint_t level) {
	REQUIRE(led_level);
	return monome->led_level->set(monome, x, y, level);
}

int monome_led_level_all(monome_t *monome, uint_t level) {
	REQUIRE(led_level);
	return monome->led_level->all(monome, level);
}

int monome_led_level_map(monome_t *monome, uint_t x_off, uint_t y_off,
                         const uint8_t *data) {
	REQUIRE(led_level);
	return monome->led_level->map(monome, x_off, y_off, data);
}

int monome_led_level_row(monome_t *monome, uint_t x_off, uint_t y,
                         size_t count, const uint8_t *data) {
	REQUIRE(led_level);
	return monome->led_level->row(monome, x_off, y, count, data);
}

int monome_led_level_col(monome_t *monome, uint_t x, uint_t y_off,
                         size_t count, const uint8_t *data) {
	REQUIRE(led_level);
	return monome->led_level->col(monome, x, y_off, count, data);
}

int monome_led_ring_set(monome_t *monome, uint_t ring, uint_t led,
                        uint_t level) {
	REQUIRE(led_ring);
	return monome->led_ring->set(monome, ring, led, level);
}

int monome_led_ring_all(monome_t *monome, uint_t ring, uint_t level) {
	REQUIRE(led_ring);
	return monome->led_ring->all(monome, ring, level);
}

int monome_led_ring_map(monome_t *monome, uint_t ring, const uint8_t *levels) {
	REQUIRE(led_ring);
	return monome->led_ring->map(monome, ring, levels);
}

int monome_led_ring_range(monome_t *monome, uint_t ring, uint_t start,
                          uint_t end, uint_t level) {
	REQUIRE(led_ring);
	return monome->led_ring->range(monome, ring, start, end, level);
}

int monome_tilt_enable(monome_t *monome, uint_t sensor) {
	REQUIRE(tilt);
	return monome->tilt->enable(monome, sensor);
}

int monome_tilt_disable(monome_t *monome, uint_t sensor) {
	REQUIRE(tilt);
	return monome->tilt->disable(monome, sensor);
}

#define _GNU_SOURCE

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include <poll.h>

#include <getopt.h>
#include <lo/lo.h>

#include <monome.h>
#include "platform.h"

#define DEFAULT_MONOME_DEVICE   "/dev/ttyUSB0"
#define DEFAULT_MONOME_PROTOCOL "series"

#define DEFAULT_OSC_PREFIX      "monome"
#define DEFAULT_OSC_SERVER_PORT "8080"
#define DEFAULT_OSC_APP_PORT    "8000"
#define DEFAULT_OSC_APP_HOST    "127.0.0.1"

#ifdef DEBUG
#define DPRINTF(...) fprintf(stderr, __VA_ARGS__)
#else
#define DPRINTF(...) ((void) 0)
#endif

typedef struct {
	monome_t *monome;
	lo_address *outgoing;
	lo_server *server;

	char *lo_prefix;
} ms_state;

ms_state state;

static void lo_error(int num, const char *error_msg, const char *path) {
	printf("monomeserial: lo server error %d in %s: %s\n",
		   num, path, error_msg);
	fflush(stdout);
}

static int osc_led_handler(const char *path, const char *types,
						   lo_arg **argv, int argc,
						   lo_message data, void *user_data) {
	monome_t *monome = user_data;

	if( (argc != 3 || strcmp("iii", types)) ||
		(argv[0]->i > 15 || argv[0]->i < 0) ||
		(argv[1]->i > 15 || argv[1]->i < 0) ||
		(argv[2]->i > 1  || argv[2]->i < 0) )
		return -1;

	return monome_led_set(monome, argv[0]->i, argv[1]->i, argv[2]->i);
}

static int osc_led_all_handler(const char *path, const char *types,
							 lo_arg **argv, int argc,
							 lo_message data, void *user_data) {
	monome_t *monome = user_data;
	int mode = (argc) ? argv[0]->i : 0;

	return monome_led_all(monome, mode);
}

static int osc_led_col_row_handler(const char *path, const char *types,
								   lo_arg **argv, int argc,
								   lo_message data, void *user_data) {
	monome_t *monome = user_data;
	uint8_t buf[2] = {argv[1]->i};

	if( argc == 3 )
		buf[1] = argv[2]->i;

	if( strstr(path, "led_col") )
		return monome_led_col(monome, argv[0]->i, 0, argc - 1, buf);
	else
		return monome_led_row(monome, 0, argv[0]->i, argc - 1, buf);
}

static int osc_led_map_handler(const char *path, const char *types,
                               lo_arg **argv, int argc,
                               lo_message data, void *user_data) {
	monome_t *monome = user_data;
	uint8_t buf[8];
	uint i;

	for( i = 0; i < 8; i++ )
		buf[i] = argv[i + (argc - 8)]->i;

	switch( argc ) {
	case 8:
		return monome_led_map(monome, 0, 0, buf);

	case 10:
		return monome_led_map(monome, argv[0]->i, argv[1]->i, buf);
	}

	return -1;
}

static int osc_intensity_handler(const char *path, const char *types,
								 lo_arg **argv, int argc,
								 lo_message data, void *user_data) {
	monome_t *monome = user_data;
	int intensity = (argc) ? argv[0]->i : 0xF;

	return monome_led_intensity(monome, intensity);
}

#define ASPRINTF_OR_BAIL(...) do { \
	if (asprintf(__VA_ARGS__) < 0) \
		return;                    \
	} while (0);

static void register_osc_methods(char *prefix, monome_t *monome) {
	lo_server_thread srv = state.server;
	char *cmd_buf;

	ASPRINTF_OR_BAIL(&cmd_buf, "/%s/led", prefix);
	lo_server_add_method(srv, cmd_buf, "iii", osc_led_handler, monome);
	m_free(cmd_buf);

	ASPRINTF_OR_BAIL(&cmd_buf, "/%s/clear", prefix);
	lo_server_add_method(srv, cmd_buf, "", osc_led_all_handler, monome);
	lo_server_add_method(srv, cmd_buf, "i", osc_led_all_handler, monome);
	m_free(cmd_buf);

	ASPRINTF_OR_BAIL(&cmd_buf, "/%s/frame", prefix);
	lo_server_add_method(srv, cmd_buf, "iiiiiiii", osc_led_map_handler, monome);
	lo_server_add_method(srv, cmd_buf, "iiiiiiiiii",
						 osc_led_map_handler, monome);
	m_free(cmd_buf);

	ASPRINTF_OR_BAIL(&cmd_buf, "/%s/led_row", prefix);
	lo_server_add_method(srv, cmd_buf, "ii", osc_led_col_row_handler, monome);
	lo_server_add_method(srv, cmd_buf, "iii", osc_led_col_row_handler, monome);
	m_free(cmd_buf);

	ASPRINTF_OR_BAIL(&cmd_buf, "/%s/led_col", prefix);
	lo_server_add_method(srv, cmd_buf, "ii", osc_led_col_row_handler, monome);
	lo_server_add_method(srv, cmd_buf, "iii", osc_led_col_row_handler, monome);
	m_free(cmd_buf);

	ASPRINTF_OR_BAIL(&cmd_buf, "/%s/intensity", prefix);
	lo_server_add_method(srv, cmd_buf, "", osc_intensity_handler, monome);
	lo_server_add_method(srv, cmd_buf, "i", osc_intensity_handler, monome);
	m_free(cmd_buf);
}

static void unregister_osc_methods(char *prefix) {
	lo_server_thread srv = state.server;
	char *cmd_buf;

	ASPRINTF_OR_BAIL(&cmd_buf, "/%s/clear", prefix);
	lo_server_del_method(srv, cmd_buf, "");
	lo_server_del_method(srv, cmd_buf, "i");
	m_free(cmd_buf);

	ASPRINTF_OR_BAIL(&cmd_buf, "/%s/intensity", prefix);
	lo_server_del_method(srv, cmd_buf, "");
	lo_server_del_method(srv, cmd_buf, "i");
	m_free(cmd_buf);

	ASPRINTF_OR_BAIL(&cmd_buf, "/%s/led", prefix);
	lo_server_del_method(srv, cmd_buf, "iii");
	m_free(cmd_buf);

	ASPRINTF_OR_BAIL(&cmd_buf, "/%s/led_row", prefix);
	lo_server_del_method(srv, cmd_buf, "ii");
	lo_server_del_method(srv, cmd_buf, "iii");
	m_free(cmd_buf);

	ASPRINTF_OR_BAIL(&cmd_buf, "/%s/led_col", prefix);
	lo_server_del_method(srv, cmd_buf, "ii");
	lo_server_del_method(srv, cmd_buf, "iii");
	m_free(cmd_buf);

	ASPRINTF_OR_BAIL(&cmd_buf, "/%s/frame", prefix);
	lo_server_del_method(srv, cmd_buf, "iiiiiiii");
	lo_server_del_method(srv, cmd_buf, "iiiiiiiiii");
	m_free(cmd_buf);

}

static void monome_handle_press(const monome_event_t *e, void *data) {
	char *cmd;
	char *prefix = data;

	ASPRINTF_OR_BAIL(&cmd, "/%s/press", prefix);
	lo_send_from(state.outgoing, state.server, LO_TT_IMMEDIATE, cmd, "iii",
				 e->grid.x, e->grid.y, e->event_type);
	m_free(cmd);
}

#undef ASPRINTF_OR_BAIL

static void usage(const char *app) {
	printf(
		"usage: %s [options...] [prefix]\n"
		"\n"
		"  -h, --help			display this information\n"
		"\n"
		"  -d, --device <device>		the monome serial device\n"

		/*
		 * protocol cannot currently be explicitly specified.
		 * this functionality will be re-added at a later date.
		 *
		"  -p, --protocol <protocol>	which protocol to use"
			"(\"40h\" or \"series\")\n" */

		"\n"
		"  -s, --server-port <port>	what port to listen on\n"
		"  -a, --application-port <port>	what port to talk to\n"
		"  -o, --application-host <host> the host your application is on\n"
		"\n"
		"  -r, --rotation <degrees>	rotate the monome. "
			"degrees can only be one of 0, 90, 180, or 270.\n"
		"\n", app);
}

static int is_numstr(const char *s) {
	while((48 <= *s) && (*s++ <= 57)); /* 48 is ASCII '0', 57 is '9' */

	/* if the character we stopped on isn't a null,
	   we didn't make it through the string */
	if( *s )
		return 0; /* oh well :( */
	return 1;
}

/* on OSX, poll() does not work with devices (i.e. ttys). */

#ifndef HAVE_BROKEN_POLL
static int main_loop() {
	struct pollfd fds[2];

	fds[0].fd = monome_get_fd(state.monome);
	fds[1].fd = lo_server_get_socket_fd(state.server);

	fds[0].events = fds[1].events = 
		POLLIN;

	do {
		/* block until either the monome or liblo have data */
		poll(fds, 2, -1);

		/* is the monome still connected? */
		if( fds[0].revents & (POLLHUP | POLLERR) )
			return 1;

		/* is there data available for reading from the monome? */
		if( fds[0].revents & POLLIN )
			monome_event_handle_next(state.monome);

		/* how about from OSC? */
		if( fds[1].revents & POLLIN )
			lo_server_recv_noblock(state.server, 0);
	} while( 1 );
}
#else
static int main_loop() {
	fd_set rfds, efds;
	int maxfd, mfd, lofd;

	mfd  = monome_get_fd(state.monome);
	lofd = lo_server_get_socket_fd(state.server);
	maxfd = ((lofd > mfd) ? lofd : mfd) + 1;

	do {
		FD_ZERO(&rfds);
		FD_SET(mfd, &rfds);
		FD_SET(lofd, &rfds);

		FD_ZERO(&efds);
		FD_SET(mfd, &efds);

		/* block until either the monome or liblo have data */
		select(maxfd, &rfds, NULL, &efds, NULL);

		/* is the monome still connected? */
		if( FD_ISSET(mfd, &efds) )
			return 1;

		/* is there data available for reading from the monome? */
		if( FD_ISSET(mfd, &rfds) )
			monome_event_handle_next(state.monome);

		/* how about from OSC? */
		if( FD_ISSET(lofd, &rfds) )
			lo_server_recv_noblock(state.server, 0);
	} while( 1 );
}
#endif

int main(int argc, char *argv[]) {
	char c, *device, *sport, *aport, *ahost;
	monome_rotate_t rotate = MONOME_ROTATE_0;
	int i;

	struct option arguments[] = {
		{"help",             no_argument,       0, 'h'},

		{"device",           required_argument, 0, 'd'},

		{"server-port",      required_argument, 0, 's'},
		{"application-port", required_argument, 0, 'a'},
		{"application-host", required_argument, 0, 'o'},

		{"rotation",         required_argument, 0, 'r'}
	};

	device = DEFAULT_MONOME_DEVICE;
	sport  = DEFAULT_OSC_SERVER_PORT;
	aport  = DEFAULT_OSC_APP_PORT;
	ahost  = DEFAULT_OSC_APP_HOST;

	while( (c = getopt_long(argc, argv, "hd:s:a:o:r:",
							arguments, &i)) > 0 ) {
		switch( c ) {
		case 'h':
			usage(argv[0]);
			return 1;

		case 'd':
			device = optarg;
			break;

		case 's':
			if( is_numstr(optarg) )
				sport = optarg;
			else
				printf("warning: \"%s\" is not a valid server port.\n",
					   optarg);

			break;

		case 'a':
			if( is_numstr(optarg) )
				aport = optarg;
			else
				printf("warning: \"%s\" is not a valid application port.\n",
					   optarg);

			break;

		case 'o':
			ahost = optarg;
			break;

		case 'r':
			switch(*optarg) {
			case 'l': case '0': rotate = MONOME_ROTATE_0;   break;
			case 't': case '9': rotate = MONOME_ROTATE_90;  break;
			case 'r': case '1': rotate = MONOME_ROTATE_180; break;
			case 'b': case '2': rotate = MONOME_ROTATE_270; break;
			}
			break;
		}
	}

	if( optind == argc )
		state.lo_prefix = m_strdup(DEFAULT_OSC_PREFIX);
	else
		state.lo_prefix = m_strdup(argv[optind]);

	if( !(state.monome = monome_open(device)) ) {
		printf("failed to open %s\n", device);
		return EXIT_FAILURE;
	}

	if( !(state.server = lo_server_new(sport, lo_error)) )
		return EXIT_FAILURE;

	state.outgoing = lo_address_new(ahost, aport);

	monome_register_handler(state.monome, MONOME_BUTTON_DOWN,
							monome_handle_press, state.lo_prefix);
	monome_register_handler(state.monome, MONOME_BUTTON_UP,
							monome_handle_press, state.lo_prefix);

	register_osc_methods(state.lo_prefix, state.monome);

	monome_set_rotation(state.monome, rotate);
	monome_led_all(state.monome, 0);

	printf("monomeserial version %s, yay!\n\n", VERSION);
	printf("initialized device %s (%s) at %s, which is %dx%d using proto %s\n",
		   monome_get_serial(state.monome), monome_get_friendly_name(state.monome),
		   monome_get_devpath(state.monome),
		   monome_get_rows(state.monome), monome_get_cols(state.monome),
		   monome_get_proto(state.monome));
	printf("running with prefix /%s\n\n", state.lo_prefix);

	/* main_loop() returns 1 if the monome was disconnected */
	if( main_loop() )
		printf("%s disconnected, monomeserial exiting.\nsee you later!\n\n",
			   monome_get_devpath(state.monome));

	monome_close(state.monome);

	unregister_osc_methods(state.lo_prefix);
	m_free(state.lo_prefix);

	lo_address_free(state.outgoing);
	lo_server_free(state.server);

	return EXIT_SUCCESS;
}

#include <stdio.h>
#include <stdint.h>
#include <string.h>

#include <monome.h>
#include "internal.h"

#define ROWS(monome) (monome_get_rows(monome) - 1)
#define COLS(monome) (monome_get_cols(monome) - 1)

/* you may notice the gratituous use of modulo when translating input
   coordinates...this is because it's possible to translate into negatives
   when pretending a bigger monome (say, a 256) is a smaller monome (say,
   a 128). because we're using unsigned integers, this will cause a wrap-around
   into some very big numbers, which makes several of the example programs
   segfault (simple.c, in particular).

   while this bug is arguably contrived, I'd rather pay the minute
   computational cost here and avoid causing trouble in application code. */

/**
 * 0 degrees
 */

static void r0_cb(monome_t *monome, uint_t *x, uint_t *y) {
	return;
}

static void r0_map_cb(monome_t *monome, uint8_t *data) {
	return;
}

static void r0_level_map_cb(monome_t *monome, uint8_t *dst,
                            const uint8_t *src) {
	memcpy(dst, src, 64);
}

/**
 * 90 degrees
 */

static void r90_output_cb(monome_t *monome, uint_t *x, uint_t *y) {
	uint_t t = *x;

	*x = *y;
	*y = COLS(monome) - t;
}

static void r90_input_cb(monome_t *monome, uint_t *x, uint_t *y) {
	uint_t t = *x;

	*x = (COLS(monome) - *y) % (COLS(monome) + 1);
	*y = t;
}

static void r90_map_cb(monome_t *monome, uint8_t *data) {
	/* this is an algorithm for rotation of a bit matrix by 90 degrees.
	   in the case of r270_map_cb, the rotation is clockwise, in the case
	   of r90_map_cb it is counter-clockwise.

	   the matrix is made up of an array of 8 bytes, which, laid out
	   contiguously in memory, can be treated as a 64 bit integer, which I've
	   opted to do here. this allows rotation to be accomplished solely with
	   bitwise operations.

	   on 64 bit architectures, we treat data as a 64 bit integer, on 32
	   bit architectures we treat it as two 32 bit integers.

	   inspired by "hacker's delight" by henry s. warren
	   see section 7-3 "transposing a bit matrix" */

#ifdef __LP64__
	uint64_t t, x = *((uint64_t *) data);

# define swap(f, c)\
	t = (x ^ (x << f)) & c; x ^= t ^ (t >> f);

# ifdef LM_BIG_ENDIAN
	swap(8, 0xFF00FF00FF00FF00LLU);
	swap(7, 0x5500550055005500LLU);

	swap(16, 0xFFFF0000FFFF0000LLU);
	swap(14, 0x3333000033330000LLU);

	swap(32, 0xFFFFFFFF00000000LLU);
	swap(28, 0x0F0F0F0F00000000LLU);
# else
	swap(8, 0xFF00FF00FF00FF00LLU);
	swap(9, 0xAA00AA00AA00AA00LLU);

	swap(16, 0xFFFF0000FFFF0000LLU);
	swap(18, 0xCCCC0000CCCC0000LLU);

	swap(32, 0xFFFFFFFF00000000LLU);
	swap(36, 0xF0F0F0F000000000LLU);
# endif /* defined LM_BIG_ENDIAN */
# undef swap

	*((uint64_t *) data) = x;
#else /* __LP64__ */
	uint32_t x, y, t;

	x = *((uint32_t *) data);
	y = *(((uint32_t *) data) + 1);
	t = 0;

# define swap(x, f, c)\
	t = (x ^ (x << f)) & c; x ^= t ^ (t >> f);

# ifdef LM_BIG_ENDIAN
	swap(x, 8, 0xFF00FF00);
	swap(x, 7, 0x55005500);

	swap(x, 16, 0xFFFF0000);
	swap(x, 14, 0x33330000);

	swap(y, 8, 0xFF00FF00);
	swap(y, 7, 0x55005500);

	swap(y, 16, 0xFFFF0000);
	swap(y, 14, 0x33330000);
# else
	swap(x, 8, 0xFF00FF00);
	swap(x, 9, 0xAA00AA00);

	swap(x, 16, 0xFFFF0000);
	swap(x, 18, 0xCCCC0000);

	swap(y, 8, 0xFF00FF00);
	swap(y, 9, 0xAA00AA00);

	swap(y, 16, 0xFFFF0000);
	swap(y, 18, 0xCCCC0000);
# endif /* defined LM_BIG_ENDIAN */
# undef swap

	*((uint32_t *) data) = ((x & 0xF0F0F0F0) >> 4) | (y & 0xF0F0F0F0);
	*(((uint32_t *) data) + 1) = (x & 0x0F0F0F0F) | ((y & 0x0F0F0F0F) << 4);
#endif /* __LP64__ */
}

static void r90_level_map_cb(monome_t *monome, uint8_t *dst,
                             const uint8_t *src) {
	int i;

	for( i = 0; i < 64; i++ )
		dst[i] = src[(7 - (i >> 3)) + ((i & 7) << 3)];
}

/**
 * 180 degrees
 */

static void r180_output_cb(monome_t *monome, uint_t *x, uint_t *y) {
	*x = COLS(monome) - *x;
	*y = ROWS(monome) - *y;
}

static void r180_input_cb(monome_t *monome, uint_t *x, uint_t *y) {
	*x = (COLS(monome) - *x) % (COLS(monome) + 1);
	*y = (ROWS(monome) - *y) % (ROWS(monome) + 1);
}

static void r180_map_cb(monome_t *monome, uint8_t *data) {
	/* integer reversal. */

#ifdef __LP64__
	uint64_t x = *((uint64_t *) data);

	x = x >> 32 | x << 32;
	x = (x & 0xFFFF0000FFFF0000LLU) >> 16 | (x & 0x0000FFFF0000FFFFLLU) << 16;
	x = (x & 0xFF00FF00FF00FF00LLU) >> 8  | (x & 0x00FF00FF00FF00FFLLU) << 8;
	x = (x & 0xF0F0F0F0F0F0F0F0LLU) >> 4  | (x & 0x0F0F0F0F0F0F0F0FLLU) << 4;
	x = (x & 0xCCCCCCCCCCCCCCCCLLU) >> 2  | (x & 0x3333333333333333LLU) << 2;
	x = (x & 0xAAAAAAAAAAAAAAAALLU) >> 1  | (x & 0x5555555555555555LLU) << 1;

	*((uint64_t *) data) = x;
#else /* __LP64__ */
	uint32_t x, y;

	x = *((uint32_t *) data);
	y = *(((uint32_t *) data) + 1);

	x = x >> 16 | x << 16;
	x = (x & 0xFF00FF00) >> 8  | (x & 0x00FF00FF) << 8;
	x = (x & 0xF0F0F0F0) >> 4  | (x & 0x0F0F0F0F) << 4;
	x = (x & 0xCCCCCCCC) >> 2  | (x & 0x33333333) << 2;
	x = (x & 0xAAAAAAAA) >> 1  | (x & 0x55555555) << 1;

	y = y >> 16 | y << 16;
	y = (y & 0xFF00FF00) >> 8  | (y & 0x00FF00FF) << 8;
	y = (y & 0xF0F0F0F0) >> 4  | (y & 0x0F0F0F0F) << 4;
	y = (y & 0xCCCCCCCC) >> 2  | (y & 0x33333333) << 2;
	y = (y & 0xAAAAAAAA) >> 1  | (y & 0x55555555) << 1;

	*((uint32_t *) data) = y;
	*(((uint32_t *) data) + 1) = x;
#endif /* defined __LP64__ */
}

static void r180_level_map_cb(monome_t *monome, uint8_t *dst,
                              const uint8_t *src) {
	int i;

	for( i = 0; i < 64; i++ )
		dst[63 - i] = src[i];
}

/**
 * 270 degrees
 */

static void r270_output_cb(monome_t *monome, uint_t *x, uint_t *y) {
	uint_t t = *x;

	*x = ROWS(monome) - *y;
	*y = t;
}

static void r270_input_cb(monome_t *monome, uint_t *x, uint_t *y) {
	uint_t t = *x;

	*x = *y;
	*y = (ROWS(monome) - t) % (ROWS(monome) + 1);
}

static void r270_map_cb(monome_t *monome, uint8_t *data) {
	/* see r90_map_cb for a brief explanation */

#ifdef __LP64__
	uint64_t t, x = *((uint64_t *) data);

# define swap(f, c)\
	t = (x ^ (x << f)) & c; x ^= t ^ (t >> f);

# ifdef LM_BIG_ENDIAN
	swap(8, 0xFF00FF00FF00FF00LLU);
	swap(9, 0xAA00AA00AA00AA00LLU);

	swap(16, 0xFFFF0000FFFF0000LLU);
	swap(18, 0xCCCC0000CCCC0000LLU);

	swap(32, 0xFFFFFFFF00000000LLU);
	swap(36, 0xF0F0F0F000000000LLU);
# else
	swap(8, 0xFF00FF00FF00FF00LLU);
	swap(7, 0x5500550055005500LLU);

	swap(16, 0xFFFF0000FFFF0000LLU);
	swap(14, 0x3333000033330000LLU);

	swap(32, 0xFFFFFFFF00000000LLU);
	swap(28, 0x0F0F0F0F00000000LLU);
# endif /* defined LM_BIG_ENDIAN */
# undef swap

	*((uint64_t *) data) = x;
#else /* __LP64__ */
	uint32_t x, y, t;

	x = *((uint32_t *) data);
	y = *(((uint32_t *) data) + 1);
	t = 0;

# define swap(x, f, c)\
	t = (x ^ (x << f)) & c; x ^= t ^ (t >> f);

# ifdef LM_BIG_ENDIAN
	swap(x, 8, 0xFF00FF00);
	swap(x, 9, 0xAA00AA00);

	swap(x, 16, 0xFFFF0000);
	swap(x, 18, 0xCCCC0000);

	swap(y, 8, 0xFF00FF00);
	swap(y, 9, 0xAA00AA00);

	swap(y, 16, 0xFFFF0000);
	swap(y, 18, 0xCCCC0000);
# else
	swap(x, 8, 0xFF00FF00);
	swap(x, 7, 0x55005500);

	swap(x, 16, 0xFFFF0000);
	swap(x, 14, 0x33330000);

	swap(y, 8, 0xFF00FF00);
	swap(y, 7, 0x55005500);

	swap(y, 16, 0xFFFF0000);
	swap(y, 14, 0x33330000);
# endif /* defined LM_BIG_ENDIAN */

	*((uint32_t *) data) = ((x & 0x0F0F0F0F) << 4) | (y & 0x0F0F0F0F);
	*(((uint32_t *) data) + 1) = (x & 0xF0F0F0F0) | ((y & 0xF0F0F0F0) >> 4);
# undef swap

#endif /* defined __LP64__ */
}

static void r270_level_map_cb(monome_t *monome, uint8_t *dst,
                              const uint8_t *src) {
	int i;

	for( i = 0; i < 64; i++ )
		dst[i] = src[(i >> 3) + ((7 - (i & 7)) << 3)];
}

monome_rotspec_t rotspec[4] = {
	[MONOME_ROTATE_0] = {
		.output_cb    = r0_cb,
		.input_cb     = r0_cb,
		.map_cb       = r0_map_cb,
		.level_map_cb = r0_level_map_cb,

		.flags        = 0,
	},
	
	[MONOME_ROTATE_90] = {
		.output_cb    = r90_output_cb,
		.input_cb     = r90_input_cb,
		.map_cb       = r90_map_cb,
		.level_map_cb = r90_level_map_cb,

		.flags        = ROW_COL_SWAP | ROW_REVBITS
	},

	[MONOME_ROTATE_180] = {
		.output_cb    = r180_output_cb,
		.input_cb     = r180_input_cb,
		.map_cb       = r180_map_cb,
		.level_map_cb = r180_level_map_cb,

		.flags        = ROW_REVBITS | COL_REVBITS
	},

	[MONOME_ROTATE_270] = {
		.output_cb    = r270_output_cb,
		.input_cb     = r270_input_cb,
		.map_cb       = r270_map_cb,
		.level_map_cb = r270_level_map_cb,

		.flags        = ROW_COL_SWAP | COL_REVBITS
	},
};

#define _GNU_SOURCE

#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <sys/select.h>

#include "platform.h"

char *monome_platform_get_dev_serial(const char *path) {
	char *serial;

	assert(path);

	/* osx serial paths are of the form
	   /dev/tty.usbserial-<device serial> or
	   /dev/tty.usbmodem<device serial> (arduino uno)
	   we'll locate to one past the first hyphen
	   or the first occurrence of usbmodem sequence */

	if( (serial = strstr(path, "usbmodem")) )
		serial += 7;
	else if( !(serial = strchr(path, '-')) )
		return NULL;

	return strdup(serial + 1);
}

int monome_platform_wait_for_input(monome_t *monome, uint_t msec) {
	struct timeval timeout[1];
	fd_set rfds[1];
	fd_set efds[1];
	int fd;

	fd = monome_get_fd(monome);

	timeout->tv_sec  = msec / 1000;
	timeout->tv_usec = (msec - (timeout->tv_sec * 1000)) * 1000;

	FD_ZERO(rfds);
	FD_SET(fd, rfds);
	FD_ZERO(efds);
	FD_SET(fd, efds);

	if( !select(fd + 1, rfds, NULL, efds, timeout) )
		return 1;

	if( FD_ISSET(fd, efds) )
		return -1;

	return 0;
}

#define _GNU_SOURCE

#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <dlfcn.h>
#include <sys/select.h>
#include <termios.h>
#include <errno.h>

#include <monome.h>
#include "internal.h"
#include "platform.h"

#define MONOME_BAUD_RATE B115200
#define READ_TIMEOUT 25

#if !defined(EMBED_PROTOS)
/* stops gcc from complaining when compiled with -pedantic */
typedef union {
	void *vptr;
	monome_t *(*func)();
} func_vptr_t;

monome_t *monome_platform_load_protocol(const char *proto) {
	void *dl_handle;
	func_vptr_t protocol_new;
	monome_t *monome;
	char *buf;

	if( asprintf(&buf, LIBDIR "/monome/protocol_%s" LIBSUFFIX, proto) < 0 )
		return NULL;

	dl_handle = dlopen(buf, RTLD_LAZY);
	free(buf);

	if( !dl_handle ) {
		fprintf(stderr, "couldn't load monome protocol module.  "
				"dlopen said: \n\t%s\n\n"
				"please make sure that libmonome is installed correctly!\n",
				dlerror());
		return NULL;
	}

	protocol_new.vptr = dlsym(dl_handle, "monome_protocol_new");

	if( !protocol_new.func ) {
		fprintf(stderr, "couldn't initialize monome protocol module.  "
				"dlopen said:\n\t%s\n\n"
				"please make sure you're using a valid protocol library!\n"
				"if this is a protocol library you wrote, make sure you're"
				"providing a \033[1mmonome_protocol_new\033[0m function.\n",
				dlerror());
		goto err;
	}

	monome = (*protocol_new.func)();

	if( !monome )
		goto err;

	monome->dl_handle = dl_handle;
	return monome;

err:
	dlclose(dl_handle);
	return NULL;
}

void monome_platform_free(monome_t *monome) {
	void *dl_handle = monome->dl_handle;

	monome->free(monome);
	dlclose(dl_handle);
}
#endif

int monome_platform_open(monome_t *monome, const monome_devmap_t *m,
                         const char *dev) {
	struct termios nt, ot;
	int fd;

	if( (fd = open(dev, O_RDWR | O_NOCTTY | O_NONBLOCK)) < 0 ) {
		perror("libmonome: could not open monome device");
		return 1;
	}

	tcgetattr(fd, &ot);
	nt = ot;

	/* baud rate */
	if( m->quirks & QUIRK_57600_BAUD ) {
		cfsetispeed(&nt, B57600);
		cfsetospeed(&nt, B57600);
	} else {
		cfsetispeed(&nt, MONOME_BAUD_RATE);
		cfsetospeed(&nt, MONOME_BAUD_RATE);
	}

	/* parity (8N1) */
	nt.c_cflag &= ~(PARENB | CSTOPB | CSIZE);
	nt.c_cflag |=  (CS8 | CLOCAL | CREAD);

	/* no line processing */
	nt.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG | IEXTEN);

	/* raw input */
	nt.c_iflag &= ~(IGNBRK | BRKINT | ICRNL | INLCR | PARMRK |
	                INPCK | ISTRIP | IXON);

	/* raw output */
	nt.c_oflag &= ~(OCRNL | ONLCR | ONLRET | ONOCR |
	                OFILL | OPOST);

	nt.c_cc[VMIN]  = 1;
	nt.c_cc[VTIME] = 0;

	if( tcsetattr(fd, TCSANOW, &nt) < 0 )
		goto err_tcsetattr;

	tcflush(fd, TCIOFLUSH);

	monome->fd = fd;
	return 0;

err_tcsetattr:
	perror("libmonome: could not set terminal attributes");

	close(fd);
	return 1;
}

int monome_platform_close(monome_t *monome) {
	return close(monome->fd);
}

ssize_t monome_platform_write(monome_t *monome, const uint8_t *buf, size_t nbyte) {
	ssize_t ret = write(monome->fd, buf, nbyte);

	if( ret < nbyte )
		perror("libmonome: write is missing bytes");

	if( ret < 0 )
		perror("libmonome: error in write");

	return ret;
}

ssize_t monome_platform_read(monome_t *monome, uint8_t *buf, size_t nbyte) {
	ssize_t bytes, ret = 0;
	int err;

	goto start;

	for( ; nbyte; nbyte -= bytes ) {
		err = monome_platform_wait_for_input(monome, READ_TIMEOUT);
		if( err > 0 )
			return ret;
		if( err < 0 )
			return -1;

start:
		if ((bytes = read(monome->fd, buf, nbyte)) < 0) {
			if (errno == EAGAIN || errno == EWOULDBLOCK)
				return 0;
			if (errno == EINTR)
				goto start;

			return bytes;
		}

		ret += bytes;
		buf += bytes;
	}

	return ret;
}

void monome_event_loop(monome_t *monome) {
	monome_callback_t *handler;
	monome_event_t e;

	fd_set fds;

	e.monome = monome;

	do {
		FD_ZERO(&fds);
		FD_SET(monome->fd, &fds);

		if( select(monome->fd + 1, &fds, NULL, NULL, NULL) < 0 ) {
			perror("libmonome: error in select()");
			break;
		}

		if( monome->next_event(monome, &e) < 1 )
			continue;

		handler = &monome->handlers[e.event_type];
		if( !handler->cb )
			continue;

		handler->cb(&e, handler->data);
	} while( 1 );
}

void *m_malloc(size_t size) {
	return malloc(size);
}

void *m_calloc(size_t nmemb, size_t size) {
	return calloc(nmemb, size);
}

void *m_strdup(const char *s) {
	return strdup(s);
}

void m_free(void *ptr) {
	free(ptr);
}

void m_sleep(uint_t msec) {
	usleep(msec * 1000);
}

#ifdef __STRICT_ANSI__
#undef __STRICT_ANSI__
#endif

#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdarg.h>
#include <stdio.h>

/* THIS WAY LIES MADNESS */
#include <windows.h>
#include <winreg.h>
#include <io.h>

#include <monome.h>
#include "internal.h"
#include "platform.h"

#define FTDI_REG_PATH "SYSTEM\\CurrentControlSet\\Enum\\FTDIBUS"

static char *m_asprintf(const char *fmt, ...) {
	va_list args;
	char *buf;
	int len;

	va_start(args, fmt);

	len = _vscprintf(fmt, args) + 1;
	if( !(buf = m_calloc(sizeof(char), len)) )
		return NULL;

	vsprintf(buf, fmt, args);
	va_end(args);

	return buf;
}

monome_t *monome_platform_load_protocol(const char *proto) {
	monome_proto_new_func_t protocol_new;

	monome_t *monome;
	HMODULE proto_mod;
	char *modname;

	if( !(modname = m_asprintf("monome\\protocol_%s.dll", proto)) )
		goto err_loadlibrary;

	proto_mod = LoadLibrary(modname);
	m_free(modname);

	if( !proto_mod )
		goto err_loadlibrary;

	protocol_new = (monome_proto_new_func_t) GetProcAddress(proto_mod, "monome_protocol_new");

	if( !protocol_new )
		goto err_protocol_new;

	if( !(monome = protocol_new()) )
		goto err_protocol_new;

	monome->dl_handle = proto_mod;
	return monome;

err_protocol_new:
	FreeLibrary(proto_mod);
err_loadlibrary:
	return NULL;
}

void monome_platform_free(monome_t *monome) {
	void *dl_handle = monome->dl_handle;

	monome->free(monome);
	FreeLibrary(dl_handle);
}

int monome_platform_open(monome_t *monome, const monome_devmap_t *m,
                         const char *dev) {
	DCB serparm = {0};
	char *devesc;
	HANDLE hser;
	COMMTIMEOUTS timeouts = {
		.ReadIntervalTimeout         = MAXDWORD,
		.ReadTotalTimeoutConstant    = 0,
		.ReadTotalTimeoutMultiplier  = 0,
		.WriteTotalTimeoutConstant   = 0,
		.WriteTotalTimeoutMultiplier = 0
	};

	if( !(devesc = m_asprintf("\\\\.\\%s", dev)) ) {
		fprintf(stderr, "libmonome: could not open %s: out of memory\n", dev);
		return 1;
	}

	hser = CreateFile(devesc, GENERIC_READ | GENERIC_WRITE, 0, NULL,
	                  OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL |
	                  FILE_FLAG_OVERLAPPED, 0);

	free(devesc);

	if( hser == INVALID_HANDLE_VALUE )
		goto err_open;

	serparm.DCBlength = sizeof(serparm);

	if( !GetCommState(hser, &serparm) )
		goto err_commstate;

	if( m->quirks & QUIRK_57600_BAUD )
		serparm.BaudRate = CBR_57600;
	else
		serparm.BaudRate = CBR_115200;

	serparm.ByteSize = 8;
	serparm.StopBits = ONESTOPBIT;
	serparm.Parity   = NOPARITY;
	serparm.fBinary  = 1;

	if( !SetCommState(hser, &serparm) )
		goto err_commstate;

	if( !SetCommTimeouts(hser, &timeouts) )
		goto err_commstate;

	PurgeComm(hser, PURGE_RXCLEAR | PURGE_TXCLEAR);

	monome->fd = _open_osfhandle((intptr_t) hser, _O_RDWR | _O_BINARY);
	return 0;

err_commstate:
	CloseHandle(hser);
err_open:
	if( GetLastError() != ERROR_FILE_NOT_FOUND )
		printf("libmonome: could not open %s: error %ld", dev,
		       GetLastError());
	return 1;
}

int monome_platform_close(monome_t *monome) {
	return !!_close(monome->fd);
}

ssize_t monome_platform_write(monome_t *monome, const uint8_t *buf, size_t nbyte) {
	HANDLE hres = (HANDLE) _get_osfhandle(monome->fd);
	OVERLAPPED ov = {0, 0, {{0, 0}}};
	DWORD written = 0;

	if( !(ov.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL)) ) {
		fprintf(stderr,
				"monome_plaform_write(): could not allocate event (%ld)\n",
				GetLastError());
		return -1;
	}

	if( !WriteFile(hres, buf, nbyte, &written, &ov) ) {
		if( GetLastError() != ERROR_IO_PENDING ) {
			fprintf(stderr, "monome_platform_write(): write failed (%ld)\n",
					GetLastError());
			return -1;
		}

		GetOverlappedResult(hres, &ov, &written, TRUE);
	}

	CloseHandle(ov.hEvent);
	return written;
}

ssize_t monome_platform_read(monome_t *monome, uint8_t *buf, size_t nbyte) {
	HANDLE hres = (HANDLE) _get_osfhandle(monome->fd);
	OVERLAPPED ov = {0, 0, {{0, 0}}};
	DWORD read = 0;

	if( !(ov.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL)) ) {
		fprintf(stderr,
				"monome_plaform_read(): could not allocate event (%ld)\n",
				GetLastError());
		return -1;
	}

	if( !ReadFile(hres, buf, nbyte, &read, &ov) ) {
		if( GetLastError() != ERROR_IO_PENDING ) {
			fprintf(stderr, "monome_platform_read(): read failed (%ld)\n",
					GetLastError());
			return -1;
		}

		GetOverlappedResult(hres, &ov, &read, TRUE);
	}

	CloseHandle(ov.hEvent);
	return read;
}

char *monome_platform_get_dev_serial(const char *path) {
	HKEY key, subkey;
	char subkey_name[MAX_PATH], *subkey_path, *serial;
	unsigned char port_name[64];
	DWORD klen, plen, ptype;
	int i = 0;

	serial = NULL;

	switch( RegOpenKeyEx(
			HKEY_LOCAL_MACHINE, FTDI_REG_PATH,
			0, KEY_READ, &key) ) {
	case ERROR_SUCCESS:
		/* ERROR: request was (unexpectedly) successful */
		break;

	case ERROR_FILE_NOT_FOUND:
		/* print message about needing the FTDI driver maybe? */
		/* fall through also */
	default:
		return NULL;
	}

	do {
		klen = sizeof(subkey_name) / sizeof(char);
		switch( RegEnumKeyEx(key, i++, subkey_name, &klen,
							 NULL, NULL, NULL, NULL) ) {
		case ERROR_MORE_DATA:
		case ERROR_SUCCESS:
			break;

		default:
			goto done;
		}

		subkey_path = m_asprintf("%s\\%s\\0000\\Device Parameters",
								 FTDI_REG_PATH, subkey_name);

		switch( RegOpenKeyEx(
				HKEY_LOCAL_MACHINE, subkey_path,
				0, KEY_READ, &subkey) ) {
		case ERROR_SUCCESS:
			break;

		default:
			continue;
		}

		free(subkey_path);

		plen = sizeof(port_name) / sizeof(char);
		ptype = REG_SZ;
		switch( RegQueryValueEx(subkey, "PortName", 0, &ptype,
								port_name, &plen) ) {
		case ERROR_SUCCESS:
			port_name[plen] = '\0';
			break;

		default:
			goto nomatch;
		}

		if( !strcmp((char *) port_name, path) ) {
			/* there's a fucking "A" right after the serial number */
			subkey_name[klen - 1] = '\0';
			serial = strrchr(subkey_name, '+') + 1;

			RegCloseKey(subkey);
			break;
		}

nomatch:
		RegCloseKey(subkey);
	} while( 1 );

done:
	RegCloseKey(key);
	return ( serial ) ? strdup(serial) : NULL;
}

int monome_platform_wait_for_input(monome_t *monome, uint_t msec) {
	Sleep(msec); /* fuck it */
	return 1;
}

void monome_event_loop(monome_t *monome) {
	printf("monome_event_loop() is unimplemented\n");
	return;
}

void *m_malloc(size_t size) {
	return malloc(size);
}

void *m_calloc(size_t nmemb, size_t size) {
	return calloc(nmemb, size);
}

void *m_strdup(const char *s) {
	return _strdup(s);
}

void m_free(void *ptr) {
	free(ptr);
}

void m_sleep(uint_t msec) {
	Sleep(msec);
}

#include "AlphaChooser.h"
#include "cinder/gl/gl.h"
#include "cinder/Text.h"
#include "Globals.h"
#include "BloomGl.h"
#include "BloomScene.h"
#include "cinder/Utilities.h" // for toString
#include <sstream>

using namespace ci;
using namespace ci::app;
using namespace std;

void AlphaChooser::setup( const Font &font, const Vec2f &interfaceSize )
{	
	// Textures
	mAlphaString	= "ABCDEFGHIJKLMNOPQRSTUVWXYZ#";
	mAlphaIndex		= 0;
	mAlphaChar		= 'A';

	for( int i=0; i<mAlphaString.length(); i++ ){
		TextLayout layout;	
		layout.setFont( font );
		layout.setColor( Color::white() );
		layout.addCenteredLine( ci::toString(mAlphaString[i]) );
		mAlphaTextures.push_back( gl::Texture( layout.render( true, false ) ) );
	}
    
    mInterfaceSize = interfaceSize;
    
    setRects();
}

void AlphaChooser::setRects()
{
	mAlphaRects.clear();
    mAlphaHitRects.clear();
    float totalWidth = 0.0f;
    float maxHeight = 0.0f;
	for( int i=0; i<mAlphaString.length(); i++ ){
        totalWidth += mAlphaTextures[i].getWidth();
        maxHeight = max( maxHeight, (float)mAlphaTextures[i].getHeight() );
    }    
    const float hPadding = 20.0f;
    const float vTopPadding = 11.0f;
    const float vBottomPadding = 9.0f;
    const float spacing = (mInterfaceSize.x - totalWidth - (hPadding * 2.0f)) / 26.0f;
    float x = hPadding;
	for( int i = 0; i < mAlphaString.length(); i++ ){
		const float w = mAlphaTextures[i].getWidth();
		const float h = mAlphaTextures[i].getHeight();
		mAlphaRects.push_back( Rectf( x, vTopPadding, x + w, h + vTopPadding ) );
		mAlphaHitRects.push_back( Rectf( x - spacing/2.0f, 0.0f, x + w + spacing/2.0f, h + vTopPadding + vBottomPadding ) );
        x += w + spacing;
	}
    mFullRect.set( 0.0f, 0.0f, mInterfaceSize.x, maxHeight + vTopPadding + vBottomPadding );
}

bool AlphaChooser::touchBegan( TouchEvent::Touch touch )
{
    if (!isVisible()) return false;    
    Vec2f pos = globalToLocal( touch.getPos() );
    return mFullRect.contains( pos );
}

bool AlphaChooser::touchMoved( TouchEvent::Touch touch )
{	
    if (!isVisible()) return false;
    
    Vec2f pos = globalToLocal( touch.getPos() );
    for (int i = 0; i < mAlphaRects.size(); i++) {
        if ( mNumberAlphaPerChar[i] ) {                        
            if ( mAlphaHitRects[i].contains( pos ) ) {
                mAlphaIndex = i;
                if( mAlphaChar != mAlphaString[i] ){            
                    mAlphaChar = mAlphaString[i];
                    mCallbacksAlphaCharSelected.call( mAlphaChar );
                }
                return true;
            }
        }
    }
    
    return mFullRect.contains( pos );
}

bool AlphaChooser::touchEnded( TouchEvent::Touch touch )
{	
    if (!isVisible()) return false;

    Vec2f pos = globalToLocal( touch.getPos() );
    for (int i = 0; i < mAlphaRects.size(); i++) {
        if ( mNumberAlphaPerChar[i] ) {            
            if ( mAlphaHitRects[i].contains( pos ) ) {
                mAlphaIndex = i;
                mAlphaChar = mAlphaString[i];
                mCallbacksAlphaCharSelected.call( mAlphaChar );
                return true;
            }
        }
    }

    return mFullRect.contains( pos );
}

void AlphaChooser::setNumberAlphaPerChar( float *numberAlphaPerChar )
{
    mNumberAlphaPerChar = numberAlphaPerChar;
}

void AlphaChooser::update( )
{    
    Vec2f interfaceSize = getRoot()->getInterfaceSize();    
    if (mInterfaceSize != interfaceSize) {
        mInterfaceSize = interfaceSize;
        setRects();        
    }
}

void AlphaChooser::draw()
{	        
    // we'll use the bright blue components to draw by frequency
    float r = BRIGHT_BLUE.r;
    float g = BRIGHT_BLUE.g;
    float b = BRIGHT_BLUE.b;

    gl::color( ColorA( r, g, b, mOpacity * 0.125f ) );
    gl::drawLine( mFullRect.getUpperLeft(), mFullRect.getUpperRight() );
            
    for( int i=0; i<27; i++ ){
        float c = mNumberAlphaPerChar[i];
        if ( mAlphaString[i] == mAlphaChar ) {
            gl::color( ColorA( 1.0f, 1.0f, 1.0f, 1.0f * mOpacity ) );
        } else if( c > 0.0f ){
            c += 0.3f;
            gl::color( ColorA( r*c, g*c, b*c, mOpacity ) );
        } else {
            gl::color( ColorA( 0.1f, 0.1f, 0.15f, mOpacity ) );
        }
        mAlphaTextures[i].enableAndBind();
        gl::drawSolidRect( mAlphaRects[i] );
        mAlphaTextures[i].disable();            
    }
}

float AlphaChooser::getHeight()
{
    return mFullRect.getHeight();
}

#pragma once
#include <vector>
#include "cinder/Vector.h"
#include "cinder/gl/Texture.h"
#include "cinder/Rect.h"
#include "cinder/Color.h"
#include "cinder/Font.h"
#include "BloomNode.h"
#include "PlaylistChooser.h"
#include "AlphaChooser.h"
#include "PlayControls.h"
#include "SettingsPanel.h"

class UiLayer : public BloomNode {
 public:
	
    UiLayer(): 
        BloomNode(), // get a default ID
        mChooserY(0.0f), 
        mSettingsY(0.0f), 
        mChooserDestY(0.0f), 
        mSettingsDestY(0.0f) 
    { }; 
    
	~UiLayer() {};
    
	void	setup( PlaylistChooserRef playlistChooser, 
                   AlphaChooserRef alphaChooser, 
                   PlayControlsRef playControls, 
                   SettingsPanelRef settingsPanel,
                   const ci::gl::Texture &uiButtonsTex, 
                   const bool &showSettings, 
                   const ci::Vec2f interfaceSize );
	
    bool	touchBegan( ci::app::TouchEvent::Touch touch );
	bool	touchMoved( ci::app::TouchEvent::Touch touch );
	bool	touchEnded( ci::app::TouchEvent::Touch touch );

    void    setShowSettings( bool visible );
    
	void    update();
	void    draw();
    
	float   getPanelYPos(){ return mPanelY; }	

	bool	getIsPanelOpen() { return mIsPanelOpen; }
	void	setIsPanelOpen( bool b ){ mIsPanelOpen = b; mHasPanelBeenDragged = false; }
	
    bool    hitTest( ci::Vec2f globalPos );
    
    //// expand/collapse/query panels
    void    setShowAlphaFilter(bool visible);
    bool    isShowingAlphaFilter();
    void    setShowPlaylistFilter(bool visible);
    bool    isShowingPlaylistFilter();
    bool    isShowingFilter();    
    
 private:

    void updateLayout( ci::Vec2f interfaceSize );
    
    ci::Vec2f       mInterfaceSize; // for detecting orientation changes    
    ci::gl::Texture mButtonsTex;
    
    float           mPanelY;                // used in setTransform
    float           mPanelOpenY;            // updated in setShowSettings/updateLayout
    float           mPanelClosedY;          // updated in updateLayout
	ci::Rectf		mPanelTabRect;			// Rect defining the panel tab
    
	bool			mIsPanelTabTouched;		// Is the Panel Tab currently being touched
	bool			mIsPanelOpen;			// Is the Panel fully open
	bool			mHasPanelBeenDragged;   // Are we dragging or just animating?
    ci::Vec2f		mPanelTabTouchOffset;	// Remember the touch position value when dragging	
    
    float           getPanelHeight();
    float           getMaxPanelHeight();
    
    float           mChooserY, mSettingsY;
    float           mChooserDestY, mSettingsDestY;
    
    PlaylistChooserRef mPlaylistChooser;
    AlphaChooserRef    mAlphaChooser;
    PlayControlsRef    mPlayControls;
    SettingsPanelRef   mSettingsPanel;
};

typedef std::shared_ptr<UiLayer> UiLayerRef;

#include "TimeLabel.h"
#include "cinder/gl/gl.h"
#include "cinder/Text.h"
#include "BloomGl.h"

void TimeLabel::setSeconds(int seconds)
{ 
    if (mSeconds != seconds) { 
        mSeconds = seconds; 
        updateTexture(); 
    }
}

void TimeLabel::updateTexture()
{
	int hours	= floor(abs(mSeconds)/3600.0f);
    int minutes = floor(abs(mSeconds)/60.0f);
	minutes = minutes - hours * 60;
    int seconds = (int)abs(mSeconds)%60;
    
	string hourStr = ci::toString( hours );
    string minsStr = ci::toString( minutes );
    string secsStr = ci::toString( seconds );
    if( minsStr.length() == 1 ) minsStr = "0" + minsStr;
    if( secsStr.length() == 1 ) secsStr = "0" + secsStr;		
	
    stringstream ss;
	if( hours > 0 )
		ss << hourStr << ":";
    ss << minsStr << ":" << secsStr << endl;
        
    TextLayout layout;
    layout.setFont( mFont );
    layout.setColor( mColor );
    layout.addLine( ss.str() );
    mTexture = layout.render( true, false );

    if (mSeconds <= 0) {
        TextLayout hyphenLayout;
        hyphenLayout.setFont( mFont );
        hyphenLayout.setColor( mColor );
        hyphenLayout.addLine( "-" );
        mHyphenTexture = hyphenLayout.render( true, false );
    }
    else {
        mHyphenTexture.reset();
    }
}

void TimeLabel::draw()
{
    // to keep the digit left-aligned in the box, squeeze the minus sign in before it
    if (mHyphenTexture) {
        bloom::gl::batchRect( mHyphenTexture, mRect.getUpperLeft() - Vec2f(mHyphenTexture.getWidth()-1.0f,0) );
    }    
    if (mTexture) {
        bloom::gl::batchRect( mTexture, mRect.getUpperLeft() );
    }
}

bool TimeLabel::touchBegan(ci::app::TouchEvent::Touch touch)
{
    return mRect.contains( globalToLocal( touch.getPos() ) );
}
bool TimeLabel::touchEnded(ci::app::TouchEvent::Touch touch)
{
    return mRect.contains( globalToLocal( touch.getPos() ) );
}

#include "TextureRect.h"
#include "cinder/gl/gl.h"
#include "BloomGl.h"

using namespace ci;

void TextureRect::draw()
{
    bloom::gl::batchRect( mTexture, mArea, mRect );
}

#include "Stats.h"
#include <sstream>
#include "cinder/gl/gl.h"
#include "cinder/Text.h"

using namespace std;
using namespace ci;

void Stats::setup(const Font &font, const Color &fpsColor, const Color &color)
{
    mFont = font;
    mFpsColor = fpsColor;
    mColor = color;
}

void Stats::update(const float &fps, 
                   const float &playheadTime, 
                   const float &fov,
				   const float &camDist,
				   const float &pinchPer,
                   const float &currentLevel, 
                   const float &zoom)
{
    stringstream s;
	TextLayout layout;	
	layout.setFont( mFont );
	layout.setColor( mColor );

	s.str("");
	s << "FPS: " << fps;
	layout.addLine( s.str() );
	
//	s.str("");
//	s << "FOV: " << fov;
//	layout.addLine( s.str() );
//	
//	s.str("");
//	s << "mCamDist: " << camDist;
//	layout.addLine( s.str() );
//	
//	s.str("");
//	s << "mPinchTotalDest: " << pinchPer;
//	layout.addLine( s.str() );
	
	mParamsTex = gl::Texture( layout.render( true, false ) );    
}