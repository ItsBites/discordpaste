package mcli;
import mcli.DispatchError;
import mcli.internal.Data;
#if macro
import haxe.macro.Expr;
import haxe.macro.Type in MType;
import haxe.macro.Context;
import haxe.macro.TypeTools;
#end
using mcli.internal.Tools;
using Lambda;

@:access(mcli.CommandLine) class Dispatch
{

	/**
		Formats an argument definition to String.
		[argSize] maximum argument string length
		[screenSize] maxium characters until a line break should be forced
	**/
	public static function argToString(arg:Argument, argSize=30, ?screenSize)
	{
		if (screenSize == null)
			screenSize = getScreenSize();
		var postfix = getPostfix(arg);
		var versions = getAliases(arg);

		if (versions.length == 0)
			if (arg.description != null)
				return arg.description;
			else
				return "";
		versions.sort(function(s1,s2) return Reflect.compare(s1.length, s2.length));

		var desc = (arg.description != null ? arg.description : "");

		var ret = new StringBuf();
		ret.add("  ");
		var argsTxt = StringTools.rpad(versions.map(function(v) return v).join(", ") + postfix, " ", argSize);
		ret.add(argsTxt);
		if (argsTxt.length > argSize)
		{
			ret.add("\n");
			for (i in 0...argSize)
				ret.add(" ");
		}

		ret.add("   ");
		if (arg.description != null)
			ret.add(arg.description);
		var consolidated = ret.toString();
		var inNewline = false;
		if (consolidated.length > screenSize)
		{
			ret = new StringBuf();
			var c = consolidated.split(" "), ccount = 0;
			for (word in c)
			{
				if (inNewline && word == '')
					continue;
				else
					inNewline = false;
				ccount += word.length + 1;
				if (ccount >= screenSize)
				{
					ret.addChar("\n".code);
					for (i in 0...(argSize + 7))
						ret.add(" ");
					ccount = word.length + 1 + argSize + 8;
					inNewline = true;
					if (word == '') continue;
				}
				ret.add(word);
				ret.add(" ");
			}
			return ret.toString();
		} else {
			return consolidated;
		}
	}

	/**
		With an argument definition array, it formats to show the standard usage help screen
		[screenSize] maximum number of characters before a line break is forced
	**/
	public static function showUsageOf(args:Array<Argument>, ?screenSize):String
	{
		if (screenSize == null)
			screenSize = getScreenSize();
		var maxSize = 0;
		for (arg in args)
		{
			if (arg.name == "runDefault") continue;
			var postfixSize = getPostfix(arg).length;
			var size = arg.command.length + postfixSize + 3;
			if (arg.aliases != null) for (a in arg.aliases)
			{
				size += a.length + 3;
			}

			if (size > maxSize)
				maxSize = size;
		}

		if (maxSize > (screenSize / 2.5)) maxSize = Std.int(screenSize / 2.5);
		var buf = new StringBuf();
		for (arg in args)
		{
			if (arg.name == "runDefault") continue;
			var str = argToString(arg, maxSize, screenSize);
			if (str.length > 0)
			{
				buf.add(str);
				buf.addChar('\n'.code);
			}
		}
		return buf.toString();
	}

	private static function getScreenSize(defaultSize=80)
	{
#if sys
		var cols:Null<Int> = null;
		cols = Std.parseInt(Sys.getEnv("COLUNNS"));
		if (cols != null)
			return cols;
		try
		{
			var proc = new sys.io.Process('resize',[]);
			var i = proc.stdout;
			try
			{
				while(true)
				{
					var ln = StringTools.trim(i.readLine());
					if (StringTools.startsWith(ln,"COLUMNS="))
					{
						cols = Std.parseInt(ln.split('=')[1]);
						break;
					}
				}
			}
			catch(e:haxe.io.Eof) {
			}
			proc.close();
		}
		catch(e:Dynamic)
		{
		}
		if (cols == null)
			return defaultSize;
		else
			return cols;
#else
		return defaultSize;
#end
	}

	private static function getAliases(arg:Argument)
	{
		var versions = arg.aliases != null ? arg.aliases.concat([arg.command]) : [arg.command];
		versions = versions.filter(function(s) return s != null && s != "");

		var prefix = "-";
		if (arg.kind == SubDispatch || arg.kind == Message)
			prefix = "";
		return [ for (v in versions) (v.length == 1) ? prefix + v.toDashSep() : prefix + prefix + v.toDashSep() ];
	}

	private static function getPostfix(arg:Argument)
	{
		return switch(arg.kind)
		{
			case VarHash(k,v,_):
				" " + k.name + "[=" + v.name +"]";
			case Var(_):
				" <" + arg.name + ">";
			case Function(args,vargs):
				var postfix = "";
				for (arg in args)
					postfix += (arg.opt ? " [" : " <") + arg.name.toDashSep() + (arg.opt ? "]" : ">");
				if (vargs != null)
					postfix += " [arg1 [arg2 ...[argN]]]";
				postfix;
			default:
				"";
		};
	}

	private static var decoders:Map<String,Decoder<Dynamic>>;

	/**
		Registers a custom Decoder<T> that will be used to decode 'T' types.
		This function is type-checked and calling it will avoid the 'no Decoder was declared' warnings.

		IMPORTANT: this function must be called before the first .dispatch() that uses the custom type is called
	**/
	macro public static function addDecoder(decoder:ExprOf<Decoder<Dynamic>>)
	{
		var t = Context.typeof(decoder);
		var field = null;
		switch(Context.follow(t))
		{
			case TInst(c,_):
				for (f in c.get().fields.get())
				{
					if (f.name == "fromString")
					{
						field = f;
						break;
					}
				}
			case TAnonymous(a):
				for(f in a.get().fields)
				{
					if (f.name == "fromString")
					{
						field =f;
						break;
					}
				}
			default:
				throw new Error("Unsupported decoder type :" + TypeTools.toString(t), decoder.pos);
		}
		if (field == null)
			throw new Error("The type '" + TypeTools.toString(t) + "' is not compatible with a Decoder type", decoder.pos);
		var type = switch(Context.follow(field.type))
		{
			case TFun([arg],ret): //TODO test arg for string
				ret;
			default:
				throw new Error("The type '" + TypeTools.toString(field.type) + "' is not compatible with a Decoder type", decoder.pos);
		};

		var name = mcli.internal.Macro.convertType(type, decoder.pos);
		mcli.internal.Macro.registerDecoder(name);
		var name = { expr:EConst(CString(name)), pos: decoder.pos };

		return macro mcli.Dispatch.addDecoderRuntime($name, $decoder);
	}

	public static function addDecoderRuntime<T>(name:String, d:Decoder<T>):Void
	{
		if (decoders == null)
			decoders = new Map();
		decoders.set(name,d);
	}

	static function decode(a:String, type:String):Dynamic
	{
		return switch(type)
		{
			case "Int":
				var ret = Std.parseInt(a);
				if (ret == null) throw ArgumentFormatError(type,a);
				ret;
			case "Float":
				var ret = Std.parseFloat(a);
				if (Math.isNaN(ret))
					throw ArgumentFormatError(type,a);
				ret;
			case "String":
				a;
			default:
				var d = decoders != null ? decoders.get(type) : null;
				if (d == null)
				{
					var dt = Type.resolveClass(type);
					if (dt != null && Reflect.hasField(dt, "fromString"))
						d = cast dt;
				}
				if (d == null)
				{
					var dt2 = Type.resolveClass(type + "Decoder");
					if (dt2 != null && Reflect.hasField(dt2, "fromString"))
						d = cast dt2;
				}
				if (d == null)
				{
					var e = Type.resolveEnum(type);
					if (e != null)
					{
						var all = Type.allEnums(e);
						if (all.length > 0 && all.length == Type.getEnumConstructs(e).length)
						{
							for (v in all)
							{
								if (a == Std.string(v).toDashSep())
									return v;
							}
							throw ArgumentFormatError(type,a);
						}
					}
				}

				if (d == null) throw DecoderNotFound(type);
				d.fromString(a);
		};
	}

	public var args(default,null):Array<String>;
	var depth:Int;

	public function new(args:Array<String>)
	{
		this.args = args.copy();
		this.args.reverse();
		this.depth = 0;
	}

	private function errln(s:String)
	{
#if sys
		Sys.stderr().writeString(s + "\n");
#else
		haxe.Log.trace(s,null);
#end
	}

	private function println(s:String)
	{
#if sys
		Sys.println(s);
#else
		haxe.Log.trace(s,null);
#end
	}

	private static function isArgument(str:String)
	{
		if (str.charCodeAt(0) == '-'.code)
		{
			var code = str.charCodeAt(1);
			if (code >= '0'.code && code <= '9'.code || code == '.'.code)
				return false;
			else
				return true;
		}
		return false;
	}

	public function dispatch(v:mcli.CommandLine, handleExceptions = true):Void
	{
		this.depth++;
		try
		{
			_dispatch(v,handleExceptions);
			this.depth--;
		}
		catch(e:Dynamic)
		{
			this.depth--;
#if cpp
			cpp.Lib.rethrow(e);
#elseif neko
			neko.Lib.rethrow(e);
#elseif cs
			cs.Lib.rethrow(e);
#else
			throw e;
#end
		}
	}

	private function _dispatch(v:mcli.CommandLine, handleExceptions:Bool):Void
	{
		if (handleExceptions)
		{
			try
			{
				_dispatch(v,false);
			}
			catch(e:DispatchError)
			{
				switch(e)
				{
					case UnknownArgument(a):
						errln('ERROR: Unknown argument: $a');
					case ArgumentFormatError(t,p):
						errln('ERROR: Unrecognized format for $t. Passed $p');
					case DecoderNotFound(t):
						errln('[mcli error] No Decoder found for type $t');
					case MissingOptionArgument(opt,name) if (opt == "--run-default"):
						errln('ERROR: The argument $name is required');
					case MissingOptionArgument(opt,name):
						name = name != null ? " (" + name + ")" : "";
						errln('ERROR: The option $opt requires an argument $name, but no argument was passed');
					case MissingArgument:
						errln('ERROR: Missing arguments');
					case TooManyArguments:
						errln('ERROR: Too many arguments');
				}
				println(v.showUsage());
#if sys
				Sys.exit(1);
#end
			}

			return;
		}

		var defs = v.getArguments();
		var names = new Map();
		for (arg in defs)
			for (a in getAliases(arg))
				names.set(a, arg);

		var didCall = false, defaultRan = false;
		var delays = [];
		function runArgument(arg:String, argDef:Argument)
		{
			switch(argDef.kind)
			{
				case Flag:
					Reflect.setProperty(v, argDef.name, true);
				case VarHash(key,val,arr):
					var map:Map.IMap<Dynamic,Dynamic> = Reflect.getProperty(v, argDef.name);
					var n = args.pop();
					var toAdd = [];
					while(n != null && isArgument(n))
					{
						toAdd.push(n);
						n = args.pop();
					}
					if (n == null)
						throw MissingOptionArgument(arg, key.name);
					var kv = n.split("=");
					var k = decode(kv[0], key.t);
					var v = null;
					if (kv[1] != null)
						v = decode(kv[1], val.t);
					var oldv = map.get(k);
					if (oldv != null)
					{
						if (arr)
							oldv.push(v);
						// else //TODO
							// throw RepeatedArgument(arg
					} else {
						if (arr)
							map.set(k, [v]);
						else
							map.set(k,v);
					}
					if (toAdd.length > 0)
					{
						toAdd.reverse();
						args = args.concat(toAdd);
					}
				case Var(t):
					var n = args.pop();
					var toAdd = [];
					while(n != null && isArgument(n))
					{
						toAdd.push(n);
						n = args.pop();
					}
					if (n == null)
						throw MissingOptionArgument(arg);
					var val = decode(n, t);
					Reflect.setProperty(v, argDef.name, val);
					if (toAdd.length > 0)
					{
						toAdd.reverse();
						args = args.concat(toAdd);
					}
				case Function(fargs,varArg):
					didCall = true;
					var applied:Array<Dynamic> = [];
					var toAdd = [];
					var origArg = arg;
					for (fa in fargs)
					{
						arg = args.pop();
						while (arg != null && isArgument(arg))
						{
							toAdd.push(arg);
							arg = args.pop();
						}
						if (arg == null && !fa.opt)
							throw MissingOptionArgument(origArg, fa.name);
						applied.push(decode(arg, fa.t));
					}
					if (varArg != null)
					{
						var va = [];
						while (args.length > 0)
						{
							var arg = args.pop();
							if (isArgument(arg))
							{
								args.push(arg);
								break;
							} else {
								va.push(decode(arg,varArg));
							}
						}
						applied.push(va);
					}
					delays.push(function() Reflect.callMethod(v, Reflect.field(v, argDef.name), applied));
					if (toAdd.length != 0)
					{
						toAdd.reverse();
						args = args.concat(toAdd);
					}
				case SubDispatch:
					didCall = true;
					for (d in delays) d();
					delays = [];
					Reflect.callMethod(v, Reflect.field(v, argDef.name), [this]);
				case Message:
					throw UnknownArgument(arg);
			}
		}

		function getDefaultAlias() {
			return
				if (names.exists("--run-default")) "--run-default";
				else if (names.exists("run-default")) "run-default";
				else "";
		}

		while (args.length > 0)
		{
			var arg = args.pop();
			var argDef = names.get(arg);
			if (argDef == null)
			{
				if (!isArgument(arg))
				{
					if (!defaultRan && !v._preventDefault)
					{
						argDef = names.get(getDefaultAlias());
						if (argDef != null)
							defaultRan = true;
						args.push(arg);
					}
				} else if (arg.length > 2 && arg.charCodeAt(1) != '-'.code) {
					var a = arg.substr(1).split('').map(function(v) return '-' + v);
					a.reverse();
					args = args.concat(a);
					continue;
				}
			}
			if (argDef == null)
				if (arg != null) {
					if ( (didCall == false && !v._preventDefault) || depth == 1 )
					{
						throw UnknownArgument(arg);
					} else {
						args.push(arg);
						break;
					}
				}
				else
					throw MissingArgument;

			runArgument(arg, argDef);
		}

		var defaultAlias = getDefaultAlias();
		var argDef = names.get(defaultAlias);

		for (d in delays) d();
		delays = [];
		if (argDef == null)
		{
			if (!didCall)
				throw MissingArgument;
		} else {
			if (!didCall && !v._preventDefault)
			{
				runArgument(defaultAlias, argDef);
			} else if (!defaultRan && !v._preventDefault) switch(argDef.kind) {
				case Function(args,_) if (!args.exists(function(a) return !a.opt)):
					runArgument(defaultAlias, argDef); //only run default if compatible
				default:
			}
		}
		for (d in delays) d();
	}
}

/* Same license as Node.js
   Maintainer: Ritchie Turner, blackdog@cloudshift.cl

   Node.js 0.8 api without haXe embellishments so that other apis may be implemented
   on top without being hindered by design choices here.

   Domain not added.
*/

package js;

typedef NodeListener = Dynamic;
typedef NodeErr = Null<String>;

/* 
   emits: newListener
 */
typedef NodeEventEmitter = {
  function addListener(event:String,fn:NodeListener):Dynamic;
  function on(event:String,fn:NodeListener):Dynamic;
  function once(event:String,fn:NodeListener):Void;
  function removeListener(event:String,listener:NodeListener):Void;
  function removeAllListeners(event:String):Void;
  function listeners(event:String):Array<NodeListener>;
  function setMaxListeners(m:Int):Void;
  function emit(event:String,?arg1:Dynamic,?arg2:Dynamic,?arg3:Dynamic):Void;
}

typedef NodeWatchOpt = {persistent:Bool,interval:Int};

typedef NodeExecOpt = {
  var encoding:String;
  var timeout:Int;
  var maxBuffer:Int;
  var killSignal:String;
  var env:Dynamic;
  var cwd:String;
}

typedef NodeSpawnOpt = {
  var cwd:String;
  var env:Dynamic;
  var customFds:Array<Int>;
  var setsid:Bool;
}

/* note:can't spec multiple optional args, so adding an arbitrary 3 */
typedef NodeConsole = {
  function log(s:String,?a1:Dynamic,?a2:Dynamic,?a3:Dynamic):Void;
  function info(s:String,?a1:Dynamic,?a2:Dynamic,?a3:Dynamic):Void;
  function warn(s:String,?a1:Dynamic,?a2:Dynamic,?a3:Dynamic):Void;
  function error(s:String,?a1:Dynamic,?a2:Dynamic,?a3:Dynamic):Void;
  function time(label:String):Void;
  function timeEnd(label:String):Void;
  function dir(obj:Dynamic):Void;
  function trace():Void;
  function assert():Void;
}
  
typedef NodePath = {
  function join(?p1:String,?p2:String,?p3:String):String;
  function normalize(p:String):String;
  function resolve(from:Array<String>,to:String):Void;
  function dirname(p:String):String;
  function basename(p:String,?ext:String):String;
  function extname(p:String):String;

  /* deprecated 0.8, use NodeFs equivs instead */
  function exists(p:String,cb:Bool->Void):Void;
  function existsSync(p:String):Bool;
}

typedef NodeUrlObj = {
  var href:String;
  var host:String;
  var protocol:String;
  var auth:String;
  var hostname:String;
  var port:String;
  var pathname:String;
  var search:String;
  var query:Dynamic;
  var hash:String;
}

typedef NodeUrl = {
  function parse(p:String,?andQueryString:Bool):NodeUrlObj;
  function format(o:NodeUrlObj):String;
  function resolve(from:Array<String>,to:String):String;
}

typedef NodeQueryString = {
  function parse(s:String,?sep:String,?eq:String,?options:{maxKeys:Int}):Dynamic;
  function escape(s:String):String;
  function unescape(s:String):String;
  function stringify(obj:Dynamic,?sep:String,?eq:String):String;
}

@:native("Buffer") extern class NodeBuffer implements ArrayAccess<Int> {

   @:overload(function(str:String,?enc:String):Void {})
   @:overload(function(arr:Array<Int>):Void {})
  function new(size:Int):Void;

  var length(default,null) : Int;
  var INSPECT_MAX_BYTES:Int;
  
  function copy(targetBuffer:NodeBuffer,targetStart:Int,sourceStart:Int,sourceEnd:Int):Void;
  function slice(start:Int,end:Int):NodeBuffer;
  function write(s:String,?offset:Int,?length:Int,?enc:String):Int;
  function toString(enc:String,?start:Int,?end:Int):String;
  function fill(value:Float,offset:Int,?end:Int):Void;
  static function isBuffer(o:Dynamic):Bool;
  static function byteLength(s:String,?enc:String):Int;

  function readUInt8(offset:Int,?noAssert:Bool):Int;
  function readUInt16LE(offset:Int,?noAssert:Bool):Int;
  function readUInt16BE(offset:Int,?noAssert:Bool):Int;
  function readUInt32LE(offset:Int,?noAssert:Bool):Int;
  function readUInt32BE(offset:Int,?noAssert:Bool):Int;

  function readInt8(offset:Int,?noAssert:Bool):Int;
  function readInt16LE(offset:Int,?noAssert:Bool):Int;
  function readInt16BE(offset:Int,?noAssert:Bool):Int;
  function readInt32LE(offset:Int,?noAssert:Bool):Int;
  function readInt32BE(offset:Int,?noAssert:Bool):Int;

  function readFloatLE(offset:Int,?noAssert:Bool):Float;
  function readFloatBE(offset:Int,?noAssert:Bool):Float;
  function readDoubleLE(offset:Int,?noAssert:Bool):Float; // is this right?
  function readDoubleBE(offset:Int,?noAssert:Bool):Float; // is this right?

  function writeUInt8(value:Int,offset:Int,?noAssert:Bool):Void;
  function writeUInt16LE(value:Int,offset:Int,?noAssert:Bool):Void;
  function writeUInt16BE(value:Int,offset:Int,?noAssert:Bool):Void;
  function writeUInt32LE(value:Int,offset:Int,?noAssert:Bool):Void;
  function writeUInt32BE(value:Int,offset:Int,?noAssert:Bool):Void;

  function writeInt8(value:Int,offset:Int,?noAssert:Bool):Void;
  function writeInt16LE(value:Int,offset:Int,?noAssert:Bool):Void;
  function writeInt16BE(value:Int,offset:Int,?noAssert:Bool):Void;
  function writeInt32LE(value:Int,offset:Int,?noAssert:Bool):Void;
  function writeInt32BE(value:Int,offset:Int,?noAssert:Bool):Void;

  function writeFloatLE(value:Float,offset:Int,?noAssert:Bool):Void;
  function writeFloatBE(value:Float,offset:Int,?noAssert:Bool):Void;
  function writeDoubleLE(value:Float,offset:Int,?noAssert:Bool):Void; // is this right?
  function writeDoubleBE(value:Float,offset:Int,?noAssert:Bool):Void; // is this right?
}

typedef NodeScript = {
  function runInThisContext():Dynamic;
  function runInNewContext(?sandbox:Dynamic):Void;
}

typedef NodeVM =  {  
    function runInThisContext(code:String,?fileName:String):Dynamic;
    function runInNewContext(?sandbox:Dynamic):Void;
    function createScript(code:Dynamic,?fileName:String):NodeScript;
}
  
typedef ReadStreamOpt = {
    flags:String,
    encoding:String,
    fd:Null<Int>,
    mode:Int,
    bufferSize:Int,
    ?start:Int,
    ?end:Int
}

typedef WriteStreamOpt = {
  var flags:String;
  var encoding:String;
  var mode:Int;
}

/* 
   Emits:
   data,end,error,close
*/
typedef NodeReadStream = { > NodeEventEmitter,
  var readable:Bool;
  function pause():Void;
  function resume():Void;
  function destroy():Void;
  function destroySoon():Void;
  function setEncoding(enc:String):Void;
  function pipe(dest:NodeWriteStream,?opts:{end:Bool}):Void;
}

/* 
   Emits:
   drain,error,close,pipe
*/
typedef NodeWriteStream = { > NodeEventEmitter,
  var writeable:Bool;
  @:overload(function(chunk:NodeBuffer):Bool {})
  function write(d:String,?enc:String,?fd:Int):Bool;
  @:overload(function(b:NodeBuffer):Void {})
  function end(?s:String,?enc:String):Void;
  function destroy():Void;
  function destroySoon():Void;
}

typedef NodeOs = {
  function hostname():String;
  function type():String;
  function release():String;
  function uptime():Int;
  function loadavg():Array<Float>;
  function totalmem():Int;
  function freemem():Int;
  function cpus():Int;
  function platform():String;
  function arch():String;
  function networkInterfaces():Dynamic;
}


typedef NodeJsDate = {
    function getTime():Int;
    function toDateString():String;
    function toUTCString():String;
}

typedef NodeStat = {
  var dev:Int;
  var ino:Int;
  var mode:Int;
  var nlink:Int;
  var uid:Int;
  var gid:Int;
  var rdev:Int;
  var size:Int;
  var blkSize:Int;
  var blocks:Int;
  var atime:NodeJsDate;
  var mtime:NodeJsDate;
  var ctime:NodeJsDate;
  
  function isFile():Bool;
  function isDirectory():Bool;
  function isBlockDevice():Bool;
  function isCharacterDevice():Bool;
  function isSymbolicLink():Bool;
  function isFIFO():Bool;
  function isSocket():Bool;
}

/*
  Emits: error,change
 */
typedef NodeFSWatcher = { > NodeEventEmitter,
   function close():Void;
}

typedef NodeFS = {
  function rename(from:String,to:String,cb:NodeErr->Void):Void;
  function renameSync(from:String,to:String):Void;
  
  function stat(path:String,cb:NodeErr->NodeStat->Void):Void;
  function statSync(path:String):NodeStat;

  function lstat(path:Dynamic,cb:NodeErr->NodeStat->Void):Void;
  function lstatSync(path:String):NodeStat;
  
  function fstat(fd:Int,cb:NodeErr->NodeStat->Void):Void;
  function fstatSync(fd:Int):NodeStat;
  
  function link(srcPath:String,dstPath:String,cb:NodeErr->Void):Void;
  function linkSync(srcPath:String,dstPath:String):Void;

  function unlink(path:String,cn:NodeErr->Void):Void;
  function unlinkSync(path:String):Void;
  
  function symlink(linkData:Dynamic,path:String,?type:String,?cb:NodeErr->Void):Void;
  function symlinkSync(linkData:Dynamic,path:String,?type:String):Void;
  
  function readlink(path:String,cb:NodeErr->String->Void):Void;
  function readlinkSync(path:String):String;
  
  function realpath(path:String,cb:NodeErr->String->Void):Void;
  function realpathSync(path:String):String;
  
  function chmod(path:String,mode:Int,cb:NodeErr->Void):Void;
  function chmodSync(path:String,?mode:Int):Void;

  function fchmod(fd:Int,mode:Int,cb:NodeErr->Void):Void;
  function fchmodSync(fd:Int,?mode:Int):Void;

  function chown(path:String,uid:Int,gid:Int,cb:NodeErr->Void):Void ;
  function chownSync(path:String,uid:Int,gid:Int):Void;
  
  function fchown(fd:Int,uid:Int,gid:Int,cb:NodeErr->Void):Void ;
  function fchownSync(fd:Int,uid:Int,gid:Int):Void;

  function rmdir(path:String,cb:NodeErr->Void):Void;
  function rmdirSync(path:String):Void;
  
  function mkdir(path:String,?mode:Int,?cb:NodeErr->Void):Void;
  function mkdirSync(path:String,?mode:Int):Void;
  
  function readdir(path:String,cb:NodeErr->Array<String>->Void):Void;
  function readdirSync(path:String):Array<String>;
  
  function close(fd:Int,cb:NodeErr->Void):Void;
  function closeSync(fd:Int):Void;
  
  function open(path:String,flags:String,?mode:Int,cb:NodeErr->Int->Void):Void;
  
  function openSync(path:String,flags:String,?mode:Int):Int;
  
  function write(fd:Int,bufOrStr:Dynamic,offset:Int,length:Int,position:Null<Int>,?cb:NodeErr->Int->Void):Void;
  function writeSync(fd:Int,bufOrStr:Dynamic,offset:Int,length:Int,position:Null<Int>):Int;
  
  function read(fd:Int,buffer:NodeBuffer,offset:Int,length:Int,position:Int,cb:NodeErr->Int->NodeBuffer->Void):Void;
  function readSync(fd:Int,buffer:NodeBuffer,offset:Int,length:Int,position:Int):Int;
  
  function truncate(fd:Int,len:Int,cb:NodeErr->Void):Void;
  function truncateSync(fd:Int,len:Int):NodeErr;
  
  function readFile(path:String,?enc:String,cb:NodeErr->String->Void):Void;
  function readFileSync(path:String,?enc:String):String;

  @:overload(function(fileName:String,data:NodeBuffer,cb:NodeErr->Void):Void {})
  function writeFile(fileName:String,contents:String,?enc:String,cb:NodeErr->Void):Void;
  @:overload(function(fileName:String,data:NodeBuffer):Void {})
  function writeFileSync(fileName:String,contents:String,?enc:String):Void;

  @:overload(function(fileName:String,data:NodeBuffer,cb:NodeErr->Void):Void {})
  function appendFile(fileName:String,contents:String,?enc:String,cb:NodeErr->Void):Void;

  @:overload(function(fileName:String,data:NodeBuffer):Void {})
  function appendFileSync(fileName:String,contents:String,?enc:String):Void;

  
  function utimes(path:String,atime:Dynamic,mtime:Dynamic,cb:NodeErr->Void):Void;
  function utimeSync(path:String,atime:Dynamic,mtime:Dynamic):Void;

  function futimes(fd:Int,atime:Dynamic,mtime:Dynamic,cb:NodeErr->Void):Void;
  function futimeSync(fd:Int,atime:Dynamic,mtime:Dynamic):Void;

  function fsync(fd:Int,cb:NodeErr->Void):Void;
  function fsyncSync(fd:Int):Void;
  
  function watchFile(fileName:String,?options:NodeWatchOpt,listener:NodeStat->NodeStat->Void):Void;
  function unwatchFile(fileName:String):Void;
  function watch(fileName:String,?options:NodeWatchOpt,listener:String->String->Void):NodeFSWatcher;
  function createReadStream(path:String,?options:ReadStreamOpt):NodeReadStream;
  function createWriteStream(path:String,?options:WriteStreamOpt):NodeWriteStream;

  function exists(p:String,cb:Bool->Void):Void;
  function existsSync(p:String):Bool;
}
  
typedef NodeUtil = {
  function debug(s:String):Void;
  function inspect(o:Dynamic,?showHidden:Bool,?depth:Int):Void;
  function log(s:String):Void;
  function pump(rs:NodeReadStream,ws:NodeWriteStream,cb:Dynamic->Void):Void;
  function inherits(constructor:Dynamic,superConstructor:Dynamic):Void;
  function isArray(o:Dynamic):Bool;
  function isRegExp(o:Dynamic):Bool;
  function isDate(o:Dynamic):Bool;
  function isError(o:Dynamic):Bool;
  function format(out:String,?a1:Dynamic,?a2:Dynamic,?a3:Dynamic):Void; // should be arbitrary # of args
}

/* 
  Emits:
  exit, uncaughtException + SIGNAL events (SIGINT etc)
 */
typedef NodeProcess = { > NodeEventEmitter,
  var stdout:NodeWriteStream;
  var stdin:NodeReadStream;
  var stderr:NodeWriteStream;
  var argv:Array<String>;
  var env:Dynamic;
  var pid:Int;
  var title:String;
  var arch:String;
  var platform:String;
  var installPrefix:String;
  var execPath:String;
  var version:String;
  var versions:Dynamic;
  
  function memoryUsage():{rss:Int,vsize:Int,heapUsed:Int,heapTotal:Int};
  function nextTick(fn:Void->Void):Void;
  function exit(code:Int):Void;
  function cwd():String;
  function getuid():Int;
  function getgid():Int;
  function setuid(u:Int):Void;
  function setgid(g:Int):Void;
  function umask(?m:Int):Int;
  function chdir(d:String):Void;
  function kill(pid:Int,?signal:String):Void;
  function uptime():Int;
  function abort():Void;
  function hrtime():Array<Int>;
}

/*
  Emits: exit,close
*/
typedef NodeChildProcess = { > NodeEventEmitter,
    var stdin:NodeWriteStream;
    var stdout:NodeReadStream;
    var stderr:NodeReadStream;
    var pid:Int;
    function kill(signal:String):Void;
}

/*
  Emits: message
*/
typedef NodeChildForkProcess = { > NodeChildProcess,
     @:overload(function(o:Dynamic,?socket:NodeNetSocket):Void {})
     function send(o:Dynamic,?server:NodeNetServer):Void;  
}

typedef NodeChildProcessCommands = { 
  function spawn(command: String,args: Array<String>,?options: Dynamic ) : NodeChildProcess;
  function exec(command: String,?options:Dynamic,cb: {code:Int}->String->String->Void ): NodeChildProcess;
  function execFile(command: String,?options:Dynamic,cb: {code:Int}->String->String->Void ): NodeChildProcess;
  function fork(path:String,?args:Dynamic,?options:Dynamic):NodeChildForkProcess;
}

typedef NodeClusterSettings = {
    var exec:String;
    var args:Array<String>;
    var silent:Bool;
}


/* emits: message, online,listening,disconnect,exit, setup */
typedef NodeWorker = { > NodeEventEmitter,
    var uniqueID:String; // indexes into cluster.workers
    var process:NodeChildProcess;
    var suicide:Bool;
    function send(message:Dynamic,?sendHandle:Dynamic):Void;
    function destroy():Void;
}

/* Emits: death,message, fork, online, listening  */
typedef NodeCluster = { > NodeEventEmitter,
  var isMaster:Bool;
  var isWorker:Bool;
  var workers:Array<NodeWorker>;
  function fork(?env:Dynamic):NodeWorker;
  function send(o:Dynamic):Void;
  function setupMaster(?settings:NodeClusterSettings):Void;
  function disconnect(?cb:Void->Void):Void;
}


/* NET ............................................. */
  
/* 
   Emits:
   connection
*/
typedef NodeNet = { > NodeEventEmitter, 
  function createServer(?options:{allowHalfOpen:Bool},fn:NodeNetSocket->Void):NodeNetServer;
  @:overload(function(cs:String):NodeNetSocket {})
  function createConnection(port:Int,host:String):NodeNetSocket;
  @:overload(function(cs:String):NodeNetSocket {})
  function connect(port:Int,host:String):NodeNetSocket;                    
  function isIP(input:String):Int; // 4 or 6
  function isIPv4(input:String):Bool;
  function isIPv6(input:String):Bool;
}
  
/* 
   Emits:
   connection,close,error,listening
*/
typedef NodeNetServer = { > NodeEventEmitter,
  var maxConnections:Int;
  var connections:Int;

  @:overload(function(path:String,?cb:Void->Void):Void {})
  @:overload(function(fd:Int,?cb:Void->Void):Void {})                        
  function listen(port:Int,?host:String,?cb:Void->Void):Void;
  function close(cb:Void->Void):Void;
  function address():Void;
  function pause(msecs:Int):Void;
}

typedef NodeConnectionOpt = {
    port:Int,
    ?host:String,
    ?localAddress:String
}

/*
  
  Emits:
  connect,data,end,timeout,drain,error,close

  implements a duplex stream interface
*/
typedef NodeNetSocket = { > NodeEventEmitter, 
  var remoteAddress:String;
  var remotePort:Int;
  var bufferSize:Int;
  var bytesRead:Int;
  var bytesWritten:Int;
                          
  @:overload(function(path:String,?cb:Void->Void):Void {})
  @:overload(function(options:NodeConnectionOpt,connectionListener:Void->Void):Void {})
  function connect(port:Int,?host:String,?cb:Void->Void):Void;
  function setEncoding(enc:String):Void;
  function setSecure():Void;
  @:overload(function(data:Dynamic,?enc:String,?fileDesc:Int,?cb:Void->Void):Bool {})
  function write(data:Dynamic,?enc:String,?cb:Void->Void):Bool;
  function end(?data:Dynamic,?enc:String):Void;
  function destroy():Void;
  function pause():Void;
  function resume():Void;
  function setTimeout(timeout:Int,?cb:Void->Void):Void;
  function setNoDelay(?noDelay:Bool):Void;
  function setKeepAlive(enable:Bool,?delay:Int):Void;
  function address():{address:String,port:Int}; 
}

/* HTTP ............................................*/

  
/* 
   Emits:
   data,end,close
 */
typedef NodeHttpServerReq = { >NodeEventEmitter,
  var method:String;
  var url:String;
  var headers:Dynamic;
  var trailers:Dynamic;
  var httpVersion:String;
  var connection:NodeNetSocket;
  function setEncoding(enc:String):Void;
  function pause():Void;
  function resume():Void;
}

/* 
 */
typedef NodeHttpServerResp = { > NodeWriteStream, 
  var statusCode:Int;
  function writeContinue():Void;
  @:overload(function(statusCode:Int,?reasonPhrase:String,?headers:Dynamic):Void {})
  function writeHead(statusCode:Int,headers:Dynamic):Void;
  function setHeader(name:String,value:Dynamic):Void;
  function getHeader(name:String):Dynamic;
  function removeHeader(name:String):Void;
  function addTrailers(headers:Dynamic):Void;
}

/* Emits:
   continue,response
*/
typedef NodeHttpClientReq = { > NodeEventEmitter,
  function write(data:Dynamic,?enc:String):Void;
  function end(?data:Dynamic,?enc:String):Void;
  function abort():Void;
}

/* Emits:
   data,end,close
*/
typedef NodeHttpClientResp = { > NodeEventEmitter,
  var statusCode:Int;
  var httpVersion:String;
  var headers:Dynamic;
  var client:NodeHttpClient;
  function setEncoding(enc:String):Void;
  function resume():Void;
  function pause():Void;  
}


typedef NodeHttpClient = { > NodeEventEmitter,
  function request(method:String,path:String,?headers:Dynamic):NodeHttpClientReq;
  function verifyPeer():Bool;
  function getPeerCertificate():NodePeerCert;
}

/* 
   Emits:
   request,connection,checkContinue,connect,clientError,close
 */
typedef NodeHttpServer = { > NodeEventEmitter,
  @:overload(function(path:String,?cb:Void->Void):Void {})
  function listen(port:Int,?host:String,?cb:Void->Void):Void;
  function close(?cb:Void->Void):Void;
}

/* 
 */
typedef NodeHttpReqOpt = {
  var host:String;
  var port:Int;
  var path:String;
  var method:String;
  var headers:Dynamic;
}

typedef NodeHttpsReqOpt =  { > NodeHttpReqOpt,
   var ciphers:Dynamic;
   var rejectUnauthorized:Dynamic;
}

/* 
   Emits:
   upgrade,continue
*/
typedef NodeAgent = { > NodeEventEmitter,
  var maxSockets:Int;
  var sockets:Array<NodeNetSocket>;
  var queue:Array<NodeHttpServerReq>;
}
    
typedef NodeHttp = {
  function createServer(listener:NodeHttpServerReq->NodeHttpServerResp->Void):NodeHttpServer;
  function createClient(port:Int,host:String):NodeHttpClient;
  @:overload(function(parsedUrl:NodeUrlObj,res:NodeHttpClientResp->Void):NodeHttpClientReq {})
  function request(options:NodeHttpReqOpt,res:NodeHttpClientResp->Void):NodeHttpClientReq;
  @:overload(function(parsedUrl:NodeUrlObj,res:NodeHttpClientResp->Void):Void {})
  function get(options:NodeHttpReqOpt,res:NodeHttpClientResp->Void):Void;
  function getAgent(host:String,port:Int):NodeAgent;
}
  
typedef NodeHttps = {
  function createServer(options:{key:String,cert:String},
                        listener:NodeHttpServerReq->NodeHttpServerResp->Void):NodeHttpServer;
  function request(options:NodeHttpsReqOpt,res:NodeHttpClientResp->Void):Void;
  function get(options:NodeHttpsReqOpt,res:NodeHttpClientResp->Void):Void;
}
  
typedef NodeDns = {
  function resolve(domain:String,?rrtype:String,cb:NodeErr->Array<Dynamic>->Void):Void;
  function resolveNs(domain:String,cb:NodeErr->Array<Dynamic>->Void):Void;
  function resolve4(domain:String,cb:NodeErr->Array<String>->Void):Void;
  function resolve6(domain:String,cb:NodeErr->Array<String>->Void):Void;
  function resolveMx(domain:String,cb:NodeErr->Array<{priority:Int,exchange:String}>->Void):Void;
  function resolveSrv(domain:String,cb:NodeErr->Array<{priority:Int,weight:Int,port:Int,name:String}->Void>):Void;
  function resolveCname(domain:String,cb:NodeErr->Array<String>->Void):Void;
  function reverse(ip:String,cb:NodeErr->Array<String>->Void):Void;
  function resolveTxt(domain:String,cb:NodeErr->Array<String>->Void):Void;
  function lookup(domain:String,?family:String,cb:NodeErr->String->Int->Void):Void;
}

typedef NodeTTY = {
  /* returns a non homogenous array of elements, el[0].fd, el[1] is a child process obj
     best check it manually */
  function open(path:String,args:Dynamic):Array<Dynamic>;
  function isatty(fd:Int):Bool;
  function setRawMode(mode:Bool):Void;
  function setWindowSize(fd:Int,row:Int,col:Int):Void;
  function getWindowSize(fd:Int):{row:Int,col:Int};
}

/* UDP ........................................ */

typedef NodeUDPCallback = NodeErr->haxe.io.Bytes->Void;

typedef NodeUDP = {
  // Valid types: udp6, and unix_dgram.
  function createSocket(type:String,cb:NodeUDPCallback):NodeDGSocket;
}

/* 
   Emits: message,listening,close
*/
typedef NodeDGSocket = { > NodeEventEmitter,
  function send(buf:NodeBuffer,offset:Int,length:Int,port:Int,address:String,cb:NodeUDPCallback):Void;
  function bind(port:Int,?address:String):Void;
  function close():Void;
  function address():Dynamic;
  function setBroadcast(flag:Bool):Void;
  function setTTL(ttl:Int):Void;
  function setMulticastTTL(ttl:Int):Void;
  function setMulticastLoopback(flag:Bool):Void;
  function addMembership(multicastAddress:String,?multicastInterface:String):Void;
  function dropMembership(multicastAddress:String,?multicastInterface:String):Void;
}
  

/* CRYPTO ..................................... */
  
typedef NodeCredDetails = {
  var key:String;
  var cert:String;
  var ca:Array<String>;
  /*
    TODO
  */
}

typedef NodePeerCert = {
  var subject:String;
  var issuer:String;
  var valid_from:String;
  var valid_to:String;
}

typedef NodeCreds = Dynamic;

typedef NodeHmac = {
  function update(data:Dynamic):Void;
  function digest(?enc:String):String;
}
  
typedef NodeHash = {
  function update(data:Dynamic):Void;
  function digest(?enc:String):String;
  function createHmac(algo:String,key:String):NodeHmac;
}

typedef NodeCipher = {
  function update(data:Dynamic,?input_enc:String,?output_enc:String):Dynamic;
  function final(output_enc:String):Void;
  function setAutoPadding(padding:Bool):Void; // default true
}
  
typedef NodeDecipher = {
  function update(data:Dynamic,?input_enc:String,?output_enc:String):Dynamic;
  function final(?output_enc:String):Dynamic;
  function setAutoPadding(padding:Bool):Void; // default true
}
  
typedef NodeSigner = {
  function update(data:Dynamic):Void;
  function sign(private_key:String,?output_format:String):Dynamic;
}
  
typedef NodeVerify = {
  function update(data:Dynamic):Void;
  function verify(cert:String,?sig_format:String):Bool;
}

typedef NodeDiffieHellman = {
    function generateKeys(?enc:String):String;
    function computeSecret(otherPublicKey:String,?inputEnc:String,?outputEnc:String):String;
    function getPrime(?enc:String):Int;
    function getGenerator(?enc:String):String;
    function getPublicKey(?enc:String):String;
    function getPrivateKey(?enc:String):String;
    function setPublicKey(pubKey:String,?enc:String):Void;
    function setPrivateKey(privKey:String,?enc:String):Void;
}

typedef NodeCrypto = {
  function createCredentials(details:NodeCredDetails):NodeCreds;
  function createHash(algo:String):NodeHash; // 'sha1', 'md5', 'sha256', 'sha512'
  function createCipher(algo:String,password:String):NodeCipher;
  function createCipheriv(algo:String,key:String,iv:String):NodeCipher;
  function createDecipher(algo:String,key:String):NodeDecipher;
  function createDecipheriv(algo:String,key:String,iv:String):NodeDecipher;
  function createSign(algo:String):NodeSigner;
  function createVerify(algo:String):NodeVerify;
  @:overload(function(prime_length:Int):NodeDiffieHellman {})
  function createDiffieHellman(prime:String,?enc:String):NodeDiffieHellman;
  function getDiffieHellman(groupName:String):NodeDiffieHellman;
  function pbkdf2(password:String,salt:String,iterations:Int,keylen:Int,cb:NodeErr->String):Void;
  function randomBytes(size:Int,cb:NodeErr->NodeBuffer):Void;

}

/* TLS/SSL ................................................ */

/* 
   Emits:
   secureConnection
*/
typedef NodeTLSServer =  { > NodeNetServer,
    function addContext(hostName:String,credentials:NodeCreds):Void;

}

/* Emits: secure */
typedef NodeSecurePair = { > NodeEventEmitter,
   // ?? todo
}
typedef NodeTLS ={
  function connect(port:Int,host:String,opts:Dynamic,cb:Void->Void):Void;
  function createServer(opts:Dynamic,cb:NodeTLSServer->Void):Void;
  function createSecurePair(creds:NodeCreds,isServer:Bool,requestCert:Bool,rejectUnauthorized:Bool):NodeSecurePair;
}

/*
  Snarfed from Tong's version ...
 */ 
typedef NodeAssert = {
	function fail(actual:Dynamic,expected:Dynamic,message:Dynamic,operator:Dynamic): Void;
	function ok(value:Dynamic,?message:Dynamic):Void;
	function equal(actual:Dynamic,expected:Dynamic,?message:Dynamic):Void;
	function notEqual(actual:Dynamic,expected:Dynamic,?message:Dynamic):Void;
	function deepEqual(actual:Dynamic,expected:Dynamic,?message:Dynamic):Void;
	function notDeepEqual(actual:Dynamic,expected:Dynamic,?message:Dynamic):Void;
	function strictEqual(actual:Dynamic,expected:Dynamic,?message:Dynamic):Void;
	function notStrictEqual(actual:Dynamic,expected:Dynamic,?message:Dynamic):Void;
	function throws(block:Dynamic,error:Dynamic,?message:Dynamic):Void;
	function doesNotThrow(block:Dynamic,error:Dynamic,?message:Dynamic):Void;
	function ifError(value:Dynamic):Void;
}

typedef NodeREPL = {
	function start( prompt : String, ?stream : Dynamic ) : Void;
}

typedef NodeGZip = {}
typedef NodeGUnzip = {}
typedef NodeDeflate = {}
typedef NodeInflate = {}
typedef NodeDeflateRaw = {}
typedef NodeInflateRaw = {}
typedef NodeUnzip = {}


typedef NodeZLib = {
    function createGzip(?options:Dynamic):NodeGZip;
    function createGunzip(?options:Dynamic):NodeGUnzip;
    function createDeflate(?options:Dynamic):NodeDeflate;
    function createInflate(?options:Dynamic):NodeInflate;
    function createInflateRaw(?options:Dynamic):NodeInflateRaw;
    function createDeflateRaw(?options:Dynamic):NodeDeflateRaw;
    function createUnzip(?options:Dynamic):NodeUnzip;

    // convenience
    @:overload(function (str:String,cb:NodeErr->Dynamic->Void):Void {})
    function deflate(buf:NodeBuffer,cb:NodeErr->Dynamic->Void):Void;
    @:overload(function (str:String,cb:NodeErr->Dynamic->Void):Void {})
    function deflateRaw(buf:NodeBuffer,cb:NodeErr->Dynamic->Void):Void;
    @:overload(function (str:String,cb:NodeErr->Dynamic->Void):Void {})
    function gzip(buf:NodeBuffer,cb:NodeErr->Dynamic->Void):Void;
    @:overload(function (str:String,cb:NodeErr->Dynamic->Void):Void {})
    function gunzip(buf:NodeBuffer,cb:NodeErr->Dynamic->Void):Void;
    @:overload(function (str:String,cb:NodeErr->Dynamic->Void):Void {})
    function inflate(buf:NodeBuffer,cb:NodeErr->Dynamic->Void):Void;
    @:overload(function (str:String,cb:NodeErr->Dynamic->Void):Void {})
    function inflateRaw(buf:NodeBuffer,cb:NodeErr->Dynamic->Void):Void;
    @:overload(function (str:String,cb:NodeErr->Dynamic->Void):Void {})
    function unzip(buf:NodeBuffer,cb:NodeErr->Dynamic->Void):Void;
}

// Node Constants
class NodeC {
  public static inline var UTF8 = "utf8";
  public static inline var ASCII = "ascii";
  public static inline var BINARY = "binary";
  public static inline var BASE64 = "base64";
  public static inline var HEX = "hex";

  //events - thanks tmedema
  public static inline var EVENT_EVENTEMITTER_NEWLISTENER = "newListener";
	public static inline var EVENT_EVENTEMITTER_ERROR = "error";

	public static inline var EVENT_STREAM_DATA = "data";
	public static inline var EVENT_STREAM_END = "end";
	public static inline var EVENT_STREAM_ERROR = "error";
	public static inline var EVENT_STREAM_CLOSE = "close";
	public static inline var EVENT_STREAM_DRAIN = "drain";
	public static inline var EVENT_STREAM_CONNECT = "connect";
	public static inline var EVENT_STREAM_SECURE = "secure";
	public static inline var EVENT_STREAM_TIMEOUT = "timeout";
  public static inline var EVENT_STREAM_PIPE = "pipe";
  
  public static inline var EVENT_PROCESS_EXIT = "exit";
	public static inline var EVENT_PROCESS_UNCAUGHTEXCEPTION = "uncaughtException";
	public static inline var EVENT_PROCESS_SIGINT = "SIGINT";
	public static inline var EVENT_PROCESS_SIGUSR1 = "SIGUSR1";
	public static inline var EVENT_CHILDPROCESS_EXIT = "exit";
	public static inline var EVENT_HTTPSERVER_REQUEST = "request";
	public static inline var EVENT_HTTPSERVER_CONNECTION = "connection";
	public static inline var EVENT_HTTPSERVER_CLOSE = "close";
	public static inline var EVENT_HTTPSERVER_UPGRADE = "upgrade";
	public static inline var EVENT_HTTPSERVER_CLIENTERROR = "clientError";
	public static inline var EVENT_HTTPSERVERREQUEST_DATA = "data";
	public static inline var EVENT_HTTPSERVERREQUEST_END = "end";
	public static inline var EVENT_CLIENTREQUEST_RESPONSE = "response";
	public static inline var EVENT_CLIENTRESPONSE_DATA = "data";
	public static inline var EVENT_CLIENTRESPONSE_END = "end";
	public static inline var EVENT_NETSERVER_CONNECTION = "connection";
	public static inline var EVENT_NETSERVER_CLOSE = "close";

	public static inline var FILE_READ = "r";
	public static inline var FILE_READ_APPEND = "r+";
	public static inline var FILE_WRITE = "w";
	public static inline var FILE_WRITE_APPEND = "a+";
	public static inline var FILE_READWRITE = "a";
	public static inline var FILE_READWRITE_APPEND = "a+";
}

class Node {  
  public static var require(default,null) : String->Dynamic;
  public static var querystring(default,null) : NodeQueryString;
  public static var util(default,null) : NodeUtil;
  public static var fs(default,null) : NodeFS;
  public static var dgram(default,null) :NodeUDP ;
  public static var net(default,null) : NodeNet;
  public static var os(default,null) : NodeOs;
  public static var http(default,null) : NodeHttp;
  public static var https(default,null) : NodeHttps;
  public static var path(default,null) : NodePath;
  public static var url(default,null) : NodeUrl;
  public static var dns(default,null) : NodeDns;
  public static var vm(default,null) : NodeVM;
  public static var process(default,null) : NodeProcess;
  public static var tty(default,null) : NodeTTY;
  public static var assert(default,null) : NodeAssert;
  public static var crypto(default,null) : NodeCrypto;
  public static var tls(default,null) : NodeTLS;
  public static var repl(default,null) : NodeREPL;
  public static var childProcess(default,null) : NodeChildProcessCommands;
  public static var console(default,null) : NodeConsole;
  public static var cluster(default,null) : NodeCluster;
  
  //  public static var paths:Array<String>;
  public static var setTimeout:Dynamic->Int->?Array<Dynamic>->Int;
  public static var clearTimeout:Int->Void;
  public static var setInterval:Dynamic->Int->?Array<Dynamic>->Int;
  public static var clearInterval:Int->Void;  
  public static var global:Dynamic;
  
  public static var __filename:String;
  public static var __dirname:String;
  public static var module:Dynamic;
  public static var stringify:Dynamic->String;
  public static var parse:String->Dynamic;
  public static var queryString:NodeQueryString;
  
  public static function newSocket(?options):NodeNetSocket {
    return untyped __js__("new js.Node.net.Socket(options)");
  }
  
  public static function
  __init__() {
    __filename = untyped __js__('__filename');
    __dirname = untyped __js__('__dirname');

    setTimeout = untyped __js__('setTimeout');
    clearTimeout = untyped __js__('clearTimeout');
    setInterval = untyped __js__('setInterval');
    clearInterval = untyped __js__('clearInterval');
    global = untyped __js__('global');
    process = untyped __js__('process');
    require = untyped __js__('require');
    console = untyped __js__('console');
    module = untyped __js__('module');  // ref to the current module
    stringify = untyped __js__('JSON.stringify');
    parse = untyped __js__('JSON.parse');
   
    // just load everything, maybe not to everyone's taste
    util = require("util");
    fs = require("fs");
    net = require("net");
    http = require("http");
    https = require("https");
    path = require('path');
    url = require('url');
    os = require('os');
    crypto = require("crypto");
    dns = require("dns");
    queryString = require('querystring');
    assert = require('assert');
    childProcess = require('child_process');
    vm = require('vm');
    tls = require('tls');
    dgram = require('dgram');
    assert = require('assert');
    repl = require('repl');
    cluster = require("cluster");
  }
  
}



package js;

@:native("Stats")
extern class Stats {
    public var domElement : js.html.Element;
    public function new() : Void;
    public function setMode(m:Int) : Void;
    public function begin() : Void;
    public function end() : Void;
    public function update() : Void;
}

class StatsInit {
    private static function __init__() : Void untyped {
        #if !noEmbedJS
            #if debug
            haxe.macro.Compiler.includeFile("vendor/stats.js/stats-debug.js");
            #else
            haxe.macro.Compiler.includeFile("vendor/stats.js/stats-min.js");
            #end
        #end
    }
}

package ;

import flash.display.Sprite;
import flash.events.Event;
import flash.Lib;

class Main extends Sprite 
{
	var inited:Bool;
	var bg:Sprite;
	
	public static function main() 
	{
		Lib.current.addChild(new Main());
	}
	
	public function new() 
	{
		super();
		addEventListener(Event.ADDED_TO_STAGE, added);
	}

	function added(e:Event):Void 
	{
		removeEventListener(Event.ADDED_TO_STAGE, added);
		stage.addEventListener(Event.RESIZE, resize);
		
		#if ios
		haxe.Timer.delay(init, 100); // iOS 6
		#else
		init();
		#end
		
		bg = new Sprite();
		drawBg();
		addChild(bg);
		
		addChild(new Visualizer());
	}
	
	function resize(e:Event):Void 
	{
		if (!inited) {
			init();
		} else {
			drawBg();
		}
	}
	
	function drawBg():Void
	{
		bg.graphics.beginFill(0x252222);
		bg.graphics.drawRect(0, 0, Lib.current.stage.stageWidth, Lib.current.stage.stageHeight);
		bg.graphics.endFill();
	}
	
	function init():Void
	{
		if (inited) return;
		inited = true;

		Lib.current.stage.align = flash.display.StageAlign.TOP_LEFT;
		Lib.current.stage.scaleMode = flash.display.StageScaleMode.NO_SCALE;
	}
}

package org.msgpack;

import haxe.Int64;
import haxe.ds.IntMap;
import haxe.ds.StringMap;
import haxe.io.Bytes;
import haxe.io.BytesInput;
import haxe.io.Eof;

using Reflect;

enum DecodeOption {
	AsMap;
	AsObject;
}

private class Pair {

	public var k (default, null) : Dynamic;
	public var v (default, null) : Dynamic;

	public function new(k, v)
	{
		this.k = k;
		this.v = v;
	}
}

class Decoder {
	var o:Dynamic;

	public function new(b:Bytes, option:DecodeOption) {
		var i       = new BytesInput(b);
		i.bigEndian = true;
		o           = decode(i, option);
	}

	function decode(i:BytesInput, option:DecodeOption):Dynamic {
		try {
			var b = i.readByte();
			switch (b) {
				// null
				case 0xc0: return null;

				// boolean
				case 0xc2: return false;
				case 0xc3: return true;

				// binary
				case 0xc4: return i.read(i.readByte  ());
				case 0xc5: return i.read(i.readUInt16());
				case 0xc6: return i.read(i.readInt32 ());

				// floating point
				case 0xca: return i.readFloat ();
				case 0xcb: return i.readDouble();
				
				// unsigned int
				case 0xcc: return i.readByte  ();
				case 0xcd: return i.readUInt16();
				case 0xce: return i.readInt32 ();
				case 0xcf: throw "UInt64 not supported";

				// signed int
				case 0xd0: return i.readInt8 ();
				case 0xd1: return i.readInt16();
				case 0xd2: return i.readInt32();
				case 0xd3: return readInt64(i);

				// string
				case 0xd9: return i.readString(i.readByte  ());
				case 0xda: return i.readString(i.readUInt16());
				case 0xdb: return i.readString(i.readInt32 ());

				// array 16, 32
				case 0xdc: return readArray(i, i.readUInt16(), option);
				case 0xdd: return readArray(i, i.readInt32 (), option);

				// map 16, 32
				case 0xde: return readMap(i, i.readUInt16(), option);
				case 0xdf: return readMap(i, i.readInt32 (), option);

				default  : {
					if (b < 0x80) {	return b;                               } else // positive fix num
					if (b < 0x90) { return readMap  (i, (0xf & b), option); } else // fix map
					if (b < 0xa0) { return readArray(i, (0xf & b), option); } else // fix array
					if (b < 0xc0) { return i.readString(0x1f & b);          } else // fix string
					if (b > 0xdf) { return 0xffffff00 | b;                  }      // negative fix num
				}
			}
		} catch (e:Eof) {}
		return null;
	}

	function readInt64(i:BytesInput){
		var high = i.readInt32();
		var low = i.readInt32();
		return Int64.make(high, low);
	}

	function readArray(i:BytesInput, length:Int, option:DecodeOption) {
		var a = [];
		for(x in 0...length) {
			a.push(decode(i, option));
		}
		return a;
	}

	function readMap(i:BytesInput, length:Int, option:DecodeOption):Dynamic {
		switch (option) {
			case DecodeOption.AsObject:
				var out = {};
				for (n in 0...length) {
					var k = decode(i, option);
					var v = decode(i, option);
					Reflect.setField(out, Std.string(k), v);
				}

				return out;

			case DecodeOption.AsMap:
				var pairs = [];
				for (n in 0...length) {
					var k = decode(i, option);
					var v = decode(i, option);
					pairs.push(new Pair(k, v));
				}

				if (pairs.length == 0)
					return new StringMap();

				switch(Type.typeof(pairs[0].k))
				{
					case TInt:
						var out = new IntMap();
						for (p in pairs){
							switch(Type.typeof(p.k)){
								case TInt:
								default:  
									throw "Error: Mixed key type when decoding IntMap";
							}
							
							if (out.exists(p.k)) 
								throw 'Error: Duplicate keys found => ${p.k}';

							out.set(p.k, p.v);
						}

						return out;

					case TClass(c) if (Type.getClassName(c) == "String"):
						var out = new StringMap();
						for (p in pairs){
							switch(Type.typeof(p.k)){
								case TClass(c) if (Type.getClassName(c) == "String"):
								default: 
									throw "Error: Mixed key type when decoding StringMap";
							}

							if (out.exists(p.k)) 
								throw 'Error: Duplicate keys found => ${p.k}';
							
							out.set(p.k, p.v);
						}

						return out;

					default:
						throw "Error: Unsupported key Type";
				}
		}

		throw "Should not get here";
	}

	public inline function getResult() {
		return o;
	}
}